import { default as CameraControls } from 'camera-controls';
import { Camera, Object3D, OrthographicCamera, PerspectiveCamera, Box3, Matrix4, Quaternion, Raycaster, Sphere, Spherical, Vector2, Vector3, Vector4 } from 'three';

export interface CameraControlsProps {
    /**
     * Whether to make this the default controls.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    makeDefault?: boolean;
    /**
     * The camera to control.
     *
     * @type {PerspectiveCamera | OrthographicCamera}
     * @memberof CameraControlsProps
     */
    camera?: PerspectiveCamera | OrthographicCamera;
    /**
     * The dom element to listen to.
     *
     * @type {HTMLElement}
     * @memberof CameraControlsProps
     */
    domElement?: HTMLElement;
    /**
     * Minimum vertical angle in radians.
     * The angle has to be between `0` and `.maxPolarAngle` inclusive.
     *
     * @default 0
     * @type {number}
     * @memberof CameraControlsProps
     */
    minPolarAngle?: number;
    /**
     * Maximum vertical angle in radians.
     * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.
     *
     * @default Math.PI
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxPolarAngle?: number;
    /**
     * Minimum horizontal angle in radians.
     * The angle has to be less than `.maxAzimuthAngle`.
     *
     * @default -Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    minAzimuthAngle?: number;
    /**
     * Maximum horizontal angle in radians.
     * The angle has to be greater than `.minAzimuthAngle`.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxAzimuthAngle?: number;
    /**
     * Current disatnce.
     *
     * @type {number}
     * @memberof CameraControlsProps
     */
    distance?: number;
    /**
     * Minimum distance for dolly. The value must be higher than `0`.
     * PerspectiveCamera only.
     *
     * @default Number.EPSILON
     * @type {number}
     * @memberof CameraControlsProps
     */
    minDistance?: number;
    /**
     * Maximum distance for dolly. The value must be higher than `minDistance`.
     * PerspectiveCamera only.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxDistance?: number;
    /**
     * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`.
     * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`),
     * `infinityDolly` will keep the distance and pushes the target position instead.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    infinityDolly?: boolean;
    /**
     * Minimum camera zoom.
     *
     * @default 0.01
     * @type {number}
     * @memberof CameraControlsProps
     */
    minZoom?: number;
    /**
     * Maximum camera zoom.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxZoom?: number;
    /**
     * Approximate time in seconds to reach the target. A smaller value will reach the target faster.
     *
     * @default 0.25
     * @type {number}
     * @memberof CameraControlsProps
     */
    smoothTime?: number;
    /**
     * The smoothTime while dragging.
     *
     * @default 0.125
     * @type {number}
     * @memberof CameraControlsProps
     */
    draggingSmoothTime?: number;
    /**
     * Max transition speed in unit-per-seconds.
     *
     * @default Infinity
     * @type {number}
     * @memberof CameraControlsProps
     */
    maxSpeed?: number;
    /**
     * Speed of azimuth (horizontal) rotation.
     *
     * @default 1.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    azimuthRotateSpeed?: number;
    /**
     * Speed of polar (vertical) rotation.
     *
     * @default 1.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    polarRotateSpeed?: number;
    /**
     * Speed of mouse-wheel dollying.
     *
     * @default 1.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    dollySpeed?: number;
    /**
     * `true` to invert direction when dollying or zooming via drag.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    dollyDragInverted?: boolean;
    /**
     * Speed of drag for truck and pedestal.
     *
     * @default 2.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    truckSpeed?: number;
    /**
     * `true` to enable Dolly-in to the mouse cursor coords.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    dollyToCursor?: boolean;
    /**
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    dragToOffset?: boolean;
    /**
     * The same as `.screenSpacePanning` in three.js's OrbitControls.
     *
     * @default false
     * @type {boolean}
     * @memberof CameraControlsProps
     */
    verticalDragToForward?: boolean;
    /**
     * Friction ratio of the boundary.
     *
     * @default 0.0
     * @type {number}
     * @memberof CameraControlsProps
     */
    boundaryFriction?: number;
    /**
     * Controls how soon the `rest` event fires as the camera slows.
     *
     * @default 0.01
     * @type {number}
     * @memberof CameraControlsProps
     */
    restThreshold?: number;
    /**
     * An array of Meshes to collide with the camera.
     * Be aware colliderMeshes may decrease performance.
     * The collision test uses 4 raycasters from the camera since the near plane has 4 corners.
     *
     * @default []
     * @type {Object3D[]}
     * @memberof CameraControlsProps
     */
    colliderMeshes?: Object3D[];
    /**
     * User's mouse input config.
     *
     * | Button to assign        | Options                                                        | Default                                                         |
     * | ----------------------- | -------------------------------------------------------------- | --------------------------------------------------------------- |
     * | `mouseButtons.left`     | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `ROTATE`                                                        |
     * | `mouseButtons.right`    | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `TRUCK`                                                         |
     * | `mouseButtons.wheel` ¹  | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `DOLLY` for Perspective camera, `ZOOM` for Orthographic camera. |
     * | `mouseButtons.middle` ² | `ROTATE` \| `TRUCK` \| `OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE` | `DOLLY`                                                         |
     *
     * 1. Mouse wheel event for scroll "up/down", on mac "up/down/left/right".
     * 2. Mouse wheel "button" click event.
     *
     * > **_NOTE:_** `DOLLY` can't be set when camera is Orthographic.
     *
     * @default See description
     * @memberof CameraControlsProps
     */
    mouseButtons?: Partial<CameraControls['mouseButtons']>;
    /**
     * User's touch input config.
     *
     * | Fingers to assign | Options                                                                                                                                                                                                                                 | Default                                                                                |
     * | ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
     * | `touches.one`     | `TOUCH_ROTATE` \| `TOUCH_TRUCK` \| `TOUCH_OFFSET` \| `DOLLY` \| `ZOOM` \| `NONE`                                                                                                                                                        | `TOUCH_ROTATE`                                                                         |
     * | `touches.two`     | `TOUCH_DOLLY_TRUCK` \| `TOUCH_DOLLY_OFFSET` \| `TOUCH_DOLLY_ROTATE` \| `TOUCH_ZOOM_TRUCK` \| `TOUCH_ZOOM_OFFSET` \| `TOUCH_ZOOM_ROTATE` \| `TOUCH_DOLLY` \| `TOUCH_ZOOM` \| `TOUCH_ROTATE` \| `TOUCH_TRUCK` \| `TOUCH_OFFSET` \| `NONE` | `TOUCH_DOLLY_TRUCK` for Perspective camera, `TOUCH_ZOOM_TRUCK` for Othographic camera. |
     * | `touches.three`   | `TOUCH_DOLLY_TRUCK` \| `TOUCH_DOLLY_OFFSET` \| `TOUCH_DOLLY_ROTATE` \| `TOUCH_ZOOM_TRUCK` \| `TOUCH_ZOOM_OFFSET` \| `TOUCH_ZOOM_ROTATE` \| `TOUCH_ROTATE` \| `TOUCH_TRUCK` \| `TOUCH_OFFSET` \| `NONE`                                  | `TOUCH_TRUCK`                                                                          |
     *
     * > **_NOTE:_** `TOUCH_DOLLY_TRUCK` and `TOUCH_DOLLY` can't be set when camera is Orthographic.
     *
     * @default See description
     * @memberof CameraControlsProps
     */
    touches?: Partial<CameraControls['touches']>;
}
export { default as BaseCameraControls } from 'camera-controls';
declare const _default: import('vue').DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<CameraControlsProps>, {
    makeDefault: boolean;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    distance: () => number;
    minDistance: number;
    maxDistance: number;
    infinityDolly: boolean;
    minZoom: number;
    maxZoom: number;
    smoothTime: number;
    draggingSmoothTime: number;
    maxSpeed: number;
    azimuthRotateSpeed: number;
    polarRotateSpeed: number;
    dollySpeed: number;
    dollyDragInverted: boolean;
    truckSpeed: number;
    dollyToCursor: boolean;
    dragToOffset: boolean;
    verticalDragToForward: boolean;
    boundaryFriction: number;
    restThreshold: number;
    colliderMeshes: () => never[];
    mouseButtons: () => import('camera-controls/dist/types').MouseButtons;
    touches: () => import('camera-controls/dist/types').Touches;
}>, {
    value: import('vue').Ref<{
        minPolarAngle: number;
        maxPolarAngle: number;
        minAzimuthAngle: number;
        maxAzimuthAngle: number;
        minDistance: number;
        maxDistance: number;
        infinityDolly: boolean;
        minZoom: number;
        maxZoom: number;
        smoothTime: number;
        draggingSmoothTime: number;
        maxSpeed: number;
        azimuthRotateSpeed: number;
        polarRotateSpeed: number;
        dollySpeed: number;
        dollyDragInverted: boolean;
        truckSpeed: number;
        dollyToCursor: boolean;
        dragToOffset: boolean;
        verticalDragToForward: boolean;
        boundaryFriction: number;
        restThreshold: number;
        colliderMeshes: {
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            readonly type: string;
            parent: any | null;
            children: any[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => Quaternion;
                clone: () => Quaternion;
                copy: (q: import('three').QuaternionLike) => Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                setFromRotationMatrix: (m: Matrix4) => Quaternion;
                setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                angleTo: (q: Quaternion) => number;
                rotateTowards: (q: Quaternion, step: number) => Quaternion;
                identity: () => Quaternion;
                invert: () => Quaternion;
                conjugate: () => Quaternion;
                dot: (v: Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => Quaternion;
                multiply: (q: Quaternion) => Quaternion;
                premultiply: (q: Quaternion) => Quaternion;
                multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                slerp: (qb: Quaternion, t: number) => Quaternion;
                slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                equals: (v: Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                _onChange: (callback: () => void) => Quaternion;
                _onChangeCallback: () => void;
                random: () => Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => Vector3;
                        setScalar: (scalar: number) => Vector3;
                        setX: (x: number) => Vector3;
                        setY: (y: number) => Vector3;
                        setZ: (z: number) => Vector3;
                        setComponent: (index: number, value: number) => Vector3;
                        getComponent: (index: number) => number;
                        clone: () => Vector3;
                        copy: (v: import('three').Vector3Like) => Vector3;
                        add: (v: import('three').Vector3Like) => Vector3;
                        addScalar: (s: number) => Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        addScaledVector: (v: Vector3, s: number) => Vector3;
                        sub: (a: import('three').Vector3Like) => Vector3;
                        subScalar: (s: number) => Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        multiply: (v: import('three').Vector3Like) => Vector3;
                        multiplyScalar: (s: number) => Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        applyEuler: (euler: import('three').Euler) => Vector3;
                        applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                        applyMatrix4: (m: Matrix4) => Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                        project: (camera: Camera) => Vector3;
                        unproject: (camera: Camera) => Vector3;
                        transformDirection: (m: Matrix4) => Vector3;
                        divide: (v: import('three').Vector3Like) => Vector3;
                        divideScalar: (s: number) => Vector3;
                        min: (v: import('three').Vector3Like) => Vector3;
                        max: (v: import('three').Vector3Like) => Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                        clampScalar: (min: number, max: number) => Vector3;
                        clampLength: (min: number, max: number) => Vector3;
                        floor: () => Vector3;
                        ceil: () => Vector3;
                        round: () => Vector3;
                        roundToZero: () => Vector3;
                        negate: () => Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => Vector3;
                        setLength: (l: number) => Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                        cross: (a: import('three').Vector3Like) => Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        projectOnVector: (v: Vector3) => Vector3;
                        projectOnPlane: (planeNormal: Vector3) => Vector3;
                        reflect: (vector: import('three').Vector3Like) => Vector3;
                        angleTo: (v: Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: Spherical) => Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                        setFromMatrixPosition: (m: Matrix4) => Vector3;
                        setFromMatrixScale: (m: Matrix4) => Vector3;
                        setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                        setFromEuler: (e: import('three').Euler) => Vector3;
                        setFromColor: (color: import('three').RGB) => Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                        random: () => Vector3;
                        randomDirection: () => Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: Vector3) => number;
                    distanceToSphere: (sphere: Sphere) => number;
                    projectPoint: (point: Vector3, target: Vector3) => Vector3;
                    intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: Box3) => boolean;
                    intersectsSphere: (sphere: Sphere) => boolean;
                    coplanarPoint: (target: Vector3) => Vector3;
                    applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => Vector3;
                        setScalar: (scalar: number) => Vector3;
                        setX: (x: number) => Vector3;
                        setY: (y: number) => Vector3;
                        setZ: (z: number) => Vector3;
                        setComponent: (index: number, value: number) => Vector3;
                        getComponent: (index: number) => number;
                        clone: () => Vector3;
                        copy: (v: import('three').Vector3Like) => Vector3;
                        add: (v: import('three').Vector3Like) => Vector3;
                        addScalar: (s: number) => Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        addScaledVector: (v: Vector3, s: number) => Vector3;
                        sub: (a: import('three').Vector3Like) => Vector3;
                        subScalar: (s: number) => Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        multiply: (v: import('three').Vector3Like) => Vector3;
                        multiplyScalar: (s: number) => Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        applyEuler: (euler: import('three').Euler) => Vector3;
                        applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                        applyMatrix4: (m: Matrix4) => Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                        project: (camera: Camera) => Vector3;
                        unproject: (camera: Camera) => Vector3;
                        transformDirection: (m: Matrix4) => Vector3;
                        divide: (v: import('three').Vector3Like) => Vector3;
                        divideScalar: (s: number) => Vector3;
                        min: (v: import('three').Vector3Like) => Vector3;
                        max: (v: import('three').Vector3Like) => Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                        clampScalar: (min: number, max: number) => Vector3;
                        clampLength: (min: number, max: number) => Vector3;
                        floor: () => Vector3;
                        ceil: () => Vector3;
                        round: () => Vector3;
                        roundToZero: () => Vector3;
                        negate: () => Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => Vector3;
                        setLength: (l: number) => Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                        cross: (a: import('three').Vector3Like) => Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        projectOnVector: (v: Vector3) => Vector3;
                        projectOnPlane: (planeNormal: Vector3) => Vector3;
                        reflect: (vector: import('three').Vector3Like) => Vector3;
                        angleTo: (v: Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: Spherical) => Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                        setFromMatrixPosition: (m: Matrix4) => Vector3;
                        setFromMatrixScale: (m: Matrix4) => Vector3;
                        setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                        setFromEuler: (e: import('three').Euler) => Vector3;
                        setFromColor: (color: import('three').RGB) => Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                        random: () => Vector3;
                        randomDirection: () => Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: Vector3) => number;
                    distanceToSphere: (sphere: Sphere) => number;
                    projectPoint: (point: Vector3, target: Vector3) => Vector3;
                    intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: Box3) => boolean;
                    intersectsSphere: (sphere: Sphere) => boolean;
                    coplanarPoint: (target: Vector3) => Vector3;
                    applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            applyMatrix4: (matrix: Matrix4) => void;
            applyQuaternion: (quaternion: Quaternion) => Object3D<import('three').Object3DEventMap>;
            setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: Matrix4) => void;
            setRotationFromQuaternion: (q: Quaternion) => void;
            rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
            rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
            rotateX: (angle: number) => Object3D<import('three').Object3DEventMap>;
            rotateY: (angle: number) => Object3D<import('three').Object3DEventMap>;
            rotateZ: (angle: number) => Object3D<import('three').Object3DEventMap>;
            translateOnAxis: (axis: Vector3, distance: number) => Object3D<import('three').Object3DEventMap>;
            translateX: (distance: number) => Object3D<import('three').Object3DEventMap>;
            translateY: (distance: number) => Object3D<import('three').Object3DEventMap>;
            translateZ: (distance: number) => Object3D<import('three').Object3DEventMap>;
            localToWorld: (vector: Vector3) => Vector3;
            worldToLocal: (vector: Vector3) => Vector3;
            lookAt: {
                (vector: Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
            remove: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
            removeFromParent: () => Object3D<import('three').Object3DEventMap>;
            clear: () => Object3D<import('three').Object3DEventMap>;
            attach: (object: Object3D<import('three').Object3DEventMap>) => Object3D<import('three').Object3DEventMap>;
            getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
            getWorldPosition: (target: Vector3) => Vector3;
            getWorldQuaternion: (target: Quaternion) => Quaternion;
            getWorldScale: (target: Vector3) => Vector3;
            getWorldDirection: (target: Vector3) => Vector3;
            raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
            traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
            copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
            addEventListener: {
                <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, Object3D<import('three').Object3DEventMap>>): void;
                <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, Object3D<import('three').Object3DEventMap>>): void;
            };
            hasEventListener: {
                <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, Object3D<import('three').Object3DEventMap>>): boolean;
                <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, Object3D<import('three').Object3DEventMap>>): boolean;
            };
            removeEventListener: {
                <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, Object3D<import('three').Object3DEventMap>>): void;
                <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, Object3D<import('three').Object3DEventMap>>): void;
            };
            dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
        }[];
        mouseButtons: {
            left: 0 | 2 | 1 | 4 | 8 | 16;
            middle: 0 | 2 | 1 | 4 | 8 | 16;
            right: 0 | 2 | 1 | 4 | 8 | 16;
            wheel: 0 | 2 | 1 | 4 | 8 | 16;
        };
        touches: {
            one: 0 | 8 | 16 | 32 | 64 | 128;
            two: 0 | 1024 | 512 | 32 | 64 | 128 | 8192 | 4096 | 2048 | 32768 | 16384 | 256;
            three: 0 | 1024 | 512 | 32 | 64 | 128 | 8192 | 4096 | 2048 | 32768 | 16384 | 256;
        };
        cancel: () => void;
        lockPointer: () => void;
        unlockPointer: () => void;
        camera: {
            readonly isPerspectiveCamera: true;
            readonly type: string;
            zoom: number;
            fov: number;
            aspect: number;
            near: number;
            far: number;
            focus: number;
            view: {
                enabled: boolean;
                fullWidth: number;
                fullHeight: number;
                offsetX: number;
                offsetY: number;
                width: number;
                height: number;
            } | null;
            filmGauge: number;
            filmOffset: number;
            getFocalLength: () => number;
            setFocalLength: (focalLength: number) => void;
            getEffectiveFOV: () => number;
            getFilmWidth: () => number;
            getFilmHeight: () => number;
            getViewBounds: (distance: number, minTarget: Vector2, maxTarget: Vector2) => void;
            getViewSize: (distance: number, target: Vector2) => Vector2;
            setViewOffset: (fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number) => void;
            clearViewOffset: () => void;
            updateProjectionMatrix: () => void;
            setLens: (focalLength: number, frameHeight?: number | undefined) => void;
            readonly isCamera: true;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            coordinateSystem: import('three').CoordinateSystem;
            viewport?: {
                x: number;
                y: number;
                z: number;
                w: number;
                width: number;
                height: number;
                readonly isVector4: true;
                set: (x: number, y: number, z: number, w: number) => Vector4;
                setScalar: (scalar: number) => Vector4;
                setX: (x: number) => Vector4;
                setY: (y: number) => Vector4;
                setZ: (z: number) => Vector4;
                setW: (w: number) => Vector4;
                setComponent: (index: number, value: number) => Vector4;
                getComponent: (index: number) => number;
                clone: () => Vector4;
                copy: (v: import('three').Vector4Like) => Vector4;
                add: (v: import('three').Vector4Like) => Vector4;
                addScalar: (scalar: number) => Vector4;
                addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => Vector4;
                addScaledVector: (v: import('three').Vector4Like, s: number) => Vector4;
                sub: (v: import('three').Vector4Like) => Vector4;
                subScalar: (s: number) => Vector4;
                subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => Vector4;
                multiply: (v: import('three').Vector4Like) => Vector4;
                multiplyScalar: (s: number) => Vector4;
                applyMatrix4: (m: Matrix4) => Vector4;
                divideScalar: (s: number) => Vector4;
                setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => Vector4;
                setAxisAngleFromRotationMatrix: (m: Matrix4) => Vector4;
                min: (v: import('three').Vector4Like) => Vector4;
                max: (v: import('three').Vector4Like) => Vector4;
                clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => Vector4;
                clampScalar: (min: number, max: number) => Vector4;
                floor: () => Vector4;
                ceil: () => Vector4;
                round: () => Vector4;
                roundToZero: () => Vector4;
                negate: () => Vector4;
                dot: (v: import('three').Vector4Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector4;
                setLength: (length: number) => Vector4;
                lerp: (v: import('three').Vector4Like, alpha: number) => Vector4;
                lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => Vector4;
                equals: (v: import('three').Vector4Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector4Tuple | undefined, offset?: 0 | undefined): import('three').Vector4Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => Vector4;
                random: () => Vector4;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            } | undefined;
            getWorldDirection: (target: Vector3) => Vector3;
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            parent: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: import('three').QuaternionLike) => Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                remove: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => Object3D<import('three').Object3DEventMap>;
                clear: () => Object3D<import('three').Object3DEventMap>;
                attach: (object: Object3D<import('three').Object3DEventMap>) => Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            } | null;
            children: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: import('three').QuaternionLike) => Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                remove: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => Object3D<import('three').Object3DEventMap>;
                clear: () => Object3D<import('three').Object3DEventMap>;
                attach: (object: Object3D<import('three').Object3DEventMap>) => Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => Quaternion;
                clone: () => Quaternion;
                copy: (q: import('three').QuaternionLike) => Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                setFromRotationMatrix: (m: Matrix4) => Quaternion;
                setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                angleTo: (q: Quaternion) => number;
                rotateTowards: (q: Quaternion, step: number) => Quaternion;
                identity: () => Quaternion;
                invert: () => Quaternion;
                conjugate: () => Quaternion;
                dot: (v: Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => Quaternion;
                multiply: (q: Quaternion) => Quaternion;
                premultiply: (q: Quaternion) => Quaternion;
                multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                slerp: (qb: Quaternion, t: number) => Quaternion;
                slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                equals: (v: Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                _onChange: (callback: () => void) => Quaternion;
                _onChangeCallback: () => void;
                random: () => Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => Vector3;
                        setScalar: (scalar: number) => Vector3;
                        setX: (x: number) => Vector3;
                        setY: (y: number) => Vector3;
                        setZ: (z: number) => Vector3;
                        setComponent: (index: number, value: number) => Vector3;
                        getComponent: (index: number) => number;
                        clone: () => Vector3;
                        copy: (v: import('three').Vector3Like) => Vector3;
                        add: (v: import('three').Vector3Like) => Vector3;
                        addScalar: (s: number) => Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        addScaledVector: (v: Vector3, s: number) => Vector3;
                        sub: (a: import('three').Vector3Like) => Vector3;
                        subScalar: (s: number) => Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        multiply: (v: import('three').Vector3Like) => Vector3;
                        multiplyScalar: (s: number) => Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        applyEuler: (euler: import('three').Euler) => Vector3;
                        applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                        applyMatrix4: (m: Matrix4) => Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                        project: (camera: Camera) => Vector3;
                        unproject: (camera: Camera) => Vector3;
                        transformDirection: (m: Matrix4) => Vector3;
                        divide: (v: import('three').Vector3Like) => Vector3;
                        divideScalar: (s: number) => Vector3;
                        min: (v: import('three').Vector3Like) => Vector3;
                        max: (v: import('three').Vector3Like) => Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                        clampScalar: (min: number, max: number) => Vector3;
                        clampLength: (min: number, max: number) => Vector3;
                        floor: () => Vector3;
                        ceil: () => Vector3;
                        round: () => Vector3;
                        roundToZero: () => Vector3;
                        negate: () => Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => Vector3;
                        setLength: (l: number) => Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                        cross: (a: import('three').Vector3Like) => Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        projectOnVector: (v: Vector3) => Vector3;
                        projectOnPlane: (planeNormal: Vector3) => Vector3;
                        reflect: (vector: import('three').Vector3Like) => Vector3;
                        angleTo: (v: Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: Spherical) => Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                        setFromMatrixPosition: (m: Matrix4) => Vector3;
                        setFromMatrixScale: (m: Matrix4) => Vector3;
                        setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                        setFromEuler: (e: import('three').Euler) => Vector3;
                        setFromColor: (color: import('three').RGB) => Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                        random: () => Vector3;
                        randomDirection: () => Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: Vector3) => number;
                    distanceToSphere: (sphere: Sphere) => number;
                    projectPoint: (point: Vector3, target: Vector3) => Vector3;
                    intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: Box3) => boolean;
                    intersectsSphere: (sphere: Sphere) => boolean;
                    coplanarPoint: (target: Vector3) => Vector3;
                    applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => Vector3;
                        setScalar: (scalar: number) => Vector3;
                        setX: (x: number) => Vector3;
                        setY: (y: number) => Vector3;
                        setZ: (z: number) => Vector3;
                        setComponent: (index: number, value: number) => Vector3;
                        getComponent: (index: number) => number;
                        clone: () => Vector3;
                        copy: (v: import('three').Vector3Like) => Vector3;
                        add: (v: import('three').Vector3Like) => Vector3;
                        addScalar: (s: number) => Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        addScaledVector: (v: Vector3, s: number) => Vector3;
                        sub: (a: import('three').Vector3Like) => Vector3;
                        subScalar: (s: number) => Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        multiply: (v: import('three').Vector3Like) => Vector3;
                        multiplyScalar: (s: number) => Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        applyEuler: (euler: import('three').Euler) => Vector3;
                        applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                        applyMatrix4: (m: Matrix4) => Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                        project: (camera: Camera) => Vector3;
                        unproject: (camera: Camera) => Vector3;
                        transformDirection: (m: Matrix4) => Vector3;
                        divide: (v: import('three').Vector3Like) => Vector3;
                        divideScalar: (s: number) => Vector3;
                        min: (v: import('three').Vector3Like) => Vector3;
                        max: (v: import('three').Vector3Like) => Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                        clampScalar: (min: number, max: number) => Vector3;
                        clampLength: (min: number, max: number) => Vector3;
                        floor: () => Vector3;
                        ceil: () => Vector3;
                        round: () => Vector3;
                        roundToZero: () => Vector3;
                        negate: () => Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => Vector3;
                        setLength: (l: number) => Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                        cross: (a: import('three').Vector3Like) => Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        projectOnVector: (v: Vector3) => Vector3;
                        projectOnPlane: (planeNormal: Vector3) => Vector3;
                        reflect: (vector: import('three').Vector3Like) => Vector3;
                        angleTo: (v: Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: Spherical) => Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                        setFromMatrixPosition: (m: Matrix4) => Vector3;
                        setFromMatrixScale: (m: Matrix4) => Vector3;
                        setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                        setFromEuler: (e: import('three').Euler) => Vector3;
                        setFromColor: (color: import('three').RGB) => Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                        random: () => Vector3;
                        randomDirection: () => Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: Vector3) => number;
                    distanceToSphere: (sphere: Sphere) => number;
                    projectPoint: (point: Vector3, target: Vector3) => Vector3;
                    intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: Box3) => boolean;
                    intersectsSphere: (sphere: Sphere) => boolean;
                    coplanarPoint: (target: Vector3) => Vector3;
                    applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            applyMatrix4: (matrix: Matrix4) => void;
            applyQuaternion: (quaternion: Quaternion) => PerspectiveCamera;
            setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: Matrix4) => void;
            setRotationFromQuaternion: (q: Quaternion) => void;
            rotateOnAxis: (axis: Vector3, angle: number) => PerspectiveCamera;
            rotateOnWorldAxis: (axis: Vector3, angle: number) => PerspectiveCamera;
            rotateX: (angle: number) => PerspectiveCamera;
            rotateY: (angle: number) => PerspectiveCamera;
            rotateZ: (angle: number) => PerspectiveCamera;
            translateOnAxis: (axis: Vector3, distance: number) => PerspectiveCamera;
            translateX: (distance: number) => PerspectiveCamera;
            translateY: (distance: number) => PerspectiveCamera;
            translateZ: (distance: number) => PerspectiveCamera;
            localToWorld: (vector: Vector3) => Vector3;
            worldToLocal: (vector: Vector3) => Vector3;
            lookAt: {
                (vector: Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: Object3D<import('three').Object3DEventMap>[]) => PerspectiveCamera;
            remove: (...object: Object3D<import('three').Object3DEventMap>[]) => PerspectiveCamera;
            removeFromParent: () => PerspectiveCamera;
            clear: () => PerspectiveCamera;
            attach: (object: Object3D<import('three').Object3DEventMap>) => PerspectiveCamera;
            getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
            getWorldPosition: (target: Vector3) => Vector3;
            getWorldQuaternion: (target: Quaternion) => Quaternion;
            getWorldScale: (target: Vector3) => Vector3;
            raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
            traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => PerspectiveCamera;
            copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => PerspectiveCamera;
            addEventListener: {
                <T_14 extends keyof import('three').Object3DEventMap>(type: T_14, listener: import('three').EventListener<import('three').Object3DEventMap[T_14], T_14, PerspectiveCamera>): void;
                <T_15 extends string>(type: T_15, listener: import('three').EventListener<{}, T_15, PerspectiveCamera>): void;
            };
            hasEventListener: {
                <T_16 extends keyof import('three').Object3DEventMap>(type: T_16, listener: import('three').EventListener<import('three').Object3DEventMap[T_16], T_16, PerspectiveCamera>): boolean;
                <T_17 extends string>(type: T_17, listener: import('three').EventListener<{}, T_17, PerspectiveCamera>): boolean;
            };
            removeEventListener: {
                <T_18 extends keyof import('three').Object3DEventMap>(type: T_18, listener: import('three').EventListener<import('three').Object3DEventMap[T_18], T_18, PerspectiveCamera>): void;
                <T_19 extends string>(type: T_19, listener: import('three').EventListener<{}, T_19, PerspectiveCamera>): void;
            };
            dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
        } | {
            readonly isOrthographicCamera: true;
            readonly type: string;
            zoom: number;
            view: {
                enabled: boolean;
                fullWidth: number;
                fullHeight: number;
                offsetX: number;
                offsetY: number;
                width: number;
                height: number;
            } | null;
            left: number;
            right: number;
            top: number;
            bottom: number;
            near: number;
            far: number;
            updateProjectionMatrix: () => void;
            setViewOffset: (fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: number) => void;
            clearViewOffset: () => void;
            readonly isCamera: true;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            coordinateSystem: import('three').CoordinateSystem;
            viewport?: {
                x: number;
                y: number;
                z: number;
                w: number;
                width: number;
                height: number;
                readonly isVector4: true;
                set: (x: number, y: number, z: number, w: number) => Vector4;
                setScalar: (scalar: number) => Vector4;
                setX: (x: number) => Vector4;
                setY: (y: number) => Vector4;
                setZ: (z: number) => Vector4;
                setW: (w: number) => Vector4;
                setComponent: (index: number, value: number) => Vector4;
                getComponent: (index: number) => number;
                clone: () => Vector4;
                copy: (v: import('three').Vector4Like) => Vector4;
                add: (v: import('three').Vector4Like) => Vector4;
                addScalar: (scalar: number) => Vector4;
                addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => Vector4;
                addScaledVector: (v: import('three').Vector4Like, s: number) => Vector4;
                sub: (v: import('three').Vector4Like) => Vector4;
                subScalar: (s: number) => Vector4;
                subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => Vector4;
                multiply: (v: import('three').Vector4Like) => Vector4;
                multiplyScalar: (s: number) => Vector4;
                applyMatrix4: (m: Matrix4) => Vector4;
                divideScalar: (s: number) => Vector4;
                setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => Vector4;
                setAxisAngleFromRotationMatrix: (m: Matrix4) => Vector4;
                min: (v: import('three').Vector4Like) => Vector4;
                max: (v: import('three').Vector4Like) => Vector4;
                clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => Vector4;
                clampScalar: (min: number, max: number) => Vector4;
                floor: () => Vector4;
                ceil: () => Vector4;
                round: () => Vector4;
                roundToZero: () => Vector4;
                negate: () => Vector4;
                dot: (v: import('three').Vector4Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector4;
                setLength: (length: number) => Vector4;
                lerp: (v: import('three').Vector4Like, alpha: number) => Vector4;
                lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => Vector4;
                equals: (v: import('three').Vector4Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector4Tuple | undefined, offset?: 0 | undefined): import('three').Vector4Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => Vector4;
                random: () => Vector4;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            } | undefined;
            getWorldDirection: (target: Vector3) => Vector3;
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            parent: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: import('three').QuaternionLike) => Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                remove: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => Object3D<import('three').Object3DEventMap>;
                clear: () => Object3D<import('three').Object3DEventMap>;
                attach: (object: Object3D<import('three').Object3DEventMap>) => Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            } | null;
            children: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => Quaternion;
                    clone: () => Quaternion;
                    copy: (q: import('three').QuaternionLike) => Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                    setFromRotationMatrix: (m: Matrix4) => Quaternion;
                    setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                    angleTo: (q: Quaternion) => number;
                    rotateTowards: (q: Quaternion, step: number) => Quaternion;
                    identity: () => Quaternion;
                    invert: () => Quaternion;
                    conjugate: () => Quaternion;
                    dot: (v: Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => Quaternion;
                    multiply: (q: Quaternion) => Quaternion;
                    premultiply: (q: Quaternion) => Quaternion;
                    multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                    slerp: (qb: Quaternion, t: number) => Quaternion;
                    slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                    equals: (v: Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                    _onChange: (callback: () => void) => Quaternion;
                    _onChangeCallback: () => void;
                    random: () => Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => Vector3;
                    setScalar: (scalar: number) => Vector3;
                    setX: (x: number) => Vector3;
                    setY: (y: number) => Vector3;
                    setZ: (z: number) => Vector3;
                    setComponent: (index: number, value: number) => Vector3;
                    getComponent: (index: number) => number;
                    clone: () => Vector3;
                    copy: (v: import('three').Vector3Like) => Vector3;
                    add: (v: import('three').Vector3Like) => Vector3;
                    addScalar: (s: number) => Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    addScaledVector: (v: Vector3, s: number) => Vector3;
                    sub: (a: import('three').Vector3Like) => Vector3;
                    subScalar: (s: number) => Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    multiply: (v: import('three').Vector3Like) => Vector3;
                    multiplyScalar: (s: number) => Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    applyEuler: (euler: import('three').Euler) => Vector3;
                    applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                    applyMatrix4: (m: Matrix4) => Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                    project: (camera: Camera) => Vector3;
                    unproject: (camera: Camera) => Vector3;
                    transformDirection: (m: Matrix4) => Vector3;
                    divide: (v: import('three').Vector3Like) => Vector3;
                    divideScalar: (s: number) => Vector3;
                    min: (v: import('three').Vector3Like) => Vector3;
                    max: (v: import('three').Vector3Like) => Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                    clampScalar: (min: number, max: number) => Vector3;
                    clampLength: (min: number, max: number) => Vector3;
                    floor: () => Vector3;
                    ceil: () => Vector3;
                    round: () => Vector3;
                    roundToZero: () => Vector3;
                    negate: () => Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => Vector3;
                    setLength: (l: number) => Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                    cross: (a: import('three').Vector3Like) => Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                    projectOnVector: (v: Vector3) => Vector3;
                    projectOnPlane: (planeNormal: Vector3) => Vector3;
                    reflect: (vector: import('three').Vector3Like) => Vector3;
                    angleTo: (v: Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: Spherical) => Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                    setFromMatrixPosition: (m: Matrix4) => Vector3;
                    setFromMatrixScale: (m: Matrix4) => Vector3;
                    setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                    setFromEuler: (e: import('three').Euler) => Vector3;
                    setFromColor: (color: import('three').RGB) => Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                    random: () => Vector3;
                    randomDirection: () => Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                    identity: () => Matrix4;
                    clone: () => Matrix4;
                    copy: (m: Matrix4) => Matrix4;
                    copyPosition: (m: Matrix4) => Matrix4;
                    extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                    extractRotation: (m: Matrix4) => Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                    makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                    multiply: (m: Matrix4) => Matrix4;
                    premultiply: (m: Matrix4) => Matrix4;
                    multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                    multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                    multiplyScalar: (s: number) => Matrix4;
                    determinant: () => number;
                    transpose: () => Matrix4;
                    setPosition: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    invert: () => Matrix4;
                    scale: (v: Vector3) => Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: Vector3): Matrix4;
                        (x: number, y: number, z: number): Matrix4;
                    };
                    makeRotationX: (theta: number) => Matrix4;
                    makeRotationY: (theta: number) => Matrix4;
                    makeRotationZ: (theta: number) => Matrix4;
                    makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                    makeScale: (x: number, y: number, z: number) => Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                    compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                    equals: (matrix: Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                    extractPosition: (m: Matrix4) => Matrix4;
                    setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => Vector3;
                            setScalar: (scalar: number) => Vector3;
                            setX: (x: number) => Vector3;
                            setY: (y: number) => Vector3;
                            setZ: (z: number) => Vector3;
                            setComponent: (index: number, value: number) => Vector3;
                            getComponent: (index: number) => number;
                            clone: () => Vector3;
                            copy: (v: import('three').Vector3Like) => Vector3;
                            add: (v: import('three').Vector3Like) => Vector3;
                            addScalar: (s: number) => Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            addScaledVector: (v: Vector3, s: number) => Vector3;
                            sub: (a: import('three').Vector3Like) => Vector3;
                            subScalar: (s: number) => Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            multiply: (v: import('three').Vector3Like) => Vector3;
                            multiplyScalar: (s: number) => Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            applyEuler: (euler: import('three').Euler) => Vector3;
                            applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                            applyMatrix4: (m: Matrix4) => Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                            project: (camera: Camera) => Vector3;
                            unproject: (camera: Camera) => Vector3;
                            transformDirection: (m: Matrix4) => Vector3;
                            divide: (v: import('three').Vector3Like) => Vector3;
                            divideScalar: (s: number) => Vector3;
                            min: (v: import('three').Vector3Like) => Vector3;
                            max: (v: import('three').Vector3Like) => Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                            clampScalar: (min: number, max: number) => Vector3;
                            clampLength: (min: number, max: number) => Vector3;
                            floor: () => Vector3;
                            ceil: () => Vector3;
                            round: () => Vector3;
                            roundToZero: () => Vector3;
                            negate: () => Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => Vector3;
                            setLength: (l: number) => Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                            cross: (a: import('three').Vector3Like) => Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                            projectOnVector: (v: Vector3) => Vector3;
                            projectOnPlane: (planeNormal: Vector3) => Vector3;
                            reflect: (vector: import('three').Vector3Like) => Vector3;
                            angleTo: (v: Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: Spherical) => Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                            setFromMatrixPosition: (m: Matrix4) => Vector3;
                            setFromMatrixScale: (m: Matrix4) => Vector3;
                            setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                            setFromEuler: (e: import('three').Euler) => Vector3;
                            setFromColor: (color: import('three').RGB) => Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                            random: () => Vector3;
                            randomDirection: () => Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: Vector3) => number;
                        distanceToSphere: (sphere: Sphere) => number;
                        projectPoint: (point: Vector3, target: Vector3) => Vector3;
                        intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: Box3) => boolean;
                        intersectsSphere: (sphere: Sphere) => boolean;
                        coplanarPoint: (target: Vector3) => Vector3;
                        applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: Matrix4) => void;
                applyQuaternion: (quaternion: Quaternion) => Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: Matrix4) => void;
                setRotationFromQuaternion: (q: Quaternion) => void;
                rotateOnAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: Vector3, angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: Vector3, distance: number) => Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: Vector3) => Vector3;
                worldToLocal: (vector: Vector3) => Vector3;
                lookAt: {
                    (vector: Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                remove: (...object: Object3D<import('three').Object3DEventMap>[]) => Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => Object3D<import('three').Object3DEventMap>;
                clear: () => Object3D<import('three').Object3DEventMap>;
                attach: (object: Object3D<import('three').Object3DEventMap>) => Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: Vector3) => Vector3;
                getWorldQuaternion: (target: Quaternion) => Quaternion;
                getWorldScale: (target: Vector3) => Vector3;
                getWorldDirection: (target: Vector3) => Vector3;
                raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromQuaternion: (q: Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromVector3: (v: Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => Quaternion;
                clone: () => Quaternion;
                copy: (q: import('three').QuaternionLike) => Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => Quaternion;
                setFromRotationMatrix: (m: Matrix4) => Quaternion;
                setFromUnitVectors: (vFrom: Vector3, vTo: import('three').Vector3Like) => Quaternion;
                angleTo: (q: Quaternion) => number;
                rotateTowards: (q: Quaternion, step: number) => Quaternion;
                identity: () => Quaternion;
                invert: () => Quaternion;
                conjugate: () => Quaternion;
                dot: (v: Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => Quaternion;
                multiply: (q: Quaternion) => Quaternion;
                premultiply: (q: Quaternion) => Quaternion;
                multiplyQuaternions: (a: Quaternion, b: Quaternion) => Quaternion;
                slerp: (qb: Quaternion, t: number) => Quaternion;
                slerpQuaternions: (qa: Quaternion, qb: Quaternion, t: number) => Quaternion;
                equals: (v: Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Quaternion;
                _onChange: (callback: () => void) => Quaternion;
                _onChangeCallback: () => void;
                random: () => Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: import('three').Vector3Like) => Vector3;
                add: (v: import('three').Vector3Like) => Vector3;
                addScalar: (s: number) => Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                sub: (a: import('three').Vector3Like) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                multiply: (v: import('three').Vector3Like) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                applyEuler: (euler: import('three').Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import('three').Matrix3) => Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                applyMatrix4: (m: Matrix4) => Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                project: (camera: Camera) => Vector3;
                unproject: (camera: Camera) => Vector3;
                transformDirection: (m: Matrix4) => Vector3;
                divide: (v: import('three').Vector3Like) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: import('three').Vector3Like) => Vector3;
                max: (v: import('three').Vector3Like) => Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                cross: (a: import('three').Vector3Like) => Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: import('three').Vector3Like) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: Matrix4) => Vector3;
                setFromMatrixScale: (m: Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                setFromEuler: (e: import('three').Euler) => Vector3;
                setFromColor: (color: import('three').RGB) => Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => Matrix4;
                identity: () => Matrix4;
                clone: () => Matrix4;
                copy: (m: Matrix4) => Matrix4;
                copyPosition: (m: Matrix4) => Matrix4;
                extractBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                makeBasis: (xAxis: Vector3, yAxis: Vector3, zAxis: Vector3) => Matrix4;
                extractRotation: (m: Matrix4) => Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => Matrix4;
                makeRotationFromQuaternion: (q: Quaternion) => Matrix4;
                lookAt: (eye: Vector3, target: Vector3, up: Vector3) => Matrix4;
                multiply: (m: Matrix4) => Matrix4;
                premultiply: (m: Matrix4) => Matrix4;
                multiplyMatrices: (a: Matrix4, b: Matrix4) => Matrix4;
                multiplyToArray: (a: Matrix4, b: Matrix4, r: number[]) => Matrix4;
                multiplyScalar: (s: number) => Matrix4;
                determinant: () => number;
                transpose: () => Matrix4;
                setPosition: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                invert: () => Matrix4;
                scale: (v: Vector3) => Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: Vector3): Matrix4;
                    (x: number, y: number, z: number): Matrix4;
                };
                makeRotationX: (theta: number) => Matrix4;
                makeRotationY: (theta: number) => Matrix4;
                makeRotationZ: (theta: number) => Matrix4;
                makeRotationAxis: (axis: Vector3, angle: number) => Matrix4;
                makeScale: (x: number, y: number, z: number) => Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => Matrix4;
                compose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                decompose: (translation: Vector3, rotation: Quaternion, scale: Vector3) => Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => Matrix4;
                equals: (matrix: Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => Matrix4;
                extractPosition: (m: Matrix4) => Matrix4;
                setRotationFromQuaternion: (q: Quaternion) => Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => Vector3;
                        setScalar: (scalar: number) => Vector3;
                        setX: (x: number) => Vector3;
                        setY: (y: number) => Vector3;
                        setZ: (z: number) => Vector3;
                        setComponent: (index: number, value: number) => Vector3;
                        getComponent: (index: number) => number;
                        clone: () => Vector3;
                        copy: (v: import('three').Vector3Like) => Vector3;
                        add: (v: import('three').Vector3Like) => Vector3;
                        addScalar: (s: number) => Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        addScaledVector: (v: Vector3, s: number) => Vector3;
                        sub: (a: import('three').Vector3Like) => Vector3;
                        subScalar: (s: number) => Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        multiply: (v: import('three').Vector3Like) => Vector3;
                        multiplyScalar: (s: number) => Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        applyEuler: (euler: import('three').Euler) => Vector3;
                        applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                        applyMatrix4: (m: Matrix4) => Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                        project: (camera: Camera) => Vector3;
                        unproject: (camera: Camera) => Vector3;
                        transformDirection: (m: Matrix4) => Vector3;
                        divide: (v: import('three').Vector3Like) => Vector3;
                        divideScalar: (s: number) => Vector3;
                        min: (v: import('three').Vector3Like) => Vector3;
                        max: (v: import('three').Vector3Like) => Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                        clampScalar: (min: number, max: number) => Vector3;
                        clampLength: (min: number, max: number) => Vector3;
                        floor: () => Vector3;
                        ceil: () => Vector3;
                        round: () => Vector3;
                        roundToZero: () => Vector3;
                        negate: () => Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => Vector3;
                        setLength: (l: number) => Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                        cross: (a: import('three').Vector3Like) => Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        projectOnVector: (v: Vector3) => Vector3;
                        projectOnPlane: (planeNormal: Vector3) => Vector3;
                        reflect: (vector: import('three').Vector3Like) => Vector3;
                        angleTo: (v: Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: Spherical) => Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                        setFromMatrixPosition: (m: Matrix4) => Vector3;
                        setFromMatrixScale: (m: Matrix4) => Vector3;
                        setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                        setFromEuler: (e: import('three').Euler) => Vector3;
                        setFromColor: (color: import('three').RGB) => Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                        random: () => Vector3;
                        randomDirection: () => Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: Vector3) => number;
                    distanceToSphere: (sphere: Sphere) => number;
                    projectPoint: (point: Vector3, target: Vector3) => Vector3;
                    intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: Box3) => boolean;
                    intersectsSphere: (sphere: Sphere) => boolean;
                    coplanarPoint: (target: Vector3) => Vector3;
                    applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => Vector3;
                        setScalar: (scalar: number) => Vector3;
                        setX: (x: number) => Vector3;
                        setY: (y: number) => Vector3;
                        setZ: (z: number) => Vector3;
                        setComponent: (index: number, value: number) => Vector3;
                        getComponent: (index: number) => number;
                        clone: () => Vector3;
                        copy: (v: import('three').Vector3Like) => Vector3;
                        add: (v: import('three').Vector3Like) => Vector3;
                        addScalar: (s: number) => Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        addScaledVector: (v: Vector3, s: number) => Vector3;
                        sub: (a: import('three').Vector3Like) => Vector3;
                        subScalar: (s: number) => Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        multiply: (v: import('three').Vector3Like) => Vector3;
                        multiplyScalar: (s: number) => Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        applyEuler: (euler: import('three').Euler) => Vector3;
                        applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => Vector3;
                        applyMatrix4: (m: Matrix4) => Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => Vector3;
                        project: (camera: Camera) => Vector3;
                        unproject: (camera: Camera) => Vector3;
                        transformDirection: (m: Matrix4) => Vector3;
                        divide: (v: import('three').Vector3Like) => Vector3;
                        divideScalar: (s: number) => Vector3;
                        min: (v: import('three').Vector3Like) => Vector3;
                        max: (v: import('three').Vector3Like) => Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => Vector3;
                        clampScalar: (min: number, max: number) => Vector3;
                        clampLength: (min: number, max: number) => Vector3;
                        floor: () => Vector3;
                        ceil: () => Vector3;
                        round: () => Vector3;
                        roundToZero: () => Vector3;
                        negate: () => Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => Vector3;
                        setLength: (l: number) => Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => Vector3;
                        cross: (a: import('three').Vector3Like) => Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => Vector3;
                        projectOnVector: (v: Vector3) => Vector3;
                        projectOnPlane: (planeNormal: Vector3) => Vector3;
                        reflect: (vector: import('three').Vector3Like) => Vector3;
                        angleTo: (v: Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: Spherical) => Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                        setFromMatrixPosition: (m: Matrix4) => Vector3;
                        setFromMatrixScale: (m: Matrix4) => Vector3;
                        setFromMatrixColumn: (matrix: Matrix4, index: number) => Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => Vector3;
                        setFromEuler: (e: import('three').Euler) => Vector3;
                        setFromColor: (color: import('three').RGB) => Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => Vector3;
                        random: () => Vector3;
                        randomDirection: () => Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: Vector3, point: Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: Vector3, b: Vector3, c: Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: Vector3) => number;
                    distanceToSphere: (sphere: Sphere) => number;
                    projectPoint: (point: Vector3, target: Vector3) => Vector3;
                    intersectLine: (line: import('three').Line3, target: Vector3) => Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: Box3) => boolean;
                    intersectsSphere: (sphere: Sphere) => boolean;
                    coplanarPoint: (target: Vector3) => Vector3;
                    applyMatrix4: (matrix: Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            applyMatrix4: (matrix: Matrix4) => void;
            applyQuaternion: (quaternion: Quaternion) => OrthographicCamera;
            setRotationFromAxisAngle: (axis: Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: Matrix4) => void;
            setRotationFromQuaternion: (q: Quaternion) => void;
            rotateOnAxis: (axis: Vector3, angle: number) => OrthographicCamera;
            rotateOnWorldAxis: (axis: Vector3, angle: number) => OrthographicCamera;
            rotateX: (angle: number) => OrthographicCamera;
            rotateY: (angle: number) => OrthographicCamera;
            rotateZ: (angle: number) => OrthographicCamera;
            translateOnAxis: (axis: Vector3, distance: number) => OrthographicCamera;
            translateX: (distance: number) => OrthographicCamera;
            translateY: (distance: number) => OrthographicCamera;
            translateZ: (distance: number) => OrthographicCamera;
            localToWorld: (vector: Vector3) => Vector3;
            worldToLocal: (vector: Vector3) => Vector3;
            lookAt: {
                (vector: Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: Object3D<import('three').Object3DEventMap>[]) => OrthographicCamera;
            remove: (...object: Object3D<import('three').Object3DEventMap>[]) => OrthographicCamera;
            removeFromParent: () => OrthographicCamera;
            clear: () => OrthographicCamera;
            attach: (object: Object3D<import('three').Object3DEventMap>) => OrthographicCamera;
            getObjectById: (id: number) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByName: (name: string) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByProperty: (name: string, value: any) => Object3D<import('three').Object3DEventMap> | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: Object3D<import('three').Object3DEventMap>[] | undefined) => Object3D<import('three').Object3DEventMap>[];
            getWorldPosition: (target: Vector3) => Vector3;
            getWorldQuaternion: (target: Quaternion) => Quaternion;
            getWorldScale: (target: Vector3) => Vector3;
            raycast: (raycaster: Raycaster, intersects: import('three').Intersection<Object3D<import('three').Object3DEventMap>>[]) => void;
            traverse: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseVisible: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseAncestors: (callback: (object: Object3D<import('three').Object3DEventMap>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => OrthographicCamera;
            copy: (object: Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => OrthographicCamera;
            addEventListener: {
                <T_20 extends keyof import('three').Object3DEventMap>(type: T_20, listener: import('three').EventListener<import('three').Object3DEventMap[T_20], T_20, OrthographicCamera>): void;
                <T_21 extends string>(type: T_21, listener: import('three').EventListener<{}, T_21, OrthographicCamera>): void;
            };
            hasEventListener: {
                <T_22 extends keyof import('three').Object3DEventMap>(type: T_22, listener: import('three').EventListener<import('three').Object3DEventMap[T_22], T_22, OrthographicCamera>): boolean;
                <T_23 extends string>(type: T_23, listener: import('three').EventListener<{}, T_23, OrthographicCamera>): boolean;
            };
            removeEventListener: {
                <T_24 extends keyof import('three').Object3DEventMap>(type: T_24, listener: import('three').EventListener<import('three').Object3DEventMap[T_24], T_24, OrthographicCamera>): void;
                <T_25 extends string>(type: T_25, listener: import('three').EventListener<{}, T_25, OrthographicCamera>): void;
            };
            dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
        };
        enabled: boolean;
        readonly active: boolean;
        readonly currentAction: number;
        distance: number;
        azimuthAngle: number;
        polarAngle: number;
        boundaryEnclosesCamera: boolean;
        interactiveArea: {
            height: number;
            width: number;
            x: number;
            y: number;
            readonly bottom: number;
            readonly left: number;
            readonly right: number;
            readonly top: number;
            toJSON: () => any;
        } | {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        addEventListener: <K extends keyof import('camera-controls/dist/types').CameraControlsEventMap>(type: K, listener: (event: import('camera-controls/dist/types').CameraControlsEventMap[K]) => any) => void;
        removeEventListener: <K_1 extends keyof import('camera-controls/dist/types').CameraControlsEventMap>(type: K_1, listener: (event: import('camera-controls/dist/types').CameraControlsEventMap[K_1]) => any) => void;
        rotate: (azimuthAngle: number, polarAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        rotateAzimuthTo: (azimuthAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        rotatePolarTo: (polarAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        rotateTo: (azimuthAngle: number, polarAngle: number, enableTransition?: boolean | undefined) => Promise<void>;
        dolly: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        dollyTo: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        dollyInFixed: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        zoom: (zoomStep: number, enableTransition?: boolean | undefined) => Promise<void>;
        zoomTo: (zoom: number, enableTransition?: boolean | undefined) => Promise<void>;
        pan: (x: number, y: number, enableTransition?: boolean | undefined) => Promise<void>;
        truck: (x: number, y: number, enableTransition?: boolean | undefined) => Promise<void>;
        forward: (distance: number, enableTransition?: boolean | undefined) => Promise<void>;
        elevate: (height: number, enableTransition?: boolean | undefined) => Promise<void>;
        moveTo: (x: number, y: number, z: number, enableTransition?: boolean | undefined) => Promise<void>;
        lookInDirectionOf: (x: number, y: number, z: number, enableTransition?: boolean | undefined) => Promise<void>;
        fitToBox: (box3OrObject: Box3 | Object3D<import('three').Object3DEventMap>, enableTransition: boolean, { cover, paddingLeft, paddingRight, paddingBottom, paddingTop }?: Partial<import('camera-controls/dist/types').FitToOptions> | undefined) => Promise<void[]>;
        fitToSphere: (sphereOrMesh: Sphere | Object3D<import('three').Object3DEventMap>, enableTransition: boolean) => Promise<void[]>;
        setLookAt: (positionX: number, positionY: number, positionZ: number, targetX: number, targetY: number, targetZ: number, enableTransition?: boolean | undefined) => Promise<void>;
        lerpLookAt: (positionAX: number, positionAY: number, positionAZ: number, targetAX: number, targetAY: number, targetAZ: number, positionBX: number, positionBY: number, positionBZ: number, targetBX: number, targetBY: number, targetBZ: number, t: number, enableTransition?: boolean | undefined) => Promise<void>;
        setPosition: (positionX: number, positionY: number, positionZ: number, enableTransition?: boolean | undefined) => Promise<void>;
        setTarget: (targetX: number, targetY: number, targetZ: number, enableTransition?: boolean | undefined) => Promise<void>;
        setFocalOffset: (x: number, y: number, z: number, enableTransition?: boolean | undefined) => Promise<void>;
        setOrbitPoint: (targetX: number, targetY: number, targetZ: number) => void;
        setBoundary: (box3?: Box3 | undefined) => void;
        setViewport: (viewportOrX: number | Vector4 | null, y: number, width: number, height: number) => void;
        getDistanceToFitBox: (width: number, height: number, depth: number, cover?: boolean | undefined) => number;
        getDistanceToFitSphere: (radius: number) => number;
        getTarget: (out: Vector3, receiveEndValue?: boolean | undefined) => Vector3;
        getPosition: (out: Vector3, receiveEndValue?: boolean | undefined) => Vector3;
        getSpherical: (out: Spherical, receiveEndValue?: boolean | undefined) => Spherical;
        getFocalOffset: (out: Vector3, receiveEndValue?: boolean | undefined) => Vector3;
        normalizeRotations: () => void;
        reset: (enableTransition?: boolean | undefined) => Promise<void[]>;
        saveState: () => void;
        updateCameraUp: () => void;
        applyCameraUp: () => void;
        update: (delta: number) => boolean;
        toJSON: () => string;
        fromJSON: (json: string, enableTransition?: boolean | undefined) => void;
        connect: (domElement: HTMLElement) => void;
        disconnect: () => void;
        dispose: () => void;
        dampingFactor: number;
        draggingDampingFactor: number;
        hasEventListener: (type: string, listener: import('camera-controls/dist/EventDispatcher').Listener) => boolean;
        removeAllEventListeners: (type?: string | undefined) => void;
        dispatchEvent: (event: import('camera-controls/dist/EventDispatcher').DispatcherEvent) => void;
    } | null>;
}, unknown, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
    start: (...args: any[]) => void;
    change: (...args: any[]) => void;
    end: (...args: any[]) => void;
}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<CameraControlsProps>, {
    makeDefault: boolean;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    distance: () => number;
    minDistance: number;
    maxDistance: number;
    infinityDolly: boolean;
    minZoom: number;
    maxZoom: number;
    smoothTime: number;
    draggingSmoothTime: number;
    maxSpeed: number;
    azimuthRotateSpeed: number;
    polarRotateSpeed: number;
    dollySpeed: number;
    dollyDragInverted: boolean;
    truckSpeed: number;
    dollyToCursor: boolean;
    dragToOffset: boolean;
    verticalDragToForward: boolean;
    boundaryFriction: number;
    restThreshold: number;
    colliderMeshes: () => never[];
    mouseButtons: () => import('camera-controls/dist/types').MouseButtons;
    touches: () => import('camera-controls/dist/types').Touches;
}>>> & {
    onStart?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    onEnd?: ((...args: any[]) => any) | undefined;
}, {
    distance: number;
    maxDistance: number;
    mouseButtons: Partial<import('camera-controls/dist/types').MouseButtons>;
    touches: Partial<import('camera-controls/dist/types').Touches>;
    makeDefault: boolean;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    minDistance: number;
    infinityDolly: boolean;
    minZoom: number;
    maxZoom: number;
    smoothTime: number;
    draggingSmoothTime: number;
    maxSpeed: number;
    azimuthRotateSpeed: number;
    polarRotateSpeed: number;
    dollySpeed: number;
    dollyDragInverted: boolean;
    truckSpeed: number;
    dollyToCursor: boolean;
    dragToOffset: boolean;
    verticalDragToForward: boolean;
    boundaryFriction: number;
    restThreshold: number;
    colliderMeshes: Object3D<import('three').Object3DEventMap>[];
}, {}>;
export default _default;
type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
type __VLS_TypePropsToRuntimeProps<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? {
        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
    } : {
        type: import('vue').PropType<T[K]>;
        required: true;
    };
};
type __VLS_WithDefaults<P, D> = {
    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
        default: D[K];
    }> : P[K];
};
type __VLS_Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
