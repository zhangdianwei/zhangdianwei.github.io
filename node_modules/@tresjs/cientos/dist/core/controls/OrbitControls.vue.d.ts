import { Camera, TOUCH } from 'three';
import { OrbitControls } from 'three-stdlib';
import { TresVector3 } from '@tresjs/core';

export interface OrbitControlsProps {
    /**
     * Whether to make this the default controls.
     *
     * @default false
     * @type {boolean}
     * @memberof OrbitControlsProps
     */
    makeDefault?: boolean;
    /**
     * The camera to control.
     *
     * @type {Camera}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.camera
     */
    camera?: Camera;
    /**
     * The dom element to listen to.
     *
     * @type {HTMLElement}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.domElement
     */
    domElement?: HTMLElement;
    /**
     * The target to orbit around.
     *
     * @type {TresVector3}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.target
     */
    target?: TresVector3;
    /**
     * Whether to enable damping (inertia)
     *
     * @default false
     * @type {boolean}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableDamping
     */
    enableDamping?: boolean;
    /**
     * The damping inertia used if `.enableDamping` is set to true
     *
     * @default 0.05
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.dampingFactor
     */
    dampingFactor?: number;
    /**
     * Set to true to automatically rotate around the target.
     *
     * @default false
     * @type {boolean}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotate
     */
    autoRotate?: boolean;
    /**
     * How fast to rotate around the target if `.autoRotate` is true.
     *
     * @default 2
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotateSpeed
     */
    autoRotateSpeed?: number;
    /**
     * Whether to enable panning.
     *
     * @default true
     * @type {boolean}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enablePan
     */
    enablePan?: boolean;
    /**
     * How fast to pan the camera when the keyboard is used. Default is 7.0 pixels per keypress.
     *
     * @default 7.0
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.keyPanSpeed
     */
    keyPanSpeed?: number;
    /**
     * This object contains references to the keycodes for controlling camera panning.
     * Default is the 4 arrow keys.
     *
     * @default `{ LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }`
     * @type Record<string, string>
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.keys
     */
    keys?: Record<string, string>;
    /**
     * How far you can orbit horizontally, upper limit.
     * If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ],
     * with ( max - min < 2 PI ). Default is Infinity.
     *
     * @default Infinity
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxAzimuthAngle
     */
    maxAzimuthAngle?: number;
    /**
     * How far you can orbit horizontally, lower limit.
     * If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ],
     * with ( max - min < 2 PI ).
     * Default is - Infinity.
     *
     * @default -Infinity
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minAzimuthAngle
     */
    minAzimuthAngle?: number;
    /**
     * How far you can orbit vertically, upper limit.
     * Range is 0 to Math.PI radians, and default is Math.PI.
     *
     * @default Math.PI
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxPolarAngle
     */
    maxPolarAngle?: number;
    /**
     * How far you can orbit vertically, lower limit.
     * Range is 0 to Math.PI radians, and default is 0.
     *
     * @default 0
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minPolarAngle
     */
    minPolarAngle?: number;
    /**
     * The minimum distance of the camera to the target.
     * Default is 0.
     *
     * @default 0
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minDistance
     */
    minDistance?: number;
    /**
     * The maximum distance of the camera to the target.
     * Default is Infinity.
     *
     * @default Infinity
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxDistance
     */
    maxDistance?: number;
    /**
     * The minimum field of view angle, in radians.
     * Default is 0.
     *
     * @default 0
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.minZoom
     */
    minZoom?: number;
    /**
     * The maximum field of view angle, in radians.
     * ( OrthographicCamera only ).
     * Default is Infinity.
     *
     * @default Infinity
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/index.html?q=orbi#examples/en/controls/OrbitControls.maxZoom
     */
    maxZoom?: number;
    touches?: {
        ONE?: number | undefined;
        TWO?: number | undefined;
    };
    /**
     * Whether to enable zooming.
     *
     * @default true
     * @type {boolean}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableZoom
     */
    enableZoom?: boolean;
    /**
     * How fast to zoom in and out. Default is 1.
     *
     * @default 1
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.zoomSpeed
     */
    zoomSpeed?: number;
    /**
     * Whether to enable rotating.
     *
     * @default true
     * @type {boolean}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.enableRotate
     */
    enableRotate?: boolean;
    /**
     * How fast to rotate around the target. Default is 1.
     *
     * @default 1
     * @type {number}
     * @memberof OrbitControlsProps
     * @see https://threejs.org/docs/#examples/en/controls/OrbitControls.rotateSpeed
     */
    rotateSpeed?: number;
}
declare const _default: import('vue').DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<OrbitControlsProps>, {
    makeDefault: boolean;
    autoRotate: boolean;
    autoRotateSpeed: number;
    enableDamping: boolean;
    dampingFactor: number;
    enablePan: boolean;
    keyPanSpeed: number;
    maxAzimuthAngle: number;
    minAzimuthAngle: number;
    maxPolarAngle: number;
    minPolarAngle: number;
    minDistance: number;
    maxDistance: number;
    minZoom: number;
    maxZoom: number;
    enableZoom: boolean;
    zoomSpeed: number;
    enableRotate: boolean;
    touches: () => {
        ONE: TOUCH;
        TWO: TOUCH;
    };
    rotateSpeed: number;
    target: () => number[];
}>, {
    value: import('vue').Ref<{
        object: {
            readonly isPerspectiveCamera: true;
            readonly type: string;
            zoom: number;
            fov: number;
            aspect: number;
            near: number;
            far: number;
            focus: number;
            view: {
                enabled: boolean;
                fullWidth: number;
                fullHeight: number;
                offsetX: number;
                offsetY: number;
                width: number;
                height: number;
            } | null;
            filmGauge: number;
            filmOffset: number;
            getFocalLength: () => number;
            setFocalLength: (focalLength: number) => void;
            getEffectiveFOV: () => number;
            getFilmWidth: () => number;
            getFilmHeight: () => number;
            getViewBounds: (distance: number, minTarget: import('three').Vector2, maxTarget: import('three').Vector2) => void;
            getViewSize: (distance: number, target: import('three').Vector2) => import('three').Vector2;
            setViewOffset: (fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number) => void;
            clearViewOffset: () => void;
            updateProjectionMatrix: () => void;
            setLens: (focalLength: number, frameHeight?: number | undefined) => void;
            readonly isCamera: true;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            coordinateSystem: import('three').CoordinateSystem;
            viewport?: {
                x: number;
                y: number;
                z: number;
                w: number;
                width: number;
                height: number;
                readonly isVector4: true;
                set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
                setScalar: (scalar: number) => import('three').Vector4;
                setX: (x: number) => import('three').Vector4;
                setY: (y: number) => import('three').Vector4;
                setZ: (z: number) => import('three').Vector4;
                setW: (w: number) => import('three').Vector4;
                setComponent: (index: number, value: number) => import('three').Vector4;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector4;
                copy: (v: import('three').Vector4Like) => import('three').Vector4;
                add: (v: import('three').Vector4Like) => import('three').Vector4;
                addScalar: (scalar: number) => import('three').Vector4;
                addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
                sub: (v: import('three').Vector4Like) => import('three').Vector4;
                subScalar: (s: number) => import('three').Vector4;
                subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                multiply: (v: import('three').Vector4Like) => import('three').Vector4;
                multiplyScalar: (s: number) => import('three').Vector4;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
                divideScalar: (s: number) => import('three').Vector4;
                setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
                setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
                min: (v: import('three').Vector4Like) => import('three').Vector4;
                max: (v: import('three').Vector4Like) => import('three').Vector4;
                clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
                clampScalar: (min: number, max: number) => import('three').Vector4;
                floor: () => import('three').Vector4;
                ceil: () => import('three').Vector4;
                round: () => import('three').Vector4;
                roundToZero: () => import('three').Vector4;
                negate: () => import('three').Vector4;
                dot: (v: import('three').Vector4Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector4;
                setLength: (length: number) => import('three').Vector4;
                lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                equals: (v: import('three').Vector4Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector4Tuple | undefined, offset?: 0 | undefined): import('three').Vector4Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
                random: () => import('three').Vector4;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            } | undefined;
            getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            parent: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                    clone: () => import('three').Quaternion;
                    copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => import('three').Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                    setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                    setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                    angleTo: (q: import('three').Quaternion) => number;
                    rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                    identity: () => import('three').Quaternion;
                    invert: () => import('three').Quaternion;
                    conjugate: () => import('three').Quaternion;
                    dot: (v: import('three').Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => import('three').Quaternion;
                    multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                    slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    equals: (v: import('three').Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                    _onChange: (callback: () => void) => import('three').Quaternion;
                    _onChangeCallback: () => void;
                    random: () => import('three').Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: import('three').Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: import('three').Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: import('three').Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: import('three').Matrix4) => void;
                applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: import('three').Matrix4) => void;
                setRotationFromQuaternion: (q: import('three').Quaternion) => void;
                rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
                worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
                lookAt: {
                    (vector: import('three').Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                remove: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
                clear: () => import('three').Object3D<import('three').Object3DEventMap>;
                attach: (object: import('three').Object3D<import('three').Object3DEventMap>) => import('three').Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D<import('three').Object3DEventMap>[] | undefined) => import('three').Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
                getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
                getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
                getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
                raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection<import('three').Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                copy: (object: import('three').Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            } | null;
            children: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                    clone: () => import('three').Quaternion;
                    copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => import('three').Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                    setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                    setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                    angleTo: (q: import('three').Quaternion) => number;
                    rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                    identity: () => import('three').Quaternion;
                    invert: () => import('three').Quaternion;
                    conjugate: () => import('three').Quaternion;
                    dot: (v: import('three').Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => import('three').Quaternion;
                    multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                    slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    equals: (v: import('three').Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                    _onChange: (callback: () => void) => import('three').Quaternion;
                    _onChangeCallback: () => void;
                    random: () => import('three').Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: import('three').Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: import('three').Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: import('three').Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: import('three').Matrix4) => void;
                applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: import('three').Matrix4) => void;
                setRotationFromQuaternion: (q: import('three').Quaternion) => void;
                rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
                worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
                lookAt: {
                    (vector: import('three').Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                remove: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
                clear: () => import('three').Object3D<import('three').Object3DEventMap>;
                attach: (object: import('three').Object3D<import('three').Object3DEventMap>) => import('three').Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D<import('three').Object3DEventMap>[] | undefined) => import('three').Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
                getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
                getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
                getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
                raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection<import('three').Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                copy: (object: import('three').Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                clone: () => import('three').Quaternion;
                copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => import('three').Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                angleTo: (q: import('three').Quaternion) => number;
                rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                identity: () => import('three').Quaternion;
                invert: () => import('three').Quaternion;
                conjugate: () => import('three').Quaternion;
                dot: (v: import('three').Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => import('three').Quaternion;
                multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                equals: (v: import('three').Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                _onChange: (callback: () => void) => import('three').Quaternion;
                _onChangeCallback: () => void;
                random: () => import('three').Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: import('three').Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: import('three').Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import('three').Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            applyMatrix4: (matrix: import('three').Matrix4) => void;
            applyQuaternion: (quaternion: import('three').Quaternion) => import('three').PerspectiveCamera;
            setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: import('three').Matrix4) => void;
            setRotationFromQuaternion: (q: import('three').Quaternion) => void;
            rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').PerspectiveCamera;
            rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').PerspectiveCamera;
            rotateX: (angle: number) => import('three').PerspectiveCamera;
            rotateY: (angle: number) => import('three').PerspectiveCamera;
            rotateZ: (angle: number) => import('three').PerspectiveCamera;
            translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').PerspectiveCamera;
            translateX: (distance: number) => import('three').PerspectiveCamera;
            translateY: (distance: number) => import('three').PerspectiveCamera;
            translateZ: (distance: number) => import('three').PerspectiveCamera;
            localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
            worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
            lookAt: {
                (vector: import('three').Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').PerspectiveCamera;
            remove: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').PerspectiveCamera;
            removeFromParent: () => import('three').PerspectiveCamera;
            clear: () => import('three').PerspectiveCamera;
            attach: (object: import('three').Object3D<import('three').Object3DEventMap>) => import('three').PerspectiveCamera;
            getObjectById: (id: number) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByName: (name: string) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByProperty: (name: string, value: any) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D<import('three').Object3DEventMap>[] | undefined) => import('three').Object3D<import('three').Object3DEventMap>[];
            getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
            getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
            getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
            raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection<import('three').Object3D<import('three').Object3DEventMap>>[]) => void;
            traverse: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseVisible: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseAncestors: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => import('three').PerspectiveCamera;
            copy: (object: import('three').Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => import('three').PerspectiveCamera;
            addEventListener: {
                <T_14 extends keyof import('three').Object3DEventMap>(type: T_14, listener: import('three').EventListener<import('three').Object3DEventMap[T_14], T_14, import('three').PerspectiveCamera>): void;
                <T_15 extends string>(type: T_15, listener: import('three').EventListener<{}, T_15, import('three').PerspectiveCamera>): void;
            };
            hasEventListener: {
                <T_16 extends keyof import('three').Object3DEventMap>(type: T_16, listener: import('three').EventListener<import('three').Object3DEventMap[T_16], T_16, import('three').PerspectiveCamera>): boolean;
                <T_17 extends string>(type: T_17, listener: import('three').EventListener<{}, T_17, import('three').PerspectiveCamera>): boolean;
            };
            removeEventListener: {
                <T_18 extends keyof import('three').Object3DEventMap>(type: T_18, listener: import('three').EventListener<import('three').Object3DEventMap[T_18], T_18, import('three').PerspectiveCamera>): void;
                <T_19 extends string>(type: T_19, listener: import('three').EventListener<{}, T_19, import('three').PerspectiveCamera>): void;
            };
            dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
        } | {
            readonly isOrthographicCamera: true;
            readonly type: string;
            zoom: number;
            view: {
                enabled: boolean;
                fullWidth: number;
                fullHeight: number;
                offsetX: number;
                offsetY: number;
                width: number;
                height: number;
            } | null;
            left: number;
            right: number;
            top: number;
            bottom: number;
            near: number;
            far: number;
            updateProjectionMatrix: () => void;
            setViewOffset: (fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: number) => void;
            clearViewOffset: () => void;
            readonly isCamera: true;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            coordinateSystem: import('three').CoordinateSystem;
            viewport?: {
                x: number;
                y: number;
                z: number;
                w: number;
                width: number;
                height: number;
                readonly isVector4: true;
                set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
                setScalar: (scalar: number) => import('three').Vector4;
                setX: (x: number) => import('three').Vector4;
                setY: (y: number) => import('three').Vector4;
                setZ: (z: number) => import('three').Vector4;
                setW: (w: number) => import('three').Vector4;
                setComponent: (index: number, value: number) => import('three').Vector4;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector4;
                copy: (v: import('three').Vector4Like) => import('three').Vector4;
                add: (v: import('three').Vector4Like) => import('three').Vector4;
                addScalar: (scalar: number) => import('three').Vector4;
                addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
                sub: (v: import('three').Vector4Like) => import('three').Vector4;
                subScalar: (s: number) => import('three').Vector4;
                subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
                multiply: (v: import('three').Vector4Like) => import('three').Vector4;
                multiplyScalar: (s: number) => import('three').Vector4;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
                divideScalar: (s: number) => import('three').Vector4;
                setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
                setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
                min: (v: import('three').Vector4Like) => import('three').Vector4;
                max: (v: import('three').Vector4Like) => import('three').Vector4;
                clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
                clampScalar: (min: number, max: number) => import('three').Vector4;
                floor: () => import('three').Vector4;
                ceil: () => import('three').Vector4;
                round: () => import('three').Vector4;
                roundToZero: () => import('three').Vector4;
                negate: () => import('three').Vector4;
                dot: (v: import('three').Vector4Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector4;
                setLength: (length: number) => import('three').Vector4;
                lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
                equals: (v: import('three').Vector4Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector4Tuple | undefined, offset?: 0 | undefined): import('three').Vector4Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
                random: () => import('three').Vector4;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            } | undefined;
            getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            parent: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                    clone: () => import('three').Quaternion;
                    copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => import('three').Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                    setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                    setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                    angleTo: (q: import('three').Quaternion) => number;
                    rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                    identity: () => import('three').Quaternion;
                    invert: () => import('three').Quaternion;
                    conjugate: () => import('three').Quaternion;
                    dot: (v: import('three').Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => import('three').Quaternion;
                    multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                    slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    equals: (v: import('three').Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                    _onChange: (callback: () => void) => import('three').Quaternion;
                    _onChangeCallback: () => void;
                    random: () => import('three').Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: import('three').Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: import('three').Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: import('three').Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: import('three').Matrix4) => void;
                applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: import('three').Matrix4) => void;
                setRotationFromQuaternion: (q: import('three').Quaternion) => void;
                rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
                worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
                lookAt: {
                    (vector: import('three').Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                remove: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
                clear: () => import('three').Object3D<import('three').Object3DEventMap>;
                attach: (object: import('three').Object3D<import('three').Object3DEventMap>) => import('three').Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D<import('three').Object3DEventMap>[] | undefined) => import('three').Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
                getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
                getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
                getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
                raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection<import('three').Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                copy: (object: import('three').Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            } | null;
            children: {
                readonly isObject3D: true;
                readonly id: number;
                uuid: string;
                name: string;
                readonly type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import('three').EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    clone: () => import('three').Euler;
                    copy: (euler: import('three').Euler) => import('three').Euler;
                    setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                    setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                    reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                    equals: (euler: import('three').Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import('three').Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                    clone: () => import('three').Quaternion;
                    copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                    setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => import('three').Quaternion;
                    setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                    setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                    setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                    angleTo: (q: import('three').Quaternion) => number;
                    rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                    identity: () => import('three').Quaternion;
                    invert: () => import('three').Quaternion;
                    conjugate: () => import('three').Quaternion;
                    dot: (v: import('three').Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => import('three').Quaternion;
                    multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                    multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                    slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                    equals: (v: import('three').Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => [number, number, number, number];
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                    _onChange: (callback: () => void) => import('three').Quaternion;
                    _onChangeCallback: () => void;
                    random: () => import('three').Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number, any, undefined>;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                    identity: () => import('three').Matrix3;
                    clone: () => import('three').Matrix3;
                    copy: (m: import('three').Matrix3) => import('three').Matrix3;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                    setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                    multiplyScalar: (s: number) => import('three').Matrix3;
                    determinant: () => number;
                    invert: () => import('three').Matrix3;
                    transpose: () => import('three').Matrix3;
                    getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                    transposeIntoArray: (r: number[]) => import('three').Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                    scale: (sx: number, sy: number) => import('three').Matrix3;
                    makeTranslation: {
                        (v: import('three').Vector2): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import('three').Matrix3;
                        (theta: number): import('three').Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import('three').Matrix3;
                        (x: number, y: number): import('three').Matrix3;
                    };
                    rotate: (theta: number) => import('three').Matrix3;
                    translate: (tx: number, ty: number) => import('three').Matrix3;
                    equals: (matrix: import('three').Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                    multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                    multiplyVector3: (vector: import('three').Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: import('three').Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                        (matrix: import('three').Matrix): import('three').Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                    identity: () => import('three').Matrix4;
                    clone: () => import('three').Matrix4;
                    copy: (m: import('three').Matrix4) => import('three').Matrix4;
                    copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                    extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                    makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                    makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                    multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                    multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                    multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                    multiplyScalar: (s: number) => import('three').Matrix4;
                    determinant: () => number;
                    transpose: () => import('three').Matrix4;
                    setPosition: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    invert: () => import('three').Matrix4;
                    scale: (v: import('three').Vector3) => import('three').Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: {
                        (v: import('three').Vector3): import('three').Matrix4;
                        (x: number, y: number, z: number): import('three').Matrix4;
                    };
                    makeRotationX: (theta: number) => import('three').Matrix4;
                    makeRotationY: (theta: number) => import('three').Matrix4;
                    makeRotationZ: (theta: number) => import('three').Matrix4;
                    makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                    makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                    compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                    makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                    equals: (matrix: import('three').Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                    extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                    setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (layer: number) => void;
                    enable: (layer: number) => void;
                    enableAll: () => void;
                    toggle: (layer: number) => void;
                    disable: (layer: number) => void;
                    disableAll: () => void;
                    test: (layers: import('three').Layers) => boolean;
                    isEnabled: (layer: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            findLast: {
                                <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                                (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                            };
                            findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                            toReversed: () => Float32Array;
                            toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            with: (index: number, value: number) => Float32Array;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import('three').InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                        setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                        getInterpolation: () => import('three').InterpolationModes;
                        createInterpolant: () => import('three').Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import('three').KeyframeTrack;
                        scale: (timeScale: number) => import('three').KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import('three').KeyframeTrack;
                        clone: () => import('three').KeyframeTrack;
                    }[];
                    blendMode: import('three').AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import('three').AnimationClip;
                    trim: () => import('three').AnimationClip;
                    validate: () => boolean;
                    optimize: () => import('three').AnimationClip;
                    clone: () => import('three').AnimationClip;
                    toJSON: (clip: import('three').AnimationClip) => any;
                }[];
                userData: Record<string, any>;
                customDepthMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                customDistanceMaterial?: {
                    readonly isMaterial: true;
                    alphaHash: boolean;
                    alphaToCoverage: boolean;
                    blendAlpha: number;
                    blendColor: {
                        readonly isColor: true;
                        r: number;
                        g: number;
                        b: number;
                        set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                        setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                        setScalar: (scalar: number) => import('three').Color;
                        setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                        clone: () => import('three').Color;
                        copy: (color: import('three').Color) => import('three').Color;
                        copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                        copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                        convertSRGBToLinear: () => import('three').Color;
                        convertLinearToSRGB: () => import('three').Color;
                        getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                        getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                        getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                        getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                        offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                        add: (color: import('three').Color) => import('three').Color;
                        addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                        addScalar: (s: number) => import('three').Color;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                        sub: (color: import('three').Color) => import('three').Color;
                        multiply: (color: import('three').Color) => import('three').Color;
                        multiplyScalar: (s: number) => import('three').Color;
                        lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                        lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                        lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                        equals: (color: import('three').Color) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        toJSON: () => number;
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                        [Symbol.iterator]: () => Generator<number, void, unknown>;
                    };
                    blendDst: import('three').BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import('three').BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import('three').Blending;
                    blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: {
                        normal: {
                            x: number;
                            y: number;
                            z: number;
                            readonly isVector3: true;
                            set: (x: number, y: number, z: number) => import('three').Vector3;
                            setScalar: (scalar: number) => import('three').Vector3;
                            setX: (x: number) => import('three').Vector3;
                            setY: (y: number) => import('three').Vector3;
                            setZ: (z: number) => import('three').Vector3;
                            setComponent: (index: number, value: number) => import('three').Vector3;
                            getComponent: (index: number) => number;
                            clone: () => import('three').Vector3;
                            copy: (v: import('three').Vector3Like) => import('three').Vector3;
                            add: (v: import('three').Vector3Like) => import('three').Vector3;
                            addScalar: (s: number) => import('three').Vector3;
                            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                            sub: (a: import('three').Vector3Like) => import('three').Vector3;
                            subScalar: (s: number) => import('three').Vector3;
                            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                            multiplyScalar: (s: number) => import('three').Vector3;
                            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                            project: (camera: Camera) => import('three').Vector3;
                            unproject: (camera: Camera) => import('three').Vector3;
                            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                            divide: (v: import('three').Vector3Like) => import('three').Vector3;
                            divideScalar: (s: number) => import('three').Vector3;
                            min: (v: import('three').Vector3Like) => import('three').Vector3;
                            max: (v: import('three').Vector3Like) => import('three').Vector3;
                            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                            clampScalar: (min: number, max: number) => import('three').Vector3;
                            clampLength: (min: number, max: number) => import('three').Vector3;
                            floor: () => import('three').Vector3;
                            ceil: () => import('three').Vector3;
                            round: () => import('three').Vector3;
                            roundToZero: () => import('three').Vector3;
                            negate: () => import('three').Vector3;
                            dot: (v: import('three').Vector3Like) => number;
                            lengthSq: () => number;
                            length: () => number;
                            manhattanLength: () => number;
                            normalize: () => import('three').Vector3;
                            setLength: (l: number) => import('three').Vector3;
                            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                            cross: (a: import('three').Vector3Like) => import('three').Vector3;
                            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                            angleTo: (v: import('three').Vector3) => number;
                            distanceTo: (v: import('three').Vector3Like) => number;
                            distanceToSquared: (v: import('three').Vector3Like) => number;
                            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                            setFromColor: (color: import('three').RGB) => import('three').Vector3;
                            equals: (v: import('three').Vector3Like) => boolean;
                            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                            toArray: {
                                (array?: number[] | undefined, offset?: number | undefined): number[];
                                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                            };
                            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                            random: () => import('three').Vector3;
                            randomDirection: () => import('three').Vector3;
                            [Symbol.iterator]: () => Iterator<number, any, undefined>;
                        };
                        constant: number;
                        readonly isPlane: true;
                        set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                        setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                        setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                        setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                        clone: () => import('three').Plane;
                        copy: (plane: import('three').Plane) => import('three').Plane;
                        normalize: () => import('three').Plane;
                        negate: () => import('three').Plane;
                        distanceToPoint: (point: import('three').Vector3) => number;
                        distanceToSphere: (sphere: import('three').Sphere) => number;
                        projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                        intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                        intersectsLine: (line: import('three').Line3) => boolean;
                        intersectsBox: (box: import('three').Box3) => boolean;
                        intersectsSphere: (sphere: import('three').Sphere) => boolean;
                        coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                        applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                        translate: (offset: import('three').Vector3) => import('three').Plane;
                        equals: (plane: import('three').Plane) => boolean;
                        isIntersectionLine: (l: any) => any;
                    }[] | null;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import('three').DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import('three').StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import('three').StencilOp;
                    stencilZFail: import('three').StencilOp;
                    stencilZPass: import('three').StencilOp;
                    name: string;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import('three').Side;
                    shadowSide: import('three').Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: Record<string, any>;
                    version: number;
                    alphaTest: number;
                    onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                    onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import('three').MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    clone: () => import('three').Material;
                    copy: (material: import('three').Material) => import('three').Material;
                    dispose: () => void;
                    needsUpdate: boolean;
                    addEventListener: {
                        <T extends "dispose">(type: T, listener: import('three').EventListener<{
                            dispose: {};
                        }[T], T, import('three').Material>): void;
                        <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                    };
                    hasEventListener: {
                        <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_2], T_2, import('three').Material>): boolean;
                        <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                    };
                    removeEventListener: {
                        <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                            dispose: {};
                        }[T_4], T_4, import('three').Material>): void;
                        <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                    };
                    dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                        dispose: {};
                    }[T_6]) => void;
                } | undefined;
                onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
                applyMatrix4: (matrix: import('three').Matrix4) => void;
                applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
                setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import('three').Euler) => void;
                setRotationFromMatrix: (m: import('three').Matrix4) => void;
                setRotationFromQuaternion: (q: import('three').Quaternion) => void;
                rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
                localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
                worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
                lookAt: {
                    (vector: import('three').Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                remove: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').Object3D<import('three').Object3DEventMap>;
                removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
                clear: () => import('three').Object3D<import('three').Object3DEventMap>;
                attach: (object: import('three').Object3D<import('three').Object3DEventMap>) => import('three').Object3D<import('three').Object3DEventMap>;
                getObjectById: (id: number) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByName: (name: string) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectByProperty: (name: string, value: any) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
                getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D<import('three').Object3DEventMap>[] | undefined) => import('three').Object3D<import('three').Object3DEventMap>[];
                getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
                getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
                getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
                getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
                raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection<import('three').Object3D<import('three').Object3DEventMap>>[]) => void;
                traverse: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseVisible: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                traverseAncestors: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                copy: (object: import('three').Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => import('three').Object3D<import('three').Object3DEventMap>;
                addEventListener: {
                    <T_7 extends keyof import('three').Object3DEventMap>(type: T_7, listener: import('three').EventListener<import('three').Object3DEventMap[T_7], T_7, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_8 extends string>(type: T_8, listener: import('three').EventListener<{}, T_8, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                hasEventListener: {
                    <T_9 extends keyof import('three').Object3DEventMap>(type: T_9, listener: import('three').EventListener<import('three').Object3DEventMap[T_9], T_9, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                    <T_10 extends string>(type: T_10, listener: import('three').EventListener<{}, T_10, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                };
                removeEventListener: {
                    <T_11 extends keyof import('three').Object3DEventMap>(type: T_11, listener: import('three').EventListener<import('three').Object3DEventMap[T_11], T_11, import('three').Object3D<import('three').Object3DEventMap>>): void;
                    <T_12 extends string>(type: T_12, listener: import('three').EventListener<{}, T_12, import('three').Object3D<import('three').Object3DEventMap>>): void;
                };
                dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder | undefined, update?: boolean | undefined) => import('three').Euler;
                setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder | undefined) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import('three').EulerOrder | undefined)?, ...any[]]) => import('three').Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                clone: () => import('three').Quaternion;
                copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean | undefined) => import('three').Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                angleTo: (q: import('three').Quaternion) => number;
                rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                identity: () => import('three').Quaternion;
                invert: () => import('three').Quaternion;
                conjugate: () => import('three').Quaternion;
                dot: (v: import('three').Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => import('three').Quaternion;
                multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                equals: (v: import('three').Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                _onChange: (callback: () => void) => import('three').Quaternion;
                _onChangeCallback: () => void;
                random: () => import('three').Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number, any, undefined>;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: import('three').Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix3Tuple | undefined, offset?: 0 | undefined): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: import('three').Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import('three').Matrix4, throwOnDegenerate?: boolean | undefined): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem | undefined) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import('three').Matrix4Tuple | undefined, offset?: 0 | undefined): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace | undefined) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace | undefined) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace | undefined) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace | undefined) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace | undefined) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Color;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207 | 208 | 209 | 210 | 211 | 212 | 213 | 214;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
                        toArray: {
                            (array?: number[] | undefined, offset?: number | undefined): number[];
                            (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number, any, undefined>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3 | undefined) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBuild: (object: import('three').Object3D<import('three').Object3DEventMap>, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, object: import('three').Object3D<import('three').Object3DEventMap>, group: import('three').Group<import('three').Object3DEventMap>) => void;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T_1 extends string>(type: T_1, listener: import('three').EventListener<{}, T_1, import('three').Material>): void;
                };
                hasEventListener: {
                    <T_2 extends "dispose">(type: T_2, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_2], T_2, import('three').Material>): boolean;
                    <T_3 extends string>(type: T_3, listener: import('three').EventListener<{}, T_3, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T_4 extends "dispose">(type: T_4, listener: import('three').EventListener<{
                        dispose: {};
                    }[T_4], T_4, import('three').Material>): void;
                    <T_5 extends string>(type: T_5, listener: import('three').EventListener<{}, T_5, import('three').Material>): void;
                };
                dispatchEvent: <T_6 extends "dispose">(event: import('three').BaseEvent<T_6> & {
                    dispose: {};
                }[T_6]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, depthMaterial: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry<import('three').NormalBufferAttributes>, material: import('three').Material, group: import('three').Group<import('three').Object3DEventMap>) => void;
            applyMatrix4: (matrix: import('three').Matrix4) => void;
            applyQuaternion: (quaternion: import('three').Quaternion) => import('three').OrthographicCamera;
            setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: import('three').Matrix4) => void;
            setRotationFromQuaternion: (q: import('three').Quaternion) => void;
            rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').OrthographicCamera;
            rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').OrthographicCamera;
            rotateX: (angle: number) => import('three').OrthographicCamera;
            rotateY: (angle: number) => import('three').OrthographicCamera;
            rotateZ: (angle: number) => import('three').OrthographicCamera;
            translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').OrthographicCamera;
            translateX: (distance: number) => import('three').OrthographicCamera;
            translateY: (distance: number) => import('three').OrthographicCamera;
            translateZ: (distance: number) => import('three').OrthographicCamera;
            localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
            worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
            lookAt: {
                (vector: import('three').Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').OrthographicCamera;
            remove: (...object: import('three').Object3D<import('three').Object3DEventMap>[]) => import('three').OrthographicCamera;
            removeFromParent: () => import('three').OrthographicCamera;
            clear: () => import('three').OrthographicCamera;
            attach: (object: import('three').Object3D<import('three').Object3DEventMap>) => import('three').OrthographicCamera;
            getObjectById: (id: number) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByName: (name: string) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
            getObjectByProperty: (name: string, value: any) => import('three').Object3D<import('three').Object3DEventMap> | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D<import('three').Object3DEventMap>[] | undefined) => import('three').Object3D<import('three').Object3DEventMap>[];
            getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
            getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
            getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
            raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection<import('three').Object3D<import('three').Object3DEventMap>>[]) => void;
            traverse: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseVisible: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
            traverseAncestors: (callback: (object: import('three').Object3D<import('three').Object3DEventMap>) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => import('three').OrthographicCamera;
            copy: (object: import('three').Object3D<import('three').Object3DEventMap>, recursive?: boolean | undefined) => import('three').OrthographicCamera;
            addEventListener: {
                <T_20 extends keyof import('three').Object3DEventMap>(type: T_20, listener: import('three').EventListener<import('three').Object3DEventMap[T_20], T_20, import('three').OrthographicCamera>): void;
                <T_21 extends string>(type: T_21, listener: import('three').EventListener<{}, T_21, import('three').OrthographicCamera>): void;
            };
            hasEventListener: {
                <T_22 extends keyof import('three').Object3DEventMap>(type: T_22, listener: import('three').EventListener<import('three').Object3DEventMap[T_22], T_22, import('three').OrthographicCamera>): boolean;
                <T_23 extends string>(type: T_23, listener: import('three').EventListener<{}, T_23, import('three').OrthographicCamera>): boolean;
            };
            removeEventListener: {
                <T_24 extends keyof import('three').Object3DEventMap>(type: T_24, listener: import('three').EventListener<import('three').Object3DEventMap[T_24], T_24, import('three').OrthographicCamera>): void;
                <T_25 extends string>(type: T_25, listener: import('three').EventListener<{}, T_25, import('three').OrthographicCamera>): void;
            };
            dispatchEvent: <T_13 extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T_13> & import('three').Object3DEventMap[T_13]) => void;
        };
        domElement: HTMLElement | undefined;
        enabled: boolean;
        target: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import('three').Vector3;
            setScalar: (scalar: number) => import('three').Vector3;
            setX: (x: number) => import('three').Vector3;
            setY: (y: number) => import('three').Vector3;
            setZ: (z: number) => import('three').Vector3;
            setComponent: (index: number, value: number) => import('three').Vector3;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector3;
            copy: (v: import('three').Vector3Like) => import('three').Vector3;
            add: (v: import('three').Vector3Like) => import('three').Vector3;
            addScalar: (s: number) => import('three').Vector3;
            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
            sub: (a: import('three').Vector3Like) => import('three').Vector3;
            subScalar: (s: number) => import('three').Vector3;
            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
            multiplyScalar: (s: number) => import('three').Vector3;
            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
            project: (camera: Camera) => import('three').Vector3;
            unproject: (camera: Camera) => import('three').Vector3;
            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
            divide: (v: import('three').Vector3Like) => import('three').Vector3;
            divideScalar: (s: number) => import('three').Vector3;
            min: (v: import('three').Vector3Like) => import('three').Vector3;
            max: (v: import('three').Vector3Like) => import('three').Vector3;
            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
            clampScalar: (min: number, max: number) => import('three').Vector3;
            clampLength: (min: number, max: number) => import('three').Vector3;
            floor: () => import('three').Vector3;
            ceil: () => import('three').Vector3;
            round: () => import('three').Vector3;
            roundToZero: () => import('three').Vector3;
            negate: () => import('three').Vector3;
            dot: (v: import('three').Vector3Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector3;
            setLength: (l: number) => import('three').Vector3;
            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            cross: (a: import('three').Vector3Like) => import('three').Vector3;
            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
            angleTo: (v: import('three').Vector3) => number;
            distanceTo: (v: import('three').Vector3Like) => number;
            distanceToSquared: (v: import('three').Vector3Like) => number;
            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
            setFromColor: (color: import('three').RGB) => import('three').Vector3;
            equals: (v: import('three').Vector3Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
            random: () => import('three').Vector3;
            randomDirection: () => import('three').Vector3;
            [Symbol.iterator]: () => Iterator<number, any, undefined>;
        };
        minDistance: number;
        maxDistance: number;
        minZoom: number;
        maxZoom: number;
        minPolarAngle: number;
        maxPolarAngle: number;
        minAzimuthAngle: number;
        maxAzimuthAngle: number;
        enableDamping: boolean;
        dampingFactor: number;
        enableZoom: boolean;
        zoomSpeed: number;
        enableRotate: boolean;
        rotateSpeed: number;
        enablePan: boolean;
        panSpeed: number;
        screenSpacePanning: boolean;
        keyPanSpeed: number;
        zoomToCursor: boolean;
        autoRotate: boolean;
        autoRotateSpeed: number;
        reverseOrbit: boolean;
        reverseHorizontalOrbit: boolean;
        reverseVerticalOrbit: boolean;
        keys: {
            LEFT: string;
            UP: string;
            RIGHT: string;
            BOTTOM: string;
        };
        mouseButtons: {
            LEFT?: import('three').MOUSE | undefined;
            MIDDLE?: import('three').MOUSE | undefined;
            RIGHT?: import('three').MOUSE | undefined;
        };
        touches: {
            ONE?: TOUCH | undefined;
            TWO?: TOUCH | undefined;
        };
        target0: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import('three').Vector3;
            setScalar: (scalar: number) => import('three').Vector3;
            setX: (x: number) => import('three').Vector3;
            setY: (y: number) => import('three').Vector3;
            setZ: (z: number) => import('three').Vector3;
            setComponent: (index: number, value: number) => import('three').Vector3;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector3;
            copy: (v: import('three').Vector3Like) => import('three').Vector3;
            add: (v: import('three').Vector3Like) => import('three').Vector3;
            addScalar: (s: number) => import('three').Vector3;
            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
            sub: (a: import('three').Vector3Like) => import('three').Vector3;
            subScalar: (s: number) => import('three').Vector3;
            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
            multiplyScalar: (s: number) => import('three').Vector3;
            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
            project: (camera: Camera) => import('three').Vector3;
            unproject: (camera: Camera) => import('three').Vector3;
            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
            divide: (v: import('three').Vector3Like) => import('three').Vector3;
            divideScalar: (s: number) => import('three').Vector3;
            min: (v: import('three').Vector3Like) => import('three').Vector3;
            max: (v: import('three').Vector3Like) => import('three').Vector3;
            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
            clampScalar: (min: number, max: number) => import('three').Vector3;
            clampLength: (min: number, max: number) => import('three').Vector3;
            floor: () => import('three').Vector3;
            ceil: () => import('three').Vector3;
            round: () => import('three').Vector3;
            roundToZero: () => import('three').Vector3;
            negate: () => import('three').Vector3;
            dot: (v: import('three').Vector3Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector3;
            setLength: (l: number) => import('three').Vector3;
            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            cross: (a: import('three').Vector3Like) => import('three').Vector3;
            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
            angleTo: (v: import('three').Vector3) => number;
            distanceTo: (v: import('three').Vector3Like) => number;
            distanceToSquared: (v: import('three').Vector3Like) => number;
            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
            setFromColor: (color: import('three').RGB) => import('three').Vector3;
            equals: (v: import('three').Vector3Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
            random: () => import('three').Vector3;
            randomDirection: () => import('three').Vector3;
            [Symbol.iterator]: () => Iterator<number, any, undefined>;
        };
        position0: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import('three').Vector3;
            setScalar: (scalar: number) => import('three').Vector3;
            setX: (x: number) => import('three').Vector3;
            setY: (y: number) => import('three').Vector3;
            setZ: (z: number) => import('three').Vector3;
            setComponent: (index: number, value: number) => import('three').Vector3;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector3;
            copy: (v: import('three').Vector3Like) => import('three').Vector3;
            add: (v: import('three').Vector3Like) => import('three').Vector3;
            addScalar: (s: number) => import('three').Vector3;
            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
            sub: (a: import('three').Vector3Like) => import('three').Vector3;
            subScalar: (s: number) => import('three').Vector3;
            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
            multiplyScalar: (s: number) => import('three').Vector3;
            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
            project: (camera: Camera) => import('three').Vector3;
            unproject: (camera: Camera) => import('three').Vector3;
            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
            divide: (v: import('three').Vector3Like) => import('three').Vector3;
            divideScalar: (s: number) => import('three').Vector3;
            min: (v: import('three').Vector3Like) => import('three').Vector3;
            max: (v: import('three').Vector3Like) => import('three').Vector3;
            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
            clampScalar: (min: number, max: number) => import('three').Vector3;
            clampLength: (min: number, max: number) => import('three').Vector3;
            floor: () => import('three').Vector3;
            ceil: () => import('three').Vector3;
            round: () => import('three').Vector3;
            roundToZero: () => import('three').Vector3;
            negate: () => import('three').Vector3;
            dot: (v: import('three').Vector3Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector3;
            setLength: (l: number) => import('three').Vector3;
            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            cross: (a: import('three').Vector3Like) => import('three').Vector3;
            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
            angleTo: (v: import('three').Vector3) => number;
            distanceTo: (v: import('three').Vector3Like) => number;
            distanceToSquared: (v: import('three').Vector3Like) => number;
            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
            setFromColor: (color: import('three').RGB) => import('three').Vector3;
            equals: (v: import('three').Vector3Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import('three').Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import('three').Vector3Tuple | undefined, offset?: 0 | undefined): import('three').Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
            random: () => import('three').Vector3;
            randomDirection: () => import('three').Vector3;
            [Symbol.iterator]: () => Iterator<number, any, undefined>;
        };
        zoom0: number;
        _domElementKeyEvents: any;
        getPolarAngle: () => number;
        getAzimuthalAngle: () => number;
        setPolarAngle: (x: number) => void;
        setAzimuthalAngle: (x: number) => void;
        getDistance: () => number;
        listenToKeyEvents: (domElement: HTMLElement) => void;
        stopListenToKeyEvents: () => void;
        saveState: () => void;
        reset: () => void;
        update: () => void;
        connect: (domElement: HTMLElement) => void;
        dispose: () => void;
        addEventListener: {
            <T_26 extends never>(type: T_26, listener: import('three').EventListener<{}[T_26], T_26, OrbitControls>): void;
            <T_27 extends string>(type: T_27, listener: import('three').EventListener<{}, T_27, OrbitControls>): void;
        };
        hasEventListener: {
            <T_28 extends never>(type: T_28, listener: import('three').EventListener<{}[T_28], T_28, OrbitControls>): boolean;
            <T_29 extends string>(type: T_29, listener: import('three').EventListener<{}, T_29, OrbitControls>): boolean;
        };
        removeEventListener: {
            <T_30 extends never>(type: T_30, listener: import('three').EventListener<{}[T_30], T_30, OrbitControls>): void;
            <T_31 extends string>(type: T_31, listener: import('three').EventListener<{}, T_31, OrbitControls>): void;
        };
        dispatchEvent: <T_32 extends never>(event: import('three').BaseEvent<T_32> & {}[T_32]) => void;
    } | null>;
}, unknown, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
    start: (...args: any[]) => void;
    change: (...args: any[]) => void;
    end: (...args: any[]) => void;
}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<OrbitControlsProps>, {
    makeDefault: boolean;
    autoRotate: boolean;
    autoRotateSpeed: number;
    enableDamping: boolean;
    dampingFactor: number;
    enablePan: boolean;
    keyPanSpeed: number;
    maxAzimuthAngle: number;
    minAzimuthAngle: number;
    maxPolarAngle: number;
    minPolarAngle: number;
    minDistance: number;
    maxDistance: number;
    minZoom: number;
    maxZoom: number;
    enableZoom: boolean;
    zoomSpeed: number;
    enableRotate: boolean;
    touches: () => {
        ONE: TOUCH;
        TWO: TOUCH;
    };
    rotateSpeed: number;
    target: () => number[];
}>>> & {
    onStart?: ((...args: any[]) => any) | undefined;
    onChange?: ((...args: any[]) => any) | undefined;
    onEnd?: ((...args: any[]) => any) | undefined;
}, {
    target: import('three').Vector3 | [x: number, y: number, z: number];
    maxDistance: number;
    touches: {
        ONE?: number | undefined;
        TWO?: number | undefined;
    };
    makeDefault: boolean;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    minDistance: number;
    minZoom: number;
    maxZoom: number;
    dampingFactor: number;
    enableDamping: boolean;
    enableZoom: boolean;
    zoomSpeed: number;
    enableRotate: boolean;
    rotateSpeed: number;
    enablePan: boolean;
    keyPanSpeed: number;
    autoRotate: boolean;
    autoRotateSpeed: number;
}, {}>;
export default _default;
type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
type __VLS_TypePropsToRuntimeProps<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? {
        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
    } : {
        type: import('vue').PropType<T[K]>;
        required: true;
    };
};
type __VLS_WithDefaults<P, D> = {
    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
        default: D[K];
    }> : P[K];
};
type __VLS_Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
