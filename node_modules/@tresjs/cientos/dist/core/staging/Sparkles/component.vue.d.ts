import { Blending, BufferGeometry, Texture, Object3D } from 'three';
import { TresColor } from '@tresjs/core';
import { VectorFlexibleParams } from '@tresjs/core/dist/utils/normalize';
import { Gradient } from '../../../utils/Gradient';

interface SparkleProps {
    /**
     * Texture or image path for individual sparkles
     */
    map?: Texture | string;
    /**
     * Vertices of the geometry will be used to emit sparkles. Geometry normals are used for sparkles' traveling direction and for responding to the directional light prop.
     *
     * - If provided, the component will use the passed geometry.
     * - If no geometry is provided, the component will try to make a copy of the parent object's geometry.
     * - If no parent geometry exists, the component will create and use an IcosphereGeometry.
     */
    geometry?: Object3D | BufferGeometry;
    /**
     * Particles "light up" when their normal "faces" the light. If no `directionalLight` is provided, the default "up" vector will be used.
     */
    directionalLight?: Object3D;
    /**
     * Particle lifetime in seconds
     */
    lifetimeSec?: number;
    /**
     * Particle cooldown in seconds â€“ time between lifetime end and respawn
     */
    cooldownSec?: number;
    /**
     * Number from 0-1 indicating how closely the particle needs to be faced towards the light to "light up". (Lower == more flexible)
     */
    normalThreshold?: number;
    /**
     * Scale of the noise period (lower == more slowly cycling noise)
     */
    noiseScale?: number;
    /**
     * Noise coefficient applied to particle scale
     */
    scaleNoise?: number;
    /**
     * Noise coefficient applied to particle offset
     */
    offsetNoise?: number;
    /**
     * Noise coefficient applied to particle lifetime
     */
    lifetimeNoise?: number;
    /**
     * Particle scale multiplier
     */
    size?: number;
    /**
     * Opacity multiplier
     */
    alpha?: number;
    /**
     * Offset multiplier
     */
    offset?: number;
    /**
     * Surface distance multiplier
     */
    surfaceDistance?: number;
    /**
     * '*Sequence' props: specify how a particle changes as it "progresses". See also "mix*" props.
     *
     * Color sequence as particles progress
     */
    sequenceColor?: Gradient<TresColor>;
    /**
     * Opacity sequence as particles progress
     */
    sequenceAlpha?: Gradient<number>;
    /**
     * Distance sequence as particles progress
     */
    sequenceOffset?: Gradient<VectorFlexibleParams>;
    /**
     * Noise sequence as particles progress
     */
    sequenceNoise?: Gradient<VectorFlexibleParams>;
    /**
     * Size sequence as particles progress
     */
    sequenceSize?: Gradient<number>;
    /**
     * Distance from surface (along normal) as particles progress
     */
    sequenceSurfaceDistance?: Gradient<number>;
    /**
     * 'mix*' props: A particle "progresses" with a mix of two factors:
     *
     * its normal "facing" the directionalLight
     * its lifetime
     *
     * 'mix*' props specify the relationship between the two factors.
     *
     * How is a particle's progress for color calculated? (0: normal, 1: particle lifetime)
     */
    mixColor?: number;
    /**
     * How is a particle's progress for alpha calculated? (0: normal, 1: particle lifetime)
     */
    mixAlpha?: number;
    /**
     * How is a particle's progress for offset calculated? (0: normal, 1: particle lifetime)
     */
    mixOffset?: number;
    /**
     * How is a particle's progress for size calculated? (0: normal, 1: particle lifetime)
     */
    mixSize?: number;
    /**
     * How is a particle's progress for surface distance calculated? (0: normal, 1: particle lifetime)
     */
    mixSurfaceDistance?: number;
    /**
     * How is a particle's progress for lifetime calculated? (0: normal, 1: particle lifetime)
     */
    mixNoise?: number;
    /**
     * Material blending
     */
    blending?: Blending;
    /**
     * Material transparency
     */
    transparent?: boolean;
    /**
     * Material depth write
     */
    depthWrite?: boolean;
}
declare const _default: import('vue').DefineComponent<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<SparkleProps>, {
    map: string;
    geometry: undefined;
    directionalLight: undefined;
    lifetimeSec: number;
    cooldownSec: number;
    size: number;
    alpha: number;
    offset: number;
    noiseScale: number;
    surfaceDistance: number;
    scaleNoise: number;
    offsetNoise: number;
    lifetimeNoise: number;
    normalThreshold: number;
    sequenceColor: () => (string | number)[][];
    sequenceAlpha: () => number[][];
    sequenceOffset: () => number[];
    sequenceSurfaceDistance: () => number[];
    sequenceSize: () => number[];
    sequenceNoise: () => number[];
    mixColor: number;
    mixAlpha: number;
    mixOffset: number;
    mixSize: number;
    mixSurfaceDistance: number;
    mixNoise: number;
    blending: 2;
    transparent: boolean;
    depthWrite: boolean;
}>, {}, unknown, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {}, string, import('vue').PublicProps, Readonly<import('vue').ExtractPropTypes<__VLS_WithDefaults<__VLS_TypePropsToRuntimeProps<SparkleProps>, {
    map: string;
    geometry: undefined;
    directionalLight: undefined;
    lifetimeSec: number;
    cooldownSec: number;
    size: number;
    alpha: number;
    offset: number;
    noiseScale: number;
    surfaceDistance: number;
    scaleNoise: number;
    offsetNoise: number;
    lifetimeNoise: number;
    normalThreshold: number;
    sequenceColor: () => (string | number)[][];
    sequenceAlpha: () => number[][];
    sequenceOffset: () => number[];
    sequenceSurfaceDistance: () => number[];
    sequenceSize: () => number[];
    sequenceNoise: () => number[];
    mixColor: number;
    mixAlpha: number;
    mixOffset: number;
    mixSize: number;
    mixSurfaceDistance: number;
    mixNoise: number;
    blending: 2;
    transparent: boolean;
    depthWrite: boolean;
}>>>, {
    map: string | Texture;
    directionalLight: Object3D<import('three').Object3DEventMap>;
    blending: Blending;
    depthWrite: boolean;
    transparent: boolean;
    offset: number;
    size: number;
    geometry: Object3D<import('three').Object3DEventMap> | BufferGeometry<import('three').NormalBufferAttributes>;
    alpha: number;
    lifetimeSec: number;
    cooldownSec: number;
    normalThreshold: number;
    noiseScale: number;
    scaleNoise: number;
    offsetNoise: number;
    lifetimeNoise: number;
    surfaceDistance: number;
    sequenceColor: Gradient<import('three').ColorRepresentation | [r: number, g: number, b: number]>;
    sequenceAlpha: Gradient<number>;
    sequenceOffset: any;
    sequenceNoise: any;
    sequenceSize: Gradient<number>;
    sequenceSurfaceDistance: Gradient<number>;
    mixColor: number;
    mixAlpha: number;
    mixOffset: number;
    mixSize: number;
    mixSurfaceDistance: number;
    mixNoise: number;
}, {}>;
export default _default;
type __VLS_NonUndefinedable<T> = T extends undefined ? never : T;
type __VLS_TypePropsToRuntimeProps<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? {
        type: import('vue').PropType<__VLS_NonUndefinedable<T[K]>>;
    } : {
        type: import('vue').PropType<T[K]>;
        required: true;
    };
};
type __VLS_WithDefaults<P, D> = {
    [K in keyof Pick<P, keyof P>]: K extends keyof D ? __VLS_Prettify<P[K] & {
        default: D[K];
    }> : P[K];
};
type __VLS_Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
