/**
 * name: @tresjs/cientos
 * version: v3.9.0
 * (c) 2024
 * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var vl = Object.defineProperty;
var yl = (o, e, t) => e in o ? vl(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var ae = (o, e, t) => (yl(o, typeof e != "symbol" ? e + "" : e, t), t);
import * as Hr from "three";
import { TrianglesDrawMode as _l, TriangleFanDrawMode as Ji, TriangleStripDrawMode as Qo, REVISION as vr, Color as Re, Vector3 as Z, CompressedTexture as vi, Texture as Jn, MathUtils as Ze, RGBAFormat as Jo, DoubleSide as wn, BufferAttribute as mt, PropertyBinding as Jt, InterpolateDiscrete as ea, Matrix4 as Pe, Scene as ws, PlaneGeometry as Ut, ShaderMaterial as Dt, Uniform as Ee, Mesh as le, PerspectiveCamera as St, WebGLRenderer as xl, InterpolateLinear as yr, NearestFilter as ta, NearestMipmapNearestFilter as na, NearestMipmapLinearFilter as sa, LinearFilter as Ot, LinearMipmapNearestFilter as ia, LinearMipmapLinearFilter as _r, ClampToEdgeWrapping as es, RepeatWrapping as Ln, MirroredRepeatWrapping as ra, Triangle as wl, Object3D as Mt, Raycaster as oa, Quaternion as He, Euler as Rn, MeshBasicMaterial as Zt, LineBasicMaterial as ts, CylinderGeometry as At, BoxGeometry as $t, BufferGeometry as at, Float32BufferAttribute as rt, Line as Ie, OctahedronGeometry as Sn, TorusGeometry as ks, SphereGeometry as Tl, EventDispatcher as aa, Ray as bl, Plane as hi, MOUSE as pn, TOUCH as Nt, OrthographicCamera as qt, Spherical as ri, Vector2 as ge, Loader as Es, LoaderUtils as Ht, FileLoader as Fn, SpotLight as la, PointLight as er, DirectionalLight as ca, MeshPhysicalMaterial as bn, InstancedMesh as El, TextureLoader as xr, ImageBitmapLoader as Sl, InterleavedBuffer as wr, InterleavedBufferAttribute as Kt, PointsMaterial as Ml, Material as yi, MeshStandardMaterial as Ss, SkinnedMesh as ua, LineSegments as Al, LineLoop as Pl, Points as ha, Group as Dn, Skeleton as fa, AnimationClip as da, Bone as tr, FrontSide as Ms, VectorKeyframeTrack as pa, QuaternionKeyframeTrack as nr, NumberKeyframeTrack as ma, Box3 as bt, Sphere as fi, Interpolant as Cl, ExtrudeGeometry as Il, Vector4 as lt, Curve as Rl, MeshPhongMaterial as _i, MeshLambertMaterial as Dl, EquirectangularReflectionMapping as sr, AmbientLight as Ol, Uint16BufferAttribute as Ll, Matrix3 as In, ShapePath as hn, DataTextureLoader as Fl, HalfFloatType as Qt, FloatType as si, DataUtils as Bs, ShapeUtils as kl, Box2 as ga, Shape as Bl, Path as xi, BackSide as va, AnimationMixer as Ul, WebGLRenderTarget as Tn, UniformsUtils as ns, AudioListener as ya, Audio as Nl, AudioLoader as _a, FramebufferTexture as jr, RawShaderMaterial as wi, AdditiveBlending as Tr, UnsignedByteType as ir, DepthTexture as xa, CubeTextureLoader as zl, CubeReflectionMapping as Hl, ShapeGeometry as jl, DefaultLoadingManager as Us, VideoTexture as Gl, NoBlending as Vl, Camera as Yl, DepthFormat as Wl, UnsignedShortType as Xl, Clock as $l, InstancedBufferGeometry as Zl, InstancedInterleavedBuffer as rr, WireframeGeometry as ql, UniformsLib as Kn, ShaderLib as ii, Line3 as Kl, CatmullRomCurve3 as Ql, QuadraticBezierCurve3 as Jl, WebGLCubeRenderTarget as ec, CubeCamera as tc, MeshDepthMaterial as nc, DataTexture as wa, UVMapping as sc, IcosahedronGeometry as ic, DirectionalLightHelper as rc, PointLightHelper as oc, SpotLightHelper as ac, HemisphereLightHelper as lc, ArrowHelper as cc } from "three";
import { defineComponent as me, toRefs as Oe, useSlots as br, computed as Fe, shallowRef as pe, withAsyncContext as Bn, toValue as on, watchEffect as ut, unref as H, openBlock as ce, createElementBlock as ue, createCommentVNode as jt, renderSlot as Ve, ref as he, shallowReactive as Ta, mergeProps as We, createElementVNode as _e, getCurrentScope as uc, onScopeDispose as hc, onMounted as En, nextTick as Er, isRef as oi, getCurrentInstance as ba, watch as ve, reactive as or, onUnmounted as ct, isReactive as fc, onBeforeUnmount as Sr, Fragment as Ea, renderList as Sa, useAttrs as Ma, createBlock as Aa, toRaw as dc, normalizeProps as pc, guardReactiveProps as mc, triggerRef as gc, createVNode as Ns, render as vc } from "vue";
import { useTresContext as ke, useRenderLoop as qe, normalizeColor as gn, useLoader as ss, useLogger as As, useTexture as ai, normalizeVectorFlexibleParam as yc } from "@tresjs/core";
import { Pane as _c } from "tweakpane";
function Gr(o, e) {
  if (e === _l)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
  if (e === Ji || e === Qo) {
    let t = o.getIndex();
    if (t === null) {
      const r = [], a = o.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          r.push(l);
        o.setIndex(r), t = o.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), o;
    }
    const n = t.count - 2, s = [];
    if (t)
      if (e === Ji)
        for (let r = 1; r <= n; r++)
          s.push(t.getX(0)), s.push(t.getX(r)), s.push(t.getX(r + 1));
      else
        for (let r = 0; r < n; r++)
          r % 2 === 0 ? (s.push(t.getX(r)), s.push(t.getX(r + 1)), s.push(t.getX(r + 2))) : (s.push(t.getX(r + 2)), s.push(t.getX(r + 1)), s.push(t.getX(r)));
    s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = o.clone();
    return i.setIndex(s), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), o;
}
const Pa = parseInt(vr.replace(/\D+/g, ""));
var xc = Object.defineProperty, wc = (o, e, t) => e in o ? xc(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Tc = (o, e, t) => (wc(o, e + "", t), t);
async function Vr(o) {
  const e = await o.arrayBuffer(), t = btoa(String.fromCharCode(...new Uint8Array(e)));
  return `data:${o.type || ""};base64,${t}`;
}
let zs, Ti, Nn, Hs;
function bi(o, e = 1 / 0, t = null) {
  Ti || (Ti = new Ut(2, 2, 1, 1)), Nn || (Nn = new Dt({
    uniforms: { blitTexture: new Ee(o) },
    vertexShader: (
      /* glsl */
      `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `
    )
  })), Nn.uniforms.blitTexture.value = o, Nn.defines.IS_SRGB = "colorSpace" in o ? o.colorSpace === "srgb" : o.encoding === 3001, Nn.needsUpdate = !0, Hs || (Hs = new le(Ti, Nn), Hs.frustrumCulled = !1);
  const n = new St(), s = new ws();
  s.add(Hs), t || (t = zs = new xl({ antialias: !1 })), t.setSize(Math.min(o.image.width, e), Math.min(o.image.height, e)), t.clear(), t.render(s, n);
  const i = new Jn(t.domElement);
  return i.minFilter = o.minFilter, i.magFilter = o.magFilter, i.wrapS = o.wrapS, i.wrapT = o.wrapT, i.name = o.name, zs && (zs.dispose(), zs = null), i;
}
const Yr = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: ["byte normalized", "short normalized"],
  TANGENT: ["byte normalized", "short normalized"],
  TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class Mr {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new Dc(e);
    }), this.register(function(e) {
      return new Oc(e);
    }), this.register(function(e) {
      return new kc(e);
    }), this.register(function(e) {
      return new Bc(e);
    }), this.register(function(e) {
      return new Uc(e);
    }), this.register(function(e) {
      return new Nc(e);
    }), this.register(function(e) {
      return new Lc(e);
    }), this.register(function(e) {
      return new Fc(e);
    }), this.register(function(e) {
      return new zc(e);
    }), this.register(function(e) {
      return new Hc(e);
    }), this.register(function(e) {
      return new jc(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, n, s) {
    const i = new Rc(), r = [];
    for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)
      r.push(this.pluginCallbacks[a](i));
    i.setPlugins(r), i.write(e, t, s).catch(n);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, s, i, t);
    });
  }
}
Tc(Mr, "Utils", {
  insertKeyframe: function(o, e) {
    const n = o.getValueSize(), s = new o.TimeBufferType(o.times.length + 1), i = new o.ValueBufferType(o.values.length + n), r = o.createInterpolant(new o.ValueBufferType(n));
    let a;
    if (o.times.length === 0) {
      s[0] = e;
      for (let l = 0; l < n; l++)
        i[l] = 0;
      a = 0;
    } else if (e < o.times[0]) {
      if (Math.abs(o.times[0] - e) < 1e-3)
        return 0;
      s[0] = e, s.set(o.times, 1), i.set(r.evaluate(e), 0), i.set(o.values, n), a = 0;
    } else if (e > o.times[o.times.length - 1]) {
      if (Math.abs(o.times[o.times.length - 1] - e) < 1e-3)
        return o.times.length - 1;
      s[s.length - 1] = e, s.set(o.times, 0), i.set(o.values, 0), i.set(r.evaluate(e), o.values.length), a = s.length - 1;
    } else
      for (let l = 0; l < o.times.length; l++) {
        if (Math.abs(o.times[l] - e) < 1e-3)
          return l;
        if (o.times[l] < e && o.times[l + 1] > e) {
          s.set(o.times.slice(0, l + 1), 0), s[l + 1] = e, s.set(o.times.slice(l + 1), l + 2), i.set(o.values.slice(0, (l + 1) * n), 0), i.set(r.evaluate(e), (l + 1) * n), i.set(o.values.slice((l + 1) * n), (l + 2) * n), a = l + 1;
          break;
        }
      }
    return o.times = s, o.values = i, a;
  },
  mergeMorphTargetTracks: function(o, e) {
    const t = [], n = {}, s = o.tracks;
    for (let i = 0; i < s.length; ++i) {
      let r = s[i];
      const a = Jt.parseTrackName(r.name), l = Jt.findNode(e, a.nodeName);
      if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
        t.push(r);
        continue;
      }
      if (r.createInterpolant !== r.InterpolantFactoryMethodDiscrete && r.createInterpolant !== r.InterpolantFactoryMethodLinear) {
        if (r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r = r.clone(), r.setInterpolation(yr);
      }
      const c = l.morphTargetInfluences.length, u = l.morphTargetDictionary[a.propertyIndex];
      if (u === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
      let h;
      if (n[l.uuid] === void 0) {
        h = r.clone();
        const p = new h.ValueBufferType(c * h.times.length);
        for (let y = 0; y < h.times.length; y++)
          p[y * c + u] = h.values[y];
        h.name = (a.nodeName || "") + ".morphTargetInfluences", h.values = p, n[l.uuid] = h, t.push(h);
        continue;
      }
      const f = r.createInterpolant(new r.ValueBufferType(1));
      h = n[l.uuid];
      for (let p = 0; p < h.times.length; p++)
        h.values[p * c + u] = f.evaluate(h.times[p]);
      for (let p = 0; p < r.times.length; p++) {
        const y = this.insertKeyframe(h, r.times[p]);
        h.values[y * c + u] = r.values[p];
      }
    }
    return o.tracks = t, o;
  }
});
const Ce = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, Ei = "KHR_mesh_quantization", yt = {};
yt[ta] = Ce.NEAREST;
yt[na] = Ce.NEAREST_MIPMAP_NEAREST;
yt[sa] = Ce.NEAREST_MIPMAP_LINEAR;
yt[Ot] = Ce.LINEAR;
yt[ia] = Ce.LINEAR_MIPMAP_NEAREST;
yt[_r] = Ce.LINEAR_MIPMAP_LINEAR;
yt[es] = Ce.CLAMP_TO_EDGE;
yt[Ln] = Ce.REPEAT;
yt[ra] = Ce.MIRRORED_REPEAT;
const Wr = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, bc = new Re(), Xr = 12, Ec = 1179937895, Sc = 2, $r = 8, Mc = 1313821514, Ac = 5130562;
function ys(o, e) {
  return o.length === e.length && o.every(function(t, n) {
    return t === e[n];
  });
}
function Pc(o) {
  return new TextEncoder().encode(o).buffer;
}
function Cc(o) {
  return ys(o.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function Ic(o, e, t) {
  const n = {
    min: new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let s = e; s < e + t; s++)
    for (let i = 0; i < o.itemSize; i++) {
      let r;
      o.itemSize > 4 ? r = o.array[s * o.itemSize + i] : (i === 0 ? r = o.getX(s) : i === 1 ? r = o.getY(s) : i === 2 ? r = o.getZ(s) : i === 3 && (r = o.getW(s)), o.normalized === !0 && (r = Ze.normalize(r, o.array))), n.min[i] = Math.min(n.min[i], r), n.max[i] = Math.max(n.max[i], r);
    }
  return n;
}
function Ca(o) {
  return Math.ceil(o / 4) * 4;
}
function Si(o, e = 0) {
  const t = Ca(o.byteLength);
  if (t !== o.byteLength) {
    const n = new Uint8Array(t);
    if (n.set(new Uint8Array(o)), e !== 0)
      for (let s = o.byteLength; s < t; s++)
        n[s] = e;
    return n.buffer;
  }
  return o;
}
function Zr() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function qr(o, e) {
  if (o.toBlob !== void 0)
    return new Promise((n) => o.toBlob(n, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), o.convertToBlob({
    type: e,
    quality: t
  });
}
class Rc {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, n = {}) {
    this.options = Object.assign(
      {
        // default options
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      },
      n
    ), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const s = this, i = s.buffers, r = s.json;
    n = s.options;
    const a = s.extensionsUsed, l = s.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), u = Object.keys(a), h = Object.keys(l);
    u.length > 0 && (r.extensionsUsed = u), h.length > 0 && (r.extensionsRequired = h), r.buffers && r.buffers.length > 0 && (r.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((f) => {
      const p = Si(f), y = new DataView(new ArrayBuffer($r));
      y.setUint32(0, p.byteLength, !0), y.setUint32(4, Ac, !0);
      const g = Si(Pc(JSON.stringify(r)), 32), v = new DataView(new ArrayBuffer($r));
      v.setUint32(0, g.byteLength, !0), v.setUint32(4, Mc, !0);
      const d = new ArrayBuffer(Xr), w = new DataView(d);
      w.setUint32(0, Ec, !0), w.setUint32(4, Sc, !0);
      const x = Xr + v.byteLength + g.byteLength + y.byteLength + p.byteLength;
      w.setUint32(8, x, !0), new Blob([d, v, g, y, p], {
        type: "application/octet-stream"
      }).arrayBuffer().then(t);
    }) : r.buffers && r.buffers.length > 0 ? Vr(c).then((f) => {
      r.buffers[0].uri = f, t(r);
    }) : t(r);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0)
      return;
    const n = this.options, s = this.extensionsUsed;
    try {
      const i = JSON.parse(JSON.stringify(e.userData));
      if (n.includeCustomExtensions && i.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const r in i.gltfExtensions)
          t.extensions[r] = i.gltfExtensions[r], s[r] = !0;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (t.extras = i);
    } catch (i) {
      console.warn(
        "THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message
      );
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const s = /* @__PURE__ */ new Map();
      s.set(!0, this.uid++), s.set(!1, this.uid++), this.uids.set(e, s);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e))
      return !1;
    const n = new Z();
    for (let s = 0, i = e.count; s < i; s++)
      if (Math.abs(n.fromBufferAttribute(e, s).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e))
      return t.attributesNormalized.get(e);
    const n = e.clone(), s = new Z();
    for (let i = 0, r = n.count; i < r; i++)
      s.fromBufferAttribute(n, i), s.x === 0 && s.y === 0 && s.z === 0 ? s.setX(1) : s.normalize(), n.setXYZ(i, s.x, s.y, s.z);
    return t.attributesNormalized.set(e, n), n;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let n = !1;
    const s = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (s.offset = t.offset.toArray(), n = !0), t.rotation !== 0 && (s.rotation = t.rotation, n = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (s.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = s, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t)
      return e;
    function n(p) {
      return ("colorSpace" in p ? p.colorSpace === "srgb" : p.encoding === 3001) ? function(g) {
        return g < 0.04045 ? g * 0.0773993808 : Math.pow(g * 0.9478672986 + 0.0521327014, 2.4);
      } : function(g) {
        return g;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof vi && (e = bi(e)), t instanceof vi && (t = bi(t));
    const s = e ? e.image : null, i = t ? t.image : null, r = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = Zr();
    l.width = r, l.height = a;
    const c = l.getContext("2d");
    c.fillStyle = "#00ffff", c.fillRect(0, 0, r, a);
    const u = c.getImageData(0, 0, r, a);
    if (s) {
      c.drawImage(s, 0, 0, r, a);
      const p = n(e), y = c.getImageData(0, 0, r, a).data;
      for (let g = 2; g < y.length; g += 4)
        u.data[g] = p(y[g] / 256) * 256;
    }
    if (i) {
      c.drawImage(i, 0, 0, r, a);
      const p = n(t), y = c.getImageData(0, 0, r, a).data;
      for (let g = 1; g < y.length; g += 4)
        u.data[g] = p(y[g] / 256) * 256;
    }
    c.putImageData(u, 0, 0);
    const f = (e || t).clone();
    return f.source = new Jn(l).source, "colorSpace" in f ? f.colorSpace = "" : f.encoding = 3e3, f.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), f;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, n = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), n.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, n, s, i) {
    const r = this.json;
    r.bufferViews || (r.bufferViews = []);
    let a;
    switch (t) {
      case Ce.BYTE:
      case Ce.UNSIGNED_BYTE:
        a = 1;
        break;
      case Ce.SHORT:
      case Ce.UNSIGNED_SHORT:
        a = 2;
        break;
      default:
        a = 4;
    }
    const l = Ca(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));
    let u = 0;
    for (let p = n; p < n + s; p++)
      for (let y = 0; y < e.itemSize; y++) {
        let g;
        e.itemSize > 4 ? g = e.array[p * e.itemSize + y] : (y === 0 ? g = e.getX(p) : y === 1 ? g = e.getY(p) : y === 2 ? g = e.getZ(p) : y === 3 && (g = e.getW(p)), e.normalized === !0 && (g = Ze.normalize(g, e.array))), t === Ce.FLOAT ? c.setFloat32(u, g, !0) : t === Ce.INT ? c.setInt32(u, g, !0) : t === Ce.UNSIGNED_INT ? c.setUint32(u, g, !0) : t === Ce.SHORT ? c.setInt16(u, g, !0) : t === Ce.UNSIGNED_SHORT ? c.setUint16(u, g, !0) : t === Ce.BYTE ? c.setInt8(u, g) : t === Ce.UNSIGNED_BYTE && c.setUint8(u, g), u += a;
      }
    const h = {
      buffer: this.processBuffer(c.buffer),
      byteOffset: this.byteOffset,
      byteLength: l
    };
    return i !== void 0 && (h.target = i), i === Ce.ARRAY_BUFFER && (h.byteStride = e.itemSize * a), this.byteOffset += l, r.bufferViews.push(h), {
      id: r.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, n = t.json;
    return n.bufferViews || (n.bufferViews = []), e.arrayBuffer().then((s) => {
      const i = Si(s), r = {
        buffer: t.processBuffer(i),
        byteOffset: t.byteOffset,
        byteLength: i.byteLength
      };
      return t.byteOffset += i.byteLength, n.bufferViews.push(r) - 1;
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, n, s) {
    const i = this.json, r = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let a;
    if (e.array.constructor === Float32Array)
      a = Ce.FLOAT;
    else if (e.array.constructor === Int32Array)
      a = Ce.INT;
    else if (e.array.constructor === Uint32Array)
      a = Ce.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      a = Ce.SHORT;
    else if (e.array.constructor === Uint16Array)
      a = Ce.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      a = Ce.BYTE;
    else if (e.array.constructor === Uint8Array)
      a = Ce.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name
      );
    if (n === void 0 && (n = 0), s === void 0 && (s = e.count), s === 0)
      return null;
    const l = Ic(e, n, s);
    let c;
    t !== void 0 && (c = e === t.index ? Ce.ELEMENT_ARRAY_BUFFER : Ce.ARRAY_BUFFER);
    const u = this.processBufferView(e, a, n, s, c), h = {
      bufferView: u.id,
      byteOffset: u.byteOffset,
      componentType: a,
      count: s,
      max: l.max,
      min: l.min,
      type: r[e.itemSize]
    };
    return e.normalized === !0 && (h.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(h) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, n, s = "image/png") {
    if (e !== null) {
      const i = this, r = i.cache, a = i.json, l = i.options, c = i.pending;
      r.images.has(e) || r.images.set(e, {});
      const u = r.images.get(e), h = s + ":flipY/" + n.toString();
      if (u[h] !== void 0)
        return u[h];
      a.images || (a.images = []);
      const f = { mimeType: s }, p = Zr();
      p.width = Math.min(e.width, l.maxTextureSize), p.height = Math.min(e.height, l.maxTextureSize);
      const y = p.getContext("2d");
      if (n === !0 && (y.translate(0, p.height), y.scale(1, -1)), e.data !== void 0) {
        t !== Jo && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const v = new Uint8ClampedArray(e.height * e.width * 4);
        for (let d = 0; d < v.length; d += 4)
          v[d + 0] = e.data[d + 0], v[d + 1] = e.data[d + 1], v[d + 2] = e.data[d + 2], v[d + 3] = e.data[d + 3];
        y.putImageData(new ImageData(v, e.width, e.height), 0, 0);
      } else
        y.drawImage(e, 0, 0, p.width, p.height);
      l.binary === !0 ? c.push(
        qr(p, s).then((v) => i.processBufferViewImage(v)).then((v) => {
          f.bufferView = v;
        })
      ) : p.toDataURL !== void 0 ? f.uri = p.toDataURL(s) : c.push(
        qr(p, s).then(Vr).then((v) => {
          f.uri = v;
        })
      );
      const g = a.images.push(f) - 1;
      return u[h] = g, g;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const n = {
      magFilter: yt[e.magFilter],
      minFilter: yt[e.minFilter],
      wrapS: yt[e.wrapS],
      wrapT: yt[e.wrapT]
    };
    return t.samplers.push(n) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const n = this.options, s = this.cache, i = this.json;
    if (s.textures.has(e))
      return s.textures.get(e);
    i.textures || (i.textures = []), e instanceof vi && (e = bi(e, n.maxTextureSize));
    let r = e.userData.mimeType;
    r === "image/webp" && (r = "image/png");
    const a = {
      sampler: this.processSampler(e),
      source: this.processImage(e.image, e.format, e.flipY, r)
    };
    e.name && (a.name = e.name), this._invokeAll(function(c) {
      c.writeTexture && c.writeTexture(e, a);
    });
    const l = i.textures.push(a) - 1;
    return s.textures.set(e, l), l;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    const t = this.cache, n = this.json;
    if (t.materials.has(e))
      return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    n.materials || (n.materials = []);
    const s = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const i = e.color.toArray().concat([e.opacity]);
    if (ys(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
      const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {
        index: this.processTexture(a),
        channel: a.channel
      };
      this.applyTextureTransform(l, a), s.pbrMetallicRoughness.metallicRoughnessTexture = l;
    }
    if (e.map) {
      const a = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(a, e.map), s.pbrMetallicRoughness.baseColorTexture = a;
    }
    if (e.emissive) {
      const a = e.emissive;
      if (Math.max(a.r, a.g, a.b) > 0 && (s.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
        const c = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(c, e.emissiveMap), s.emissiveTexture = c;
      }
    }
    if (e.normalMap) {
      const a = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x), this.applyTextureTransform(a, e.normalMap), s.normalTexture = a;
    }
    if (e.aoMap) {
      const a = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), s.occlusionTexture = a;
    }
    e.transparent ? s.alphaMode = "BLEND" : e.alphaTest > 0 && (s.alphaMode = "MASK", s.alphaCutoff = e.alphaTest), e.side === wn && (s.doubleSided = !0), e.name !== "" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {
      a.writeMaterial && a.writeMaterial(e, s);
    });
    const r = n.materials.push(s) - 1;
    return t.materials.set(e, r), r;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = this.cache, n = this.json, s = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let x = 0, T = e.material.length; x < T; x++)
        s.push(e.material[x].uuid);
    else
      s.push(e.material.uuid);
    const i = s.join(":");
    if (t.meshes.has(i))
      return t.meshes.get(i);
    const r = e.geometry;
    let a;
    e.isLineSegments ? a = Ce.LINES : e.isLineLoop ? a = Ce.LINE_LOOP : e.isLine ? a = Ce.LINE_STRIP : e.isPoints ? a = Ce.POINTS : a = e.material.wireframe ? Ce.LINES : Ce.TRIANGLES;
    const l = {}, c = {}, u = [], h = [], f = {
      ...Pa >= 152 ? {
        uv: "TEXCOORD_0",
        uv1: "TEXCOORD_1",
        uv2: "TEXCOORD_2",
        uv3: "TEXCOORD_3"
      } : {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1"
      },
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, p = r.getAttribute("normal");
    p !== void 0 && !this.isNormalizedNormalAttribute(p) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(p)));
    let y = null;
    for (let x in r.attributes) {
      if (x.slice(0, 5) === "morph")
        continue;
      const T = r.attributes[x];
      if (x = f[x] || x.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(x) || (x = "_" + x), t.attributes.has(this.getUID(T))) {
        c[x] = t.attributes.get(this.getUID(T));
        continue;
      }
      y = null;
      const S = T.array;
      x === "JOINTS_0" && !(S instanceof Uint16Array) && !(S instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), y = new mt(new Uint16Array(S), T.itemSize, T.normalized));
      const M = this.processAccessor(y || T, r);
      M !== null && (x.startsWith("_") || this.detectMeshQuantization(x, T), c[x] = M, t.attributes.set(this.getUID(T), M));
    }
    if (p !== void 0 && r.setAttribute("normal", p), Object.keys(c).length === 0)
      return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const x = [], T = [], P = {};
      if (e.morphTargetDictionary !== void 0)
        for (const S in e.morphTargetDictionary)
          P[e.morphTargetDictionary[S]] = S;
      for (let S = 0; S < e.morphTargetInfluences.length; ++S) {
        const M = {};
        let m = !1;
        for (const b in r.morphAttributes) {
          if (b !== "position" && b !== "normal") {
            m || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), m = !0);
            continue;
          }
          const _ = r.morphAttributes[b][S], I = b.toUpperCase(), R = r.attributes[b];
          if (t.attributes.has(this.getUID(_, !0))) {
            M[I] = t.attributes.get(this.getUID(_, !0));
            continue;
          }
          const z = _.clone();
          if (!r.morphTargetsRelative)
            for (let k = 0, G = _.count; k < G; k++)
              for (let U = 0; U < _.itemSize; U++)
                U === 0 && z.setX(k, _.getX(k) - R.getX(k)), U === 1 && z.setY(k, _.getY(k) - R.getY(k)), U === 2 && z.setZ(k, _.getZ(k) - R.getZ(k)), U === 3 && z.setW(k, _.getW(k) - R.getW(k));
          M[I] = this.processAccessor(z, r), t.attributes.set(this.getUID(R, !0), M[I]);
        }
        h.push(M), x.push(e.morphTargetInfluences[S]), e.morphTargetDictionary !== void 0 && T.push(P[S]);
      }
      l.weights = x, T.length > 0 && (l.extras = {}, l.extras.targetNames = T);
    }
    const g = Array.isArray(e.material);
    if (g && r.groups.length === 0)
      return null;
    const v = g ? e.material : [e.material], d = g ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let x = 0, T = d.length; x < T; x++) {
      const P = {
        mode: a,
        attributes: c
      };
      if (this.serializeUserData(r, P), h.length > 0 && (P.targets = h), r.index !== null) {
        let M = this.getUID(r.index);
        (d[x].start !== void 0 || d[x].count !== void 0) && (M += ":" + d[x].start + ":" + d[x].count), t.attributes.has(M) ? P.indices = t.attributes.get(M) : (P.indices = this.processAccessor(r.index, r, d[x].start, d[x].count), t.attributes.set(M, P.indices)), P.indices === null && delete P.indices;
      }
      const S = this.processMaterial(v[d[x].materialIndex]);
      S !== null && (P.material = S), u.push(P);
    }
    l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll(function(x) {
      x.writeMesh && x.writeMesh(e, l);
    });
    const w = n.meshes.push(l) - 1;
    return t.meshes.set(i, w), w;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[Ei])
      return;
    let n;
    switch (t.array.constructor) {
      case Int8Array:
        n = "byte";
        break;
      case Uint8Array:
        n = "unsigned byte";
        break;
      case Int16Array:
        n = "short";
        break;
      case Uint16Array:
        n = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (n += " normalized");
    const s = e.split("_", 1)[0];
    Yr[s] && Yr[s].includes(n) && (this.extensionsUsed[Ei] = !0, this.extensionsRequired[Ei] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const n = e.isOrthographicCamera, s = {
      type: n ? "orthographic" : "perspective"
    };
    return n ? s.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : s.perspective = {
      aspectRatio: e.aspect,
      yfov: Ze.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (s.name = e.type), t.cameras.push(s) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const n = this.json, s = this.nodeMap;
    n.animations || (n.animations = []), e = Mr.Utils.mergeMorphTargetTracks(e.clone(), t);
    const i = e.tracks, r = [], a = [];
    for (let l = 0; l < i.length; ++l) {
      const c = i[l], u = Jt.parseTrackName(c.name);
      let h = Jt.findNode(t, u.nodeName);
      const f = Wr[u.propertyName];
      if (u.objectName === "bones" && (h.isSkinnedMesh === !0 ? h = h.skeleton.getBoneByName(u.objectIndex) : h = void 0), !h || !f)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
      const p = 1;
      let y = c.values.length / c.times.length;
      f === Wr.morphTargetInfluences && (y /= h.morphTargetInfluences.length);
      let g;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (g = "CUBICSPLINE", y /= 3) : c.getInterpolation() === ea ? g = "STEP" : g = "LINEAR", a.push({
        input: this.processAccessor(new mt(c.times, p)),
        output: this.processAccessor(new mt(c.values, y)),
        interpolation: g
      }), r.push({
        sampler: a.length - 1,
        target: {
          node: s.get(h),
          path: f
        }
      });
    }
    return n.animations.push({
      name: e.name || "clip_" + n.animations.length,
      samplers: a,
      channels: r
    }), n.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, n = this.nodeMap, s = t.nodes[n.get(e)], i = e.skeleton;
    if (i === void 0)
      return null;
    const r = e.skeleton.bones[0];
    if (r === void 0)
      return null;
    const a = [], l = new Float32Array(i.bones.length * 16), c = new Pe();
    for (let h = 0; h < i.bones.length; ++h)
      a.push(n.get(i.bones[h])), c.copy(i.boneInverses[h]), c.multiply(e.bindMatrix).toArray(l, h * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new mt(l, 16)),
      joints: a,
      skeleton: n.get(r)
    }), s.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = this.json, n = this.options, s = this.nodeMap;
    t.nodes || (t.nodes = []);
    const i = {};
    if (n.trs) {
      const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();
      ys(a, [0, 0, 0, 1]) || (i.rotation = a), ys(l, [0, 0, 0]) || (i.translation = l), ys(c, [1, 1, 1]) || (i.scale = c);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), Cc(e.matrix) === !1 && (i.matrix = e.matrix.elements);
    if (e.name !== "" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
      const a = this.processMesh(e);
      a !== null && (i.mesh = a);
    } else
      e.isCamera && (i.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const a = [];
      for (let l = 0, c = e.children.length; l < c; l++) {
        const u = e.children[l];
        if (u.visible || n.onlyVisible === !1) {
          const h = this.processNode(u);
          h !== null && a.push(h);
        }
      }
      a.length > 0 && (i.children = a);
    }
    this._invokeAll(function(a) {
      a.writeNode && a.writeNode(e, i);
    });
    const r = t.nodes.push(i) - 1;
    return s.set(e, r), r;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, n = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const s = {};
    e.name !== "" && (s.name = e.name), t.scenes.push(s);
    const i = [];
    for (let r = 0, a = e.children.length; r < a; r++) {
      const l = e.children[r];
      if (l.visible || n.onlyVisible === !1) {
        const c = this.processNode(l);
        c !== null && i.push(c);
      }
    }
    i.length > 0 && (s.nodes = i), this.serializeUserData(e, s);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new ws();
    t.name = "AuxScene";
    for (let n = 0; n < e.length; n++)
      t.children.push(e[n]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(s) {
      s.beforeParse && s.beforeParse(e);
    });
    const n = [];
    for (let s = 0; s < e.length; s++)
      e[s] instanceof ws ? this.processScene(e[s]) : n.push(e[s]);
    n.length > 0 && this.processObjects(n);
    for (let s = 0; s < this.skins.length; ++s)
      this.processSkin(this.skins[s]);
    for (let s = 0; s < t.animations.length; ++s)
      this.processAnimation(t.animations[s], e[0]);
    this._invokeAll(function(s) {
      s.afterParse && s.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, n = this.plugins.length; t < n; t++)
      e(this.plugins[t]);
  }
}
class Dc {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight)
      return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const n = this.writer, s = n.json, i = n.extensionsUsed, r = {};
    e.name && (r.name = e.name), r.color = e.color.toArray(), r.intensity = e.intensity, e.isDirectionalLight ? r.type = "directional" : e.isPointLight ? (r.type = "point", e.distance > 0 && (r.range = e.distance)) : e.isSpotLight && (r.type = "spot", e.distance > 0 && (r.range = e.distance), r.spot = {}, r.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, r.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn(
      "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."
    ), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn(
      "THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."
    ), i[this.name] || (s.extensions = s.extensions || {}, s.extensions[this.name] = { lights: [] }, i[this.name] = !0);
    const a = s.extensions[this.name].lights;
    a.push(r), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 };
  }
}
let Oc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial)
      return;
    const s = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}, Lc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      const r = {
        index: n.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatMap), i.clearcoatTexture = r;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      const r = {
        index: n.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = r;
    }
    if (e.clearcoatNormalMap) {
      const r = {
        index: n.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatNormalMap), i.clearcoatNormalTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Fc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      const r = {
        index: n.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      n.applyTextureTransform(r, e.iridescenceMap), i.iridescenceTexture = r;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      const r = {
        index: n.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      n.applyTextureTransform(r, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, kc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      const r = {
        index: n.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      n.applyTextureTransform(r, e.transmissionMap), i.transmissionTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Bc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      const r = {
        index: n.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      n.applyTextureTransform(r, e.thicknessMap), i.thicknessTexture = r;
    }
    i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Uc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Nc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(bc) && !e.specularIntensityMap && !e.specularColorTexture)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      const r = {
        index: n.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      n.applyTextureTransform(r, e.specularIntensityMap), i.specularTexture = r;
    }
    if (e.specularColorMap) {
      const r = {
        index: n.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      n.applyTextureTransform(r, e.specularColorMap), i.specularColorTexture = r;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, zc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      const r = {
        index: n.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      n.applyTextureTransform(r, e.sheenRoughnessMap), i.sheenRoughnessTexture = r;
    }
    if (e.sheenColorMap) {
      const r = {
        index: n.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      n.applyTextureTransform(r, e.sheenColorMap), i.sheenColorTexture = r;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Hc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      const r = { index: n.processTexture(e.anisotropyMap) };
      n.applyTextureTransform(r, e.anisotropyMap), i.anisotropyTexture = r;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, jc = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
};
var Et = Uint8Array, yn = Uint16Array, ar = Uint32Array, Ia = new Et([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Ra = new Et([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Gc = new Et([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Da = function(o, e) {
  for (var t = new yn(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << o[n - 1];
  for (var s = new ar(t[30]), n = 1; n < 30; ++n)
    for (var i = t[n]; i < t[n + 1]; ++i)
      s[i] = i - t[n] << 5 | n;
  return [t, s];
}, Oa = Da(Ia, 2), La = Oa[0], Vc = Oa[1];
La[28] = 258, Vc[258] = 28;
var Yc = Da(Ra, 0), Wc = Yc[0], lr = new yn(32768);
for (var Ge = 0; Ge < 32768; ++Ge) {
  var an = (Ge & 43690) >>> 1 | (Ge & 21845) << 1;
  an = (an & 52428) >>> 2 | (an & 13107) << 2, an = (an & 61680) >>> 4 | (an & 3855) << 4, lr[Ge] = ((an & 65280) >>> 8 | (an & 255) << 8) >>> 1;
}
var _s = function(o, e, t) {
  for (var n = o.length, s = 0, i = new yn(e); s < n; ++s)
    ++i[o[s] - 1];
  var r = new yn(e);
  for (s = 0; s < e; ++s)
    r[s] = r[s - 1] + i[s - 1] << 1;
  var a;
  if (t) {
    a = new yn(1 << e);
    var l = 15 - e;
    for (s = 0; s < n; ++s)
      if (o[s])
        for (var c = s << 4 | o[s], u = e - o[s], h = r[o[s] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h)
          a[lr[h] >>> l] = c;
  } else
    for (a = new yn(n), s = 0; s < n; ++s)
      o[s] && (a[s] = lr[r[o[s] - 1]++] >>> 15 - o[s]);
  return a;
}, Ps = new Et(288);
for (var Ge = 0; Ge < 144; ++Ge)
  Ps[Ge] = 8;
for (var Ge = 144; Ge < 256; ++Ge)
  Ps[Ge] = 9;
for (var Ge = 256; Ge < 280; ++Ge)
  Ps[Ge] = 7;
for (var Ge = 280; Ge < 288; ++Ge)
  Ps[Ge] = 8;
var Fa = new Et(32);
for (var Ge = 0; Ge < 32; ++Ge)
  Fa[Ge] = 5;
var Xc = /* @__PURE__ */ _s(Ps, 9, 1), $c = /* @__PURE__ */ _s(Fa, 5, 1), Mi = function(o) {
  for (var e = o[0], t = 1; t < o.length; ++t)
    o[t] > e && (e = o[t]);
  return e;
}, Pt = function(o, e, t) {
  var n = e / 8 | 0;
  return (o[n] | o[n + 1] << 8) >> (e & 7) & t;
}, Ai = function(o, e) {
  var t = e / 8 | 0;
  return (o[t] | o[t + 1] << 8 | o[t + 2] << 16) >> (e & 7);
}, Zc = function(o) {
  return (o / 8 | 0) + (o & 7 && 1);
}, qc = function(o, e, t) {
  (t == null || t > o.length) && (t = o.length);
  var n = new (o instanceof yn ? yn : o instanceof ar ? ar : Et)(t - e);
  return n.set(o.subarray(e, t)), n;
}, Kc = function(o, e, t) {
  var n = o.length;
  if (!n || t && !t.l && n < 5)
    return e || new Et(0);
  var s = !e || t, i = !t || t.i;
  t || (t = {}), e || (e = new Et(n * 3));
  var r = function(L) {
    var O = e.length;
    if (L > O) {
      var N = new Et(Math.max(O * 2, L));
      N.set(e), e = N;
    }
  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, u = t.l, h = t.d, f = t.m, p = t.n, y = n * 8;
  do {
    if (!u) {
      t.f = a = Pt(o, l, 1);
      var g = Pt(o, l + 1, 3);
      if (l += 3, g)
        if (g == 1)
          u = Xc, h = $c, f = 9, p = 5;
        else if (g == 2) {
          var x = Pt(o, l, 31) + 257, T = Pt(o, l + 10, 15) + 4, P = x + Pt(o, l + 5, 31) + 1;
          l += 14;
          for (var S = new Et(P), M = new Et(19), m = 0; m < T; ++m)
            M[Gc[m]] = Pt(o, l + m * 3, 7);
          l += T * 3;
          for (var b = Mi(M), _ = (1 << b) - 1, I = _s(M, b, 1), m = 0; m < P; ) {
            var R = I[Pt(o, l, _)];
            l += R & 15;
            var v = R >>> 4;
            if (v < 16)
              S[m++] = v;
            else {
              var z = 0, k = 0;
              for (v == 16 ? (k = 3 + Pt(o, l, 3), l += 2, z = S[m - 1]) : v == 17 ? (k = 3 + Pt(o, l, 7), l += 3) : v == 18 && (k = 11 + Pt(o, l, 127), l += 7); k--; )
                S[m++] = z;
            }
          }
          var G = S.subarray(0, x), U = S.subarray(x);
          f = Mi(G), p = Mi(U), u = _s(G, f, 1), h = _s(U, p, 1);
        } else
          throw "invalid block type";
      else {
        var v = Zc(l) + 4, d = o[v - 4] | o[v - 3] << 8, w = v + d;
        if (w > n) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && r(c + d), e.set(o.subarray(v, w), c), t.b = c += d, t.p = l = w * 8;
        continue;
      }
      if (l > y) {
        if (i)
          throw "unexpected EOF";
        break;
      }
    }
    s && r(c + 131072);
    for (var q = (1 << f) - 1, $ = (1 << p) - 1, te = l; ; te = l) {
      var z = u[Ai(o, l) & q], ee = z >>> 4;
      if (l += z & 15, l > y) {
        if (i)
          throw "unexpected EOF";
        break;
      }
      if (!z)
        throw "invalid length/literal";
      if (ee < 256)
        e[c++] = ee;
      else if (ee == 256) {
        te = l, u = null;
        break;
      } else {
        var oe = ee - 254;
        if (ee > 264) {
          var m = ee - 257, de = Ia[m];
          oe = Pt(o, l, (1 << de) - 1) + La[m], l += de;
        }
        var xe = h[Ai(o, l) & $], C = xe >>> 4;
        if (!xe)
          throw "invalid distance";
        l += xe & 15;
        var U = Wc[C];
        if (C > 3) {
          var de = Ra[C];
          U += Ai(o, l) & (1 << de) - 1, l += de;
        }
        if (l > y) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && r(c + 131072);
        for (var B = c + oe; c < B; c += 4)
          e[c] = e[c - U], e[c + 1] = e[c + 1 - U], e[c + 2] = e[c + 2 - U], e[c + 3] = e[c + 3 - U];
        c = B;
      }
    }
    t.l = u, t.p = te, t.b = c, u && (a = 1, t.m = f, t.d = h, t.n = p);
  } while (!a);
  return c == e.length ? e : qc(e, 0, c);
}, Qc = /* @__PURE__ */ new Et(0), Jc = function(o) {
  if ((o[0] & 15) != 8 || o[0] >>> 4 > 7 || (o[0] << 8 | o[1]) % 31)
    throw "invalid zlib data";
  if (o[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function eu(o, e) {
  return Kc((Jc(o), o.subarray(2, -4)), e);
}
var tu = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), nu = 0;
try {
  tu.decode(Qc, { stream: !0 }), nu = 1;
} catch {
}
const et = new wl(), js = new Z();
class su {
  constructor(e) {
    let t = e.geometry;
    t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null;
  }
  setWeightAttribute(e) {
    return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this;
  }
  build() {
    const e = this.positionAttribute, t = this.weightAttribute, n = new Float32Array(e.count / 3);
    for (let i = 0; i < e.count; i += 3) {
      let r = 1;
      t && (r = t.getX(i) + t.getX(i + 1) + t.getX(i + 2)), et.a.fromBufferAttribute(e, i), et.b.fromBufferAttribute(e, i + 1), et.c.fromBufferAttribute(e, i + 2), r *= et.getArea(), n[i / 3] = r;
    }
    this.distribution = new Float32Array(e.count / 3);
    let s = 0;
    for (let i = 0; i < n.length; i++)
      s += n[i], this.distribution[i] = s;
    return this;
  }
  setRandomGenerator(e) {
    return this.randomFunction = e, this;
  }
  sample(e, t, n) {
    const s = this.sampleFaceIndex();
    return this.sampleFace(s, e, t, n);
  }
  sampleFaceIndex() {
    const e = this.distribution[this.distribution.length - 1];
    return this.binarySearch(this.randomFunction() * e);
  }
  binarySearch(e) {
    const t = this.distribution;
    let n = 0, s = t.length - 1, i = -1;
    for (; n <= s; ) {
      const r = Math.ceil((n + s) / 2);
      if (r === 0 || t[r - 1] <= e && t[r] > e) {
        i = r;
        break;
      } else
        e < t[r] ? s = r - 1 : n = r + 1;
    }
    return i;
  }
  sampleFace(e, t, n, s) {
    let i = this.randomFunction(), r = this.randomFunction();
    return i + r > 1 && (i = 1 - i, r = 1 - r), et.a.fromBufferAttribute(this.positionAttribute, e * 3), et.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), et.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(et.a, i).addScaledVector(et.b, r).addScaledVector(et.c, 1 - (i + r)), n !== void 0 && et.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (et.a.fromBufferAttribute(this.colorAttribute, e * 3), et.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), et.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), js.set(0, 0, 0).addScaledVector(et.a, i).addScaledVector(et.b, r).addScaledVector(et.c, 1 - (i + r)), s.r = js.x, s.g = js.y, s.b = js.z), this;
  }
}
var iu = Object.defineProperty, ru = (o, e, t) => e in o ? iu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, K = (o, e, t) => (ru(o, typeof e != "symbol" ? e + "" : e, t), t);
class ou extends Mt {
  constructor(e, t) {
    super(), K(this, "isTransformControls", !0), K(this, "visible", !1), K(this, "domElement"), K(this, "raycaster", new oa()), K(this, "gizmo"), K(this, "plane"), K(this, "tempVector", new Z()), K(this, "tempVector2", new Z()), K(this, "tempQuaternion", new He()), K(this, "unit", {
      X: new Z(1, 0, 0),
      Y: new Z(0, 1, 0),
      Z: new Z(0, 0, 1)
    }), K(this, "pointStart", new Z()), K(this, "pointEnd", new Z()), K(this, "offset", new Z()), K(this, "rotationAxis", new Z()), K(this, "startNorm", new Z()), K(this, "endNorm", new Z()), K(this, "rotationAngle", 0), K(this, "cameraPosition", new Z()), K(this, "cameraQuaternion", new He()), K(this, "cameraScale", new Z()), K(this, "parentPosition", new Z()), K(this, "parentQuaternion", new He()), K(this, "parentQuaternionInv", new He()), K(this, "parentScale", new Z()), K(this, "worldPositionStart", new Z()), K(this, "worldQuaternionStart", new He()), K(this, "worldScaleStart", new Z()), K(this, "worldPosition", new Z()), K(this, "worldQuaternion", new He()), K(this, "worldQuaternionInv", new He()), K(this, "worldScale", new Z()), K(this, "eye", new Z()), K(this, "positionStart", new Z()), K(this, "quaternionStart", new He()), K(this, "scaleStart", new Z()), K(this, "camera"), K(this, "object"), K(this, "enabled", !0), K(this, "axis", null), K(this, "mode", "translate"), K(this, "translationSnap", null), K(this, "rotationSnap", null), K(this, "scaleSnap", null), K(this, "space", "world"), K(this, "size", 1), K(this, "dragging", !1), K(this, "showX", !0), K(this, "showY", !0), K(this, "showZ", !0), K(this, "changeEvent", { type: "change" }), K(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), K(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), K(this, "objectChangeEvent", { type: "objectChange" }), K(this, "intersectObjectWithRay", (s, i, r) => {
      const a = i.intersectObject(s, !0);
      for (let l = 0; l < a.length; l++)
        if (a[l].object.visible || r)
          return a[l];
      return !1;
    }), K(this, "attach", (s) => (this.object = s, this.visible = !0, this)), K(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), K(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), K(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), K(this, "pointerHover", (s) => {
      if (this.object === void 0 || this.dragging === !0)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      i ? this.axis = i.object.name : this.axis = null;
    }), K(this, "pointerDown", (s) => {
      if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(s, this.camera);
        const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
        if (i) {
          let r = this.space;
          if (this.mode === "scale" ? r = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (r = "world"), r === "local" && this.mode === "rotate") {
            const a = this.rotationSnap;
            this.axis === "X" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === "Y" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === "Z" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);
        }
        this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), K(this, "pointerMove", (s) => {
      const i = this.axis, r = this.mode, a = this.object;
      let l = this.space;
      if (r === "scale" ? l = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (l = "world"), a === void 0 || i === null || this.dragging === !1 || s.button !== -1)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), r === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), l === "local" && i !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf("X") === -1 && (this.offset.x = 0), i.indexOf("Y") === -1 && (this.offset.y = 0), i.indexOf("Z") === -1 && (this.offset.z = 0), l === "local" && i !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (l === "local" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), l === "world" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
        else if (r === "scale") {
          if (i.search("XYZ") !== -1) {
            let u = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (u *= -1), this.tempVector2.set(u, u, u);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search("X") === -1 && (this.tempVector2.x = 1), i.search("Y") === -1 && (this.tempVector2.y = 1), i.search("Z") === -1 && (this.tempVector2.z = 1);
          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search("X") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (r === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const u = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * u) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), l === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * u), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), l === "local" && i !== "E" && i !== "XYZE" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), K(this, "pointerUp", (s) => {
      s.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);
    }), K(this, "getPointer", (s) => {
      var i;
      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: s.button
        };
      {
        const r = s.changedTouches ? s.changedTouches[0] : s, a = this.domElement.getBoundingClientRect();
        return {
          x: (r.clientX - a.left) / a.width * 2 - 1,
          y: -(r.clientY - a.top) / a.height * 2 + 1,
          button: s.button
        };
      }
    }), K(this, "onPointerHover", (s) => {
      if (this.enabled)
        switch (s.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(s));
            break;
        }
    }), K(this, "onPointerDown", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(s)), this.pointerDown(this.getPointer(s)));
    }), K(this, "onPointerMove", (s) => {
      this.enabled && this.pointerMove(this.getPointer(s));
    }), K(this, "onPointerUp", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(s)));
    }), K(this, "getMode", () => this.mode), K(this, "setMode", (s) => {
      this.mode = s;
    }), K(this, "setTranslationSnap", (s) => {
      this.translationSnap = s;
    }), K(this, "setRotationSnap", (s) => {
      this.rotationSnap = s;
    }), K(this, "setScaleSnap", (s) => {
      this.scaleSnap = s;
    }), K(this, "setSize", (s) => {
      this.size = s;
    }), K(this, "setSpace", (s) => {
      this.space = s;
    }), K(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), K(this, "connect", (s) => {
      s === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = s, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), K(this, "dispose", () => {
      var s, i, r, a, l, c;
      (s = this.domElement) == null || s.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (a = (r = this.domElement) == null ? void 0 : r.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (c = (l = this.domElement) == null ? void 0 : l.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((u) => {
        const h = u;
        h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
      });
    }), this.domElement = t, this.camera = e, this.gizmo = new au(), this.add(this.gizmo), this.plane = new lu(), this.add(this.plane);
    const n = (s, i) => {
      let r = i;
      Object.defineProperty(this, s, {
        get: function() {
          return r !== void 0 ? r : i;
        },
        set: function(a) {
          r !== a && (r = a, this.plane[s] = a, this.gizmo[s] = a, this.dispatchEvent({ type: s + "-changed", value: a }), this.dispatchEvent(this.changeEvent));
        }
      }), this[s] = i, this.plane[s] = i, this.gizmo[s] = i;
    };
    n("camera", this.camera), n("object", this.object), n("enabled", this.enabled), n("axis", this.axis), n("mode", this.mode), n("translationSnap", this.translationSnap), n("rotationSnap", this.rotationSnap), n("scaleSnap", this.scaleSnap), n("space", this.space), n("size", this.size), n("dragging", this.dragging), n("showX", this.showX), n("showY", this.showY), n("showZ", this.showZ), n("worldPosition", this.worldPosition), n("worldPositionStart", this.worldPositionStart), n("worldQuaternion", this.worldQuaternion), n("worldQuaternionStart", this.worldQuaternionStart), n("cameraPosition", this.cameraPosition), n("cameraQuaternion", this.cameraQuaternion), n("pointStart", this.pointStart), n("pointEnd", this.pointEnd), n("rotationAxis", this.rotationAxis), n("rotationAngle", this.rotationAngle), n("eye", this.eye), t !== void 0 && this.connect(t);
  }
}
class au extends Mt {
  constructor() {
    super(), K(this, "isTransformControlsGizmo", !0), K(this, "type", "TransformControlsGizmo"), K(this, "tempVector", new Z(0, 0, 0)), K(this, "tempEuler", new Rn()), K(this, "alignVector", new Z(0, 1, 0)), K(this, "zeroVector", new Z(0, 0, 0)), K(this, "lookAtMatrix", new Pe()), K(this, "tempQuaternion", new He()), K(this, "tempQuaternion2", new He()), K(this, "identityQuaternion", new He()), K(this, "unitX", new Z(1, 0, 0)), K(this, "unitY", new Z(0, 1, 0)), K(this, "unitZ", new Z(0, 0, 1)), K(this, "gizmo"), K(this, "picker"), K(this, "helper"), K(this, "rotationAxis", new Z()), K(this, "cameraPosition", new Z()), K(this, "worldPositionStart", new Z()), K(this, "worldQuaternionStart", new He()), K(this, "worldPosition", new Z()), K(this, "worldQuaternion", new He()), K(this, "eye", new Z()), K(this, "camera", null), K(this, "enabled", !0), K(this, "axis", null), K(this, "mode", "translate"), K(this, "space", "world"), K(this, "size", 1), K(this, "dragging", !1), K(this, "showX", !0), K(this, "showY", !0), K(this, "showZ", !0), K(this, "updateMatrixWorld", () => {
      let ee = this.space;
      this.mode === "scale" && (ee = "local");
      const oe = ee === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let de = [];
      de = de.concat(this.picker[this.mode].children), de = de.concat(this.gizmo[this.mode].children), de = de.concat(this.helper[this.mode].children);
      for (let xe = 0; xe < de.length; xe++) {
        const C = de[xe];
        C.visible = !0, C.rotation.set(0, 0, 0), C.position.copy(this.worldPosition);
        let B;
        if (this.camera.isOrthographicCamera ? B = (this.camera.top - this.camera.bottom) / this.camera.zoom : B = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), C.scale.set(1, 1, 1).multiplyScalar(B * this.size / 7), C.tag === "helper") {
          C.visible = !1, C.name === "AXIS" ? (C.position.copy(this.worldPositionStart), C.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), C.quaternion.copy(oe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(oe).dot(this.eye)) > 0.9 && (C.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), C.quaternion.copy(oe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(oe).dot(this.eye)) > 0.9 && (C.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), C.quaternion.copy(oe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(oe).dot(this.eye)) > 0.9 && (C.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), C.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), C.quaternion.multiply(this.tempQuaternion), C.visible = this.dragging), this.axis === "E" && (C.visible = !1)) : C.name === "START" ? (C.position.copy(this.worldPositionStart), C.visible = this.dragging) : C.name === "END" ? (C.position.copy(this.worldPosition), C.visible = this.dragging) : C.name === "DELTA" ? (C.position.copy(this.worldPositionStart), C.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), C.scale.copy(this.tempVector), C.visible = this.dragging) : (C.quaternion.copy(oe), this.dragging ? C.position.copy(this.worldPositionStart) : C.position.copy(this.worldPosition), this.axis && (C.visible = this.axis.search(C.name) !== -1));
          continue;
        }
        C.quaternion.copy(oe), this.mode === "translate" || this.mode === "scale" ? ((C.name === "X" || C.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(oe).dot(this.eye)) > 0.99 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = !1), (C.name === "Y" || C.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(oe).dot(this.eye)) > 0.99 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = !1), (C.name === "Z" || C.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(oe).dot(this.eye)) > 0.99 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = !1), C.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(oe).dot(this.eye)) < 0.2 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = !1), C.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(oe).dot(this.eye)) < 0.2 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = !1), C.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(oe).dot(this.eye)) < 0.2 && (C.scale.set(1e-10, 1e-10, 1e-10), C.visible = !1), C.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(oe).dot(this.eye) < 0 ? C.tag === "fwd" ? C.visible = !1 : C.scale.x *= -1 : C.tag === "bwd" && (C.visible = !1)), C.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(oe).dot(this.eye) < 0 ? C.tag === "fwd" ? C.visible = !1 : C.scale.y *= -1 : C.tag === "bwd" && (C.visible = !1)), C.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(oe).dot(this.eye) < 0 ? C.tag === "fwd" ? C.visible = !1 : C.scale.z *= -1 : C.tag === "bwd" && (C.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy(oe), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(oe).invert()), C.name.search("E") !== -1 && C.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), C.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), C.quaternion.copy(this.tempQuaternion)), C.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), C.quaternion.copy(this.tempQuaternion)), C.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), C.quaternion.copy(this.tempQuaternion))), C.visible = C.visible && (C.name.indexOf("X") === -1 || this.showX), C.visible = C.visible && (C.name.indexOf("Y") === -1 || this.showY), C.visible = C.visible && (C.name.indexOf("Z") === -1 || this.showZ), C.visible = C.visible && (C.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), C.material.tempOpacity = C.material.tempOpacity || C.material.opacity, C.material.tempColor = C.material.tempColor || C.material.color.clone(), C.material.color.copy(C.material.tempColor), C.material.opacity = C.material.tempOpacity, this.enabled ? this.axis && (C.name === this.axis ? (C.material.opacity = 1, C.material.color.lerp(new Re(1, 1, 1), 0.5)) : this.axis.split("").some(function(L) {
          return C.name === L;
        }) ? (C.material.opacity = 1, C.material.color.lerp(new Re(1, 1, 1), 0.5)) : (C.material.opacity *= 0.25, C.material.color.lerp(new Re(1, 1, 1), 0.5))) : (C.material.opacity *= 0.5, C.material.color.lerp(new Re(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const e = new Zt({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      side: wn,
      fog: !1,
      toneMapped: !1
    }), t = new ts({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      linewidth: 1,
      fog: !1,
      toneMapped: !1
    }), n = e.clone();
    n.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.33;
    const i = e.clone();
    i.color.set(16711680);
    const r = e.clone();
    r.color.set(65280);
    const a = e.clone();
    a.color.set(255);
    const l = e.clone();
    l.opacity = 0.25;
    const c = l.clone();
    c.color.set(16776960);
    const u = l.clone();
    u.color.set(65535);
    const h = l.clone();
    h.color.set(16711935), e.clone().color.set(16776960);
    const p = t.clone();
    p.color.set(16711680);
    const y = t.clone();
    y.color.set(65280);
    const g = t.clone();
    g.color.set(255);
    const v = t.clone();
    v.color.set(65535);
    const d = t.clone();
    d.color.set(16711935);
    const w = t.clone();
    w.color.set(16776960);
    const x = t.clone();
    x.color.set(7895160);
    const T = w.clone();
    T.opacity = 0.25;
    const P = new At(0, 0.05, 0.2, 12, 1, !1), S = new $t(0.125, 0.125, 0.125), M = new at();
    M.setAttribute("position", new rt([0, 0, 0, 1, 0, 0], 3));
    const m = (ee, oe) => {
      const de = new at(), xe = [];
      for (let C = 0; C <= 64 * oe; ++C)
        xe.push(0, Math.cos(C / 32 * Math.PI) * ee, Math.sin(C / 32 * Math.PI) * ee);
      return de.setAttribute("position", new rt(xe, 3)), de;
    }, b = () => {
      const ee = new at();
      return ee.setAttribute("position", new rt([0, 0, 0, 1, 1, 1], 3)), ee;
    }, _ = {
      X: [
        [new le(P, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new le(P, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new Ie(M, p)]
      ],
      Y: [
        [new le(P, r), [0, 1, 0], null, null, "fwd"],
        [new le(P, r), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new Ie(M, y), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new le(P, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new le(P, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new Ie(M, g), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new le(new Sn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new le(new Ut(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new Ie(M, w), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new Ie(M, w), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new le(new Ut(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new Ie(M, v), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Ie(M, v), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new le(new Ut(0.295, 0.295), h.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new Ie(M, d), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new Ie(M, d), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, I = {
      X: [[new le(new At(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new le(new At(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],
      Z: [[new le(new At(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new le(new Sn(0.2, 0), n)]],
      XY: [[new le(new Ut(0.4, 0.4), n), [0.2, 0.2, 0]]],
      YZ: [[new le(new Ut(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new le(new Ut(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, R = {
      START: [[new le(new Sn(0.01, 2), s), null, null, null, "helper"]],
      END: [[new le(new Sn(0.01, 2), s), null, null, null, "helper"]],
      DELTA: [[new Ie(b(), s), null, null, null, "helper"]],
      X: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Ie(M, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Ie(M, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, z = {
      X: [
        [new Ie(m(1, 0.5), p)],
        [new le(new Sn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new Ie(m(1, 0.5), y), null, [0, 0, -Math.PI / 2]],
        [new le(new Sn(0.04, 0), r), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new Ie(m(1, 0.5), g), null, [0, Math.PI / 2, 0]],
        [new le(new Sn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new Ie(m(1.25, 1), T), null, [0, Math.PI / 2, 0]],
        [
          new le(new At(0.03, 0, 0.15, 4, 1, !1), T),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new le(new At(0.03, 0, 0.15, 4, 1, !1), T),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new le(new At(0.03, 0, 0.15, 4, 1, !1), T),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new le(new At(0.03, 0, 0.15, 4, 1, !1), T),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new Ie(m(1, 1), x), null, [0, Math.PI / 2, 0]]]
    }, k = {
      AXIS: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, G = {
      X: [[new le(new ks(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new le(new ks(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new le(new ks(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new le(new ks(1.25, 0.1, 2, 24), n)]],
      XYZE: [[new le(new Tl(0.7, 10, 8), n)]]
    }, U = {
      X: [
        [new le(S, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ie(M, p), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new le(S, r), [0, 0.8, 0]],
        [new Ie(M, y), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new le(S, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new Ie(M, g), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new le(S, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new Ie(M, w), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new Ie(M, w), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new le(S, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new Ie(M, v), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Ie(M, v), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new le(S, h), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new Ie(M, d), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new Ie(M, d), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new le(new $t(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],
      XYZY: [[new le(new $t(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],
      XYZZ: [[new le(new $t(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]
    }, q = {
      X: [[new le(new At(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new le(new At(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],
      Z: [[new le(new At(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new le(S, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new le(S, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new le(S, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new le(new $t(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],
      XYZY: [[new le(new $t(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],
      XYZZ: [[new le(new $t(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]
    }, $ = {
      X: [[new Ie(M, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Ie(M, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Ie(M, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, te = (ee) => {
      const oe = new Mt();
      for (let de in ee)
        for (let xe = ee[de].length; xe--; ) {
          const C = ee[de][xe][0].clone(), B = ee[de][xe][1], L = ee[de][xe][2], O = ee[de][xe][3], N = ee[de][xe][4];
          C.name = de, C.tag = N, B && C.position.set(B[0], B[1], B[2]), L && C.rotation.set(L[0], L[1], L[2]), O && C.scale.set(O[0], O[1], O[2]), C.updateMatrix();
          const E = C.geometry.clone();
          E.applyMatrix4(C.matrix), C.geometry = E, C.renderOrder = 1 / 0, C.position.set(0, 0, 0), C.rotation.set(0, 0, 0), C.scale.set(1, 1, 1), oe.add(C);
        }
      return oe;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = te(_)), this.add(this.gizmo.rotate = te(z)), this.add(this.gizmo.scale = te(U)), this.add(this.picker.translate = te(I)), this.add(this.picker.rotate = te(G)), this.add(this.picker.scale = te(q)), this.add(this.helper.translate = te(R)), this.add(this.helper.rotate = te(k)), this.add(this.helper.scale = te($)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
}
class lu extends le {
  constructor() {
    super(
      new Ut(1e5, 1e5, 2, 2),
      new Zt({
        visible: !1,
        wireframe: !0,
        side: wn,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1
      })
    ), K(this, "isTransformControlsPlane", !0), K(this, "type", "TransformControlsPlane"), K(this, "unitX", new Z(1, 0, 0)), K(this, "unitY", new Z(0, 1, 0)), K(this, "unitZ", new Z(0, 0, 1)), K(this, "tempVector", new Z()), K(this, "dirVector", new Z()), K(this, "alignVector", new Z()), K(this, "tempMatrix", new Pe()), K(this, "identityQuaternion", new He()), K(this, "cameraQuaternion", new He()), K(this, "worldPosition", new Z()), K(this, "worldQuaternion", new He()), K(this, "eye", new Z()), K(this, "axis", null), K(this, "mode", "translate"), K(this, "space", "world"), K(this, "updateMatrixWorld", () => {
      let e = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
}
var cu = Object.defineProperty, uu = (o, e, t) => e in o ? cu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Qe = (o, e, t) => (uu(o, typeof e != "symbol" ? e + "" : e, t), t);
const zn = new Rn(0, 0, 0, "YXZ"), Hn = new Z(), hu = { type: "change" }, fu = { type: "lock" }, du = { type: "unlock" }, Kr = Math.PI / 2;
class cr extends aa {
  constructor(e, t) {
    super(), Qe(this, "camera"), Qe(this, "domElement"), Qe(this, "isLocked"), Qe(this, "minPolarAngle"), Qe(this, "maxPolarAngle"), Qe(this, "pointerSpeed"), Qe(this, "onMouseMove", (n) => {
      if (!this.domElement || this.isLocked === !1)
        return;
      const s = n.movementX || n.mozMovementX || n.webkitMovementX || 0, i = n.movementY || n.mozMovementY || n.webkitMovementY || 0;
      zn.setFromQuaternion(this.camera.quaternion), zn.y -= s * 2e-3 * this.pointerSpeed, zn.x -= i * 2e-3 * this.pointerSpeed, zn.x = Math.max(Kr - this.maxPolarAngle, Math.min(Kr - this.minPolarAngle, zn.x)), this.camera.quaternion.setFromEuler(zn), this.dispatchEvent(hu);
    }), Qe(this, "onPointerlockChange", () => {
      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(fu), this.isLocked = !0) : (this.dispatchEvent(du), this.isLocked = !1));
    }), Qe(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }), Qe(this, "connect", (n) => {
      this.domElement = n || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
    }), Qe(this, "disconnect", () => {
      this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
    }), Qe(this, "dispose", () => {
      this.disconnect();
    }), Qe(this, "getObject", () => this.camera), Qe(this, "direction", new Z(0, 0, -1)), Qe(this, "getDirection", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Qe(this, "moveForward", (n) => {
      Hn.setFromMatrixColumn(this.camera.matrix, 0), Hn.crossVectors(this.camera.up, Hn), this.camera.position.addScaledVector(Hn, n);
    }), Qe(this, "moveRight", (n) => {
      Hn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Hn, n);
    }), Qe(this, "lock", () => {
      this.domElement && this.domElement.requestPointerLock();
    }), Qe(this, "unlock", () => {
      this.domElement && this.domElement.ownerDocument.exitPointerLock();
    }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
  }
}
var pu = Object.defineProperty, mu = (o, e, t) => e in o ? pu(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, we = (o, e, t) => (mu(o, typeof e != "symbol" ? e + "" : e, t), t);
const Gs = new bl(), Qr = new hi(), gu = Math.cos(70 * (Math.PI / 180)), Jr = (o, e) => (o % e + e) % e;
class ka extends aa {
  constructor(e, t) {
    super(), we(this, "object"), we(this, "domElement"), we(this, "enabled", !0), we(this, "target", new Z()), we(this, "minDistance", 0), we(this, "maxDistance", 1 / 0), we(this, "minZoom", 0), we(this, "maxZoom", 1 / 0), we(this, "minPolarAngle", 0), we(this, "maxPolarAngle", Math.PI), we(this, "minAzimuthAngle", -1 / 0), we(this, "maxAzimuthAngle", 1 / 0), we(this, "enableDamping", !1), we(this, "dampingFactor", 0.05), we(this, "enableZoom", !0), we(this, "zoomSpeed", 1), we(this, "enableRotate", !0), we(this, "rotateSpeed", 1), we(this, "enablePan", !0), we(this, "panSpeed", 1), we(this, "screenSpacePanning", !0), we(this, "keyPanSpeed", 7), we(this, "zoomToCursor", !1), we(this, "autoRotate", !1), we(this, "autoRotateSpeed", 2), we(this, "reverseOrbit", !1), we(this, "reverseHorizontalOrbit", !1), we(this, "reverseVerticalOrbit", !1), we(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), we(this, "mouseButtons", {
      LEFT: pn.ROTATE,
      MIDDLE: pn.DOLLY,
      RIGHT: pn.PAN
    }), we(this, "touches", { ONE: Nt.ROTATE, TWO: Nt.DOLLY_PAN }), we(this, "target0"), we(this, "position0"), we(this, "zoom0"), we(this, "_domElementKeyEvents", null), we(this, "getPolarAngle"), we(this, "getAzimuthalAngle"), we(this, "setPolarAngle"), we(this, "setAzimuthalAngle"), we(this, "getDistance"), we(this, "listenToKeyEvents"), we(this, "stopListenToKeyEvents"), we(this, "saveState"), we(this, "reset"), we(this, "update"), we(this, "connect"), we(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = (X) => {
      let ie = Jr(X, 2 * Math.PI), Te = u.phi;
      Te < 0 && (Te += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
      let Be = Math.abs(ie - Te);
      2 * Math.PI - Be < Be && (ie < Te ? ie += 2 * Math.PI : Te += 2 * Math.PI), h.phi = ie - Te, n.update();
    }, this.setAzimuthalAngle = (X) => {
      let ie = Jr(X, 2 * Math.PI), Te = u.theta;
      Te < 0 && (Te += 2 * Math.PI), ie < 0 && (ie += 2 * Math.PI);
      let Be = Math.abs(ie - Te);
      2 * Math.PI - Be < Be && (ie < Te ? ie += 2 * Math.PI : Te += 2 * Math.PI), h.theta = ie - Te, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (X) => {
      X.addEventListener("keydown", sn), this._domElementKeyEvents = X;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", sn), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(s), n.update(), l = a.NONE;
    }, this.update = (() => {
      const X = new Z(), ie = new Z(0, 1, 0), Te = new He().setFromUnitVectors(e.up, ie), Be = Te.clone().invert(), Je = new Z(), Gt = new He(), rn = 2 * Math.PI;
      return function() {
        const zr = n.object.position;
        Te.setFromUnitVectors(e.up, ie), Be.copy(Te).invert(), X.copy(zr).sub(n.target), X.applyQuaternion(Te), u.setFromVector3(X), n.autoRotate && l === a.NONE && k(R()), n.enableDamping ? (u.theta += h.theta * n.dampingFactor, u.phi += h.phi * n.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
        let Vt = n.minAzimuthAngle, Yt = n.maxAzimuthAngle;
        isFinite(Vt) && isFinite(Yt) && (Vt < -Math.PI ? Vt += rn : Vt > Math.PI && (Vt -= rn), Yt < -Math.PI ? Yt += rn : Yt > Math.PI && (Yt -= rn), Vt <= Yt ? u.theta = Math.max(Vt, Math.min(Yt, u.theta)) : u.theta = u.theta > (Vt + Yt) / 2 ? Math.max(Vt, u.theta) : Math.min(Yt, u.theta)), u.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, u.phi)), u.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(p, n.dampingFactor) : n.target.add(p), n.zoomToCursor && b || n.object.isOrthographicCamera ? u.radius = de(u.radius) : u.radius = de(u.radius * f), X.setFromSpherical(u), X.applyQuaternion(Be), zr.copy(n.target).add(X), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (h.theta *= 1 - n.dampingFactor, h.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (h.set(0, 0, 0), p.set(0, 0, 0));
        let os = !1;
        if (n.zoomToCursor && b) {
          let as = null;
          if (n.object instanceof St && n.object.isPerspectiveCamera) {
            const ls = X.length();
            as = de(ls * f);
            const Fs = ls - as;
            n.object.position.addScaledVector(M, Fs), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const ls = new Z(m.x, m.y, 0);
            ls.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / f)), n.object.updateProjectionMatrix(), os = !0;
            const Fs = new Z(m.x, m.y, 0);
            Fs.unproject(n.object), n.object.position.sub(Fs).add(ls), n.object.updateMatrixWorld(), as = X.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          as !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(as).add(n.object.position) : (Gs.origin.copy(n.object.position), Gs.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Gs.direction)) < gu ? e.lookAt(n.target) : (Qr.setFromNormalAndCoplanarPoint(n.object.up, n.target), Gs.intersectPlane(Qr, n.target))));
        } else
          n.object instanceof qt && n.object.isOrthographicCamera && (os = f !== 1, os && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / f)), n.object.updateProjectionMatrix()));
        return f = 1, b = !1, os || Je.distanceToSquared(n.object.position) > c || 8 * (1 - Gt.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), Je.copy(n.object.position), Gt.copy(n.object.quaternion), os = !1, !0) : !1;
      };
    })(), this.connect = (X) => {
      X === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), n.domElement = X, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", rs), n.domElement.addEventListener("pointerdown", fe), n.domElement.addEventListener("pointercancel", je), n.domElement.addEventListener("wheel", gt, { passive: !0 });
    }, this.dispose = () => {
      var X, ie, Te, Be, Je, Gt;
      n.domElement && (n.domElement.style.touchAction = "auto"), (X = n.domElement) == null || X.removeEventListener("contextmenu", rs), (ie = n.domElement) == null || ie.removeEventListener("pointerdown", fe), (Te = n.domElement) == null || Te.removeEventListener("pointercancel", je), (Be = n.domElement) == null || Be.removeEventListener("wheel", gt), (Je = n.domElement) == null || Je.ownerDocument.removeEventListener("pointermove", Me), (Gt = n.domElement) == null || Gt.ownerDocument.removeEventListener("pointerup", Xe), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", sn);
    };
    const n = this, s = { type: "change" }, i = { type: "start" }, r = { type: "end" }, a = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let l = a.NONE;
    const c = 1e-6, u = new ri(), h = new ri();
    let f = 1;
    const p = new Z(), y = new ge(), g = new ge(), v = new ge(), d = new ge(), w = new ge(), x = new ge(), T = new ge(), P = new ge(), S = new ge(), M = new Z(), m = new ge();
    let b = !1;
    const _ = [], I = {};
    function R() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function z() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function k(X) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? h.theta += X : h.theta -= X;
    }
    function G(X) {
      n.reverseOrbit || n.reverseVerticalOrbit ? h.phi += X : h.phi -= X;
    }
    const U = (() => {
      const X = new Z();
      return function(Te, Be) {
        X.setFromMatrixColumn(Be, 0), X.multiplyScalar(-Te), p.add(X);
      };
    })(), q = (() => {
      const X = new Z();
      return function(Te, Be) {
        n.screenSpacePanning === !0 ? X.setFromMatrixColumn(Be, 1) : (X.setFromMatrixColumn(Be, 0), X.crossVectors(n.object.up, X)), X.multiplyScalar(Te), p.add(X);
      };
    })(), $ = (() => {
      const X = new Z();
      return function(Te, Be) {
        const Je = n.domElement;
        if (Je && n.object instanceof St && n.object.isPerspectiveCamera) {
          const Gt = n.object.position;
          X.copy(Gt).sub(n.target);
          let rn = X.length();
          rn *= Math.tan(n.object.fov / 2 * Math.PI / 180), U(2 * Te * rn / Je.clientHeight, n.object.matrix), q(2 * Be * rn / Je.clientHeight, n.object.matrix);
        } else
          Je && n.object instanceof qt && n.object.isOrthographicCamera ? (U(
            Te * (n.object.right - n.object.left) / n.object.zoom / Je.clientWidth,
            n.object.matrix
          ), q(
            Be * (n.object.top - n.object.bottom) / n.object.zoom / Je.clientHeight,
            n.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function te(X) {
      n.object instanceof St && n.object.isPerspectiveCamera || n.object instanceof qt && n.object.isOrthographicCamera ? f /= X : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function ee(X) {
      n.object instanceof St && n.object.isPerspectiveCamera || n.object instanceof qt && n.object.isOrthographicCamera ? f *= X : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function oe(X) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      b = !0;
      const ie = n.domElement.getBoundingClientRect(), Te = X.clientX - ie.left, Be = X.clientY - ie.top, Je = ie.width, Gt = ie.height;
      m.x = Te / Je * 2 - 1, m.y = -(Be / Gt) * 2 + 1, M.set(m.x, m.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function de(X) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, X));
    }
    function xe(X) {
      y.set(X.clientX, X.clientY);
    }
    function C(X) {
      oe(X), T.set(X.clientX, X.clientY);
    }
    function B(X) {
      d.set(X.clientX, X.clientY);
    }
    function L(X) {
      g.set(X.clientX, X.clientY), v.subVectors(g, y).multiplyScalar(n.rotateSpeed);
      const ie = n.domElement;
      ie && (k(2 * Math.PI * v.x / ie.clientHeight), G(2 * Math.PI * v.y / ie.clientHeight)), y.copy(g), n.update();
    }
    function O(X) {
      P.set(X.clientX, X.clientY), S.subVectors(P, T), S.y > 0 ? te(z()) : S.y < 0 && ee(z()), T.copy(P), n.update();
    }
    function N(X) {
      w.set(X.clientX, X.clientY), x.subVectors(w, d).multiplyScalar(n.panSpeed), $(x.x, x.y), d.copy(w), n.update();
    }
    function E(X) {
      oe(X), X.deltaY < 0 ? ee(z()) : X.deltaY > 0 && te(z()), n.update();
    }
    function A(X) {
      let ie = !1;
      switch (X.code) {
        case n.keys.UP:
          $(0, n.keyPanSpeed), ie = !0;
          break;
        case n.keys.BOTTOM:
          $(0, -n.keyPanSpeed), ie = !0;
          break;
        case n.keys.LEFT:
          $(n.keyPanSpeed, 0), ie = !0;
          break;
        case n.keys.RIGHT:
          $(-n.keyPanSpeed, 0), ie = !0;
          break;
      }
      ie && (X.preventDefault(), n.update());
    }
    function D() {
      if (_.length == 1)
        y.set(_[0].pageX, _[0].pageY);
      else {
        const X = 0.5 * (_[0].pageX + _[1].pageX), ie = 0.5 * (_[0].pageY + _[1].pageY);
        y.set(X, ie);
      }
    }
    function W() {
      if (_.length == 1)
        d.set(_[0].pageX, _[0].pageY);
      else {
        const X = 0.5 * (_[0].pageX + _[1].pageX), ie = 0.5 * (_[0].pageY + _[1].pageY);
        d.set(X, ie);
      }
    }
    function Y() {
      const X = _[0].pageX - _[1].pageX, ie = _[0].pageY - _[1].pageY, Te = Math.sqrt(X * X + ie * ie);
      T.set(0, Te);
    }
    function j() {
      n.enableZoom && Y(), n.enablePan && W();
    }
    function J() {
      n.enableZoom && Y(), n.enableRotate && D();
    }
    function ne(X) {
      if (_.length == 1)
        g.set(X.pageX, X.pageY);
      else {
        const Te = gi(X), Be = 0.5 * (X.pageX + Te.x), Je = 0.5 * (X.pageY + Te.y);
        g.set(Be, Je);
      }
      v.subVectors(g, y).multiplyScalar(n.rotateSpeed);
      const ie = n.domElement;
      ie && (k(2 * Math.PI * v.x / ie.clientHeight), G(2 * Math.PI * v.y / ie.clientHeight)), y.copy(g);
    }
    function se(X) {
      if (_.length == 1)
        w.set(X.pageX, X.pageY);
      else {
        const ie = gi(X), Te = 0.5 * (X.pageX + ie.x), Be = 0.5 * (X.pageY + ie.y);
        w.set(Te, Be);
      }
      x.subVectors(w, d).multiplyScalar(n.panSpeed), $(x.x, x.y), d.copy(w);
    }
    function V(X) {
      const ie = gi(X), Te = X.pageX - ie.x, Be = X.pageY - ie.y, Je = Math.sqrt(Te * Te + Be * Be);
      P.set(0, Je), S.set(0, Math.pow(P.y / T.y, n.zoomSpeed)), te(S.y), T.copy(P);
    }
    function F(X) {
      n.enableZoom && V(X), n.enablePan && se(X);
    }
    function re(X) {
      n.enableZoom && V(X), n.enableRotate && ne(X);
    }
    function fe(X) {
      var ie, Te;
      n.enabled !== !1 && (_.length === 0 && ((ie = n.domElement) == null || ie.ownerDocument.addEventListener("pointermove", Me), (Te = n.domElement) == null || Te.ownerDocument.addEventListener("pointerup", Xe)), Ds(X), X.pointerType === "touch" ? is(X) : _t(X));
    }
    function Me(X) {
      n.enabled !== !1 && (X.pointerType === "touch" ? Un(X) : nn(X));
    }
    function Xe(X) {
      var ie, Te, Be;
      Os(X), _.length === 0 && ((ie = n.domElement) == null || ie.releasePointerCapture(X.pointerId), (Te = n.domElement) == null || Te.ownerDocument.removeEventListener("pointermove", Me), (Be = n.domElement) == null || Be.ownerDocument.removeEventListener("pointerup", Xe)), n.dispatchEvent(r), l = a.NONE;
    }
    function je(X) {
      Os(X);
    }
    function _t(X) {
      let ie;
      switch (X.button) {
        case 0:
          ie = n.mouseButtons.LEFT;
          break;
        case 1:
          ie = n.mouseButtons.MIDDLE;
          break;
        case 2:
          ie = n.mouseButtons.RIGHT;
          break;
        default:
          ie = -1;
      }
      switch (ie) {
        case pn.DOLLY:
          if (n.enableZoom === !1)
            return;
          C(X), l = a.DOLLY;
          break;
        case pn.ROTATE:
          if (X.ctrlKey || X.metaKey || X.shiftKey) {
            if (n.enablePan === !1)
              return;
            B(X), l = a.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            xe(X), l = a.ROTATE;
          }
          break;
        case pn.PAN:
          if (X.ctrlKey || X.metaKey || X.shiftKey) {
            if (n.enableRotate === !1)
              return;
            xe(X), l = a.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            B(X), l = a.PAN;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function nn(X) {
      if (n.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (n.enableRotate === !1)
              return;
            L(X);
            break;
          case a.DOLLY:
            if (n.enableZoom === !1)
              return;
            O(X);
            break;
          case a.PAN:
            if (n.enablePan === !1)
              return;
            N(X);
            break;
        }
    }
    function gt(X) {
      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (n.dispatchEvent(i), E(X), n.dispatchEvent(r));
    }
    function sn(X) {
      n.enabled === !1 || n.enablePan === !1 || A(X);
    }
    function is(X) {
      switch (Ls(X), _.length) {
        case 1:
          switch (n.touches.ONE) {
            case Nt.ROTATE:
              if (n.enableRotate === !1)
                return;
              D(), l = a.TOUCH_ROTATE;
              break;
            case Nt.PAN:
              if (n.enablePan === !1)
                return;
              W(), l = a.TOUCH_PAN;
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Nt.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              j(), l = a.TOUCH_DOLLY_PAN;
              break;
            case Nt.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              J(), l = a.TOUCH_DOLLY_ROTATE;
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function Un(X) {
      switch (Ls(X), l) {
        case a.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          ne(X), n.update();
          break;
        case a.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          se(X), n.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          F(X), n.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          re(X), n.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function rs(X) {
      n.enabled !== !1 && X.preventDefault();
    }
    function Ds(X) {
      _.push(X);
    }
    function Os(X) {
      delete I[X.pointerId];
      for (let ie = 0; ie < _.length; ie++)
        if (_[ie].pointerId == X.pointerId) {
          _.splice(ie, 1);
          return;
        }
    }
    function Ls(X) {
      let ie = I[X.pointerId];
      ie === void 0 && (ie = new ge(), I[X.pointerId] = ie), ie.set(X.pageX, X.pageY);
    }
    function gi(X) {
      const ie = X.pointerId === _[0].pointerId ? _[1] : _[0];
      return I[ie.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
}
class vu extends ka {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = pn.PAN, this.mouseButtons.RIGHT = pn.ROTATE, this.touches.ONE = Nt.PAN, this.touches.TWO = Nt.DOLLY_ROTATE;
  }
}
class yu extends Es {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new bu(t);
    }), this.register(function(t) {
      return new Ru(t);
    }), this.register(function(t) {
      return new Du(t);
    }), this.register(function(t) {
      return new Ou(t);
    }), this.register(function(t) {
      return new Su(t);
    }), this.register(function(t) {
      return new Mu(t);
    }), this.register(function(t) {
      return new Au(t);
    }), this.register(function(t) {
      return new Pu(t);
    }), this.register(function(t) {
      return new Tu(t);
    }), this.register(function(t) {
      return new Cu(t);
    }), this.register(function(t) {
      return new Eu(t);
    }), this.register(function(t) {
      return new Iu(t);
    }), this.register(function(t) {
      return new xu(t);
    }), this.register(function(t) {
      return new Lu(t);
    }), this.register(function(t) {
      return new Fu(t);
    });
  }
  load(e, t, n, s) {
    const i = this;
    let r;
    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = Ht.extractUrlBase(e), this.manager.itemStart(e);
    const a = function(c) {
      s ? s(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, l = new Fn(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(
      e,
      function(c) {
        try {
          i.parse(
            c,
            r,
            function(u) {
              t(u), i.manager.itemEnd(e);
            },
            a
          );
        } catch (u) {
          a(u);
        }
      },
      n,
      a
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, s) {
    let i;
    const r = {}, a = {};
    if (typeof e == "string")
      i = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Ht.decodeText(new Uint8Array(e.slice(0, 4))) === Ba) {
        try {
          r[De.KHR_BINARY_GLTF] = new ku(e);
        } catch (u) {
          s && s(u);
          return;
        }
        i = JSON.parse(r[De.KHR_BINARY_GLTF].content);
      } else
        i = JSON.parse(Ht.decodeText(new Uint8Array(e)));
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new Zu(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const u = this.pluginCallbacks[c](l);
      a[u.name] = u, r[u.name] = !0;
    }
    if (i.extensionsUsed)
      for (let c = 0; c < i.extensionsUsed.length; ++c) {
        const u = i.extensionsUsed[c], h = i.extensionsRequired || [];
        switch (u) {
          case De.KHR_MATERIALS_UNLIT:
            r[u] = new wu();
            break;
          case De.KHR_DRACO_MESH_COMPRESSION:
            r[u] = new Bu(i, this.dracoLoader);
            break;
          case De.KHR_TEXTURE_TRANSFORM:
            r[u] = new Uu();
            break;
          case De.KHR_MESH_QUANTIZATION:
            r[u] = new Nu();
            break;
          default:
            h.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(n, s);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, t, s, i);
    });
  }
}
function _u() {
  let o = {};
  return {
    get: function(e) {
      return o[e];
    },
    add: function(e, t) {
      o[e] = t;
    },
    remove: function(e) {
      delete o[e];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const De = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class xu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let s = t.cache.get(n);
    if (s)
      return s;
    const i = t.json, l = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new Re(16777215);
    l.color !== void 0 && u.fromArray(l.color);
    const h = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new ca(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new er(u), c.distance = h;
        break;
      case "spot":
        c = new la(u), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, mn(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, i = n.json.nodes[e], a = (i.extensions && i.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return n._getNodeRef(t.cache, a, l);
    });
  }
}
class wu {
  constructor() {
    this.name = De.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Zt;
  }
  extendParams(e, t, n) {
    const s = [];
    e.color = new Re(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const r = i.baseColorFactor;
        e.color.fromArray(r), e.opacity = r[3];
      }
      i.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", i.baseColorTexture, 3001));
    }
    return Promise.all(s);
  }
}
class Tu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}
class bu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (t.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (i.push(n.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const a = r.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ge(a, a);
    }
    return Promise.all(i);
  }
}
class Eu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (t.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && i.push(n.assignTexture(t, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (t.iridescenceIOR = r.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && i.push(
      n.assignTexture(t, "iridescenceThicknessMap", r.iridescenceThicknessTexture)
    ), Promise.all(i);
  }
}
class Su {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new Re(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const r = s.extensions[this.name];
    return r.sheenColorFactor !== void 0 && t.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && i.push(n.assignTexture(t, "sheenColorMap", r.sheenColorTexture, 3001)), r.sheenRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(i);
  }
}
class Mu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.transmissionFactor !== void 0 && (t.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && i.push(n.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(i);
  }
}
class Au {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    t.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && i.push(n.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
    const a = r.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Re(a[0], a[1], a[2]), Promise.all(i);
  }
}
class Pu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}
class Cu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    t.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && i.push(n.assignTexture(t, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Re(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && i.push(
      n.assignTexture(t, "specularColorMap", r.specularColorTexture, 3001)
      // sRGBEncoding
    ), Promise.all(i);
  }
}
class Iu {
  constructor(e) {
    this.parser = e, this.name = De.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : bn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.anisotropyStrength !== void 0 && (t.anisotropy = r.anisotropyStrength), r.anisotropyRotation !== void 0 && (t.anisotropyRotation = r.anisotropyRotation), r.anisotropyTexture !== void 0 && i.push(n.assignTexture(t, "anisotropyMap", r.anisotropyTexture)), Promise.all(i);
  }
}
class Ru {
  constructor(e) {
    this.parser = e, this.name = De.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const i = s.extensions[this.name], r = t.options.ktx2Loader;
    if (!r) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, r);
  }
}
class Du {
  constructor(e) {
    this.parser = e, this.name = De.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const r = i.extensions[t], a = s.images[r.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, r.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Ou {
  constructor(e) {
    this.parser = e, this.name = De.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const r = i.extensions[t], a = s.images[r.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, r.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Lu {
  constructor(e) {
    this.name = De.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const s = n.extensions[this.name], i = this.parser.getDependency("buffer", s.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(a) {
        const l = s.byteOffset || 0, c = s.byteLength || 0, u = s.count, h = s.byteStride, f = new Uint8Array(a, l, c);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(u, h, f, s.mode, s.filter).then(function(p) {
          return p.buffer;
        }) : r.ready.then(function() {
          const p = new ArrayBuffer(u * h);
          return r.decodeGltfBuffer(
            new Uint8Array(p),
            u,
            h,
            f,
            s.mode,
            s.filter
          ), p;
        });
      });
    } else
      return null;
  }
}
class Fu {
  constructor(e) {
    this.name = De.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const s = t.meshes[n.mesh];
    for (const c of s.primitives)
      if (c.mode !== Tt.TRIANGLES && c.mode !== Tt.TRIANGLE_STRIP && c.mode !== Tt.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const r = n.extensions[this.name].attributes, a = [], l = {};
    for (const c in r)
      a.push(
        this.parser.getDependency("accessor", r[c]).then((u) => (l[c] = u, l[c]))
      );
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
      const u = c.pop(), h = u.isGroup ? u.children : [u], f = c[0].count, p = [];
      for (const y of h) {
        const g = new Pe(), v = new Z(), d = new He(), w = new Z(1, 1, 1), x = new El(y.geometry, y.material, f);
        for (let T = 0; T < f; T++)
          l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, T), l.ROTATION && d.fromBufferAttribute(l.ROTATION, T), l.SCALE && w.fromBufferAttribute(l.SCALE, T), x.setMatrixAt(T, g.compose(v, d, w));
        for (const T in l)
          T !== "TRANSLATION" && T !== "ROTATION" && T !== "SCALE" && y.geometry.setAttribute(T, l[T]);
        Mt.prototype.copy.call(x, y), this.parser.assignFinalMaterial(x), p.push(x);
      }
      return u.isGroup ? (u.clear(), u.add(...p), u) : p[0];
    }));
  }
}
const Ba = "glTF", cs = 12, eo = { JSON: 1313821514, BIN: 5130562 };
class ku {
  constructor(e) {
    this.name = De.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, cs);
    if (this.header = {
      magic: Ht.decodeText(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Ba)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - cs, s = new DataView(e, cs);
    let i = 0;
    for (; i < n; ) {
      const r = s.getUint32(i, !0);
      i += 4;
      const a = s.getUint32(i, !0);
      if (i += 4, a === eo.JSON) {
        const l = new Uint8Array(e, cs + i, r);
        this.content = Ht.decodeText(l);
      } else if (a === eo.BIN) {
        const l = cs + i;
        this.body = e.slice(l, l + r);
      }
      i += r;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Bu {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = De.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, s = this.dracoLoader, i = e.extensions[this.name].bufferView, r = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const u in r) {
      const h = ur[u] || u.toLowerCase();
      a[h] = r[u];
    }
    for (const u in e.attributes) {
      const h = ur[u] || u.toLowerCase();
      if (r[u] !== void 0) {
        const f = n.accessors[e.attributes[u]], p = Qn[f.componentType];
        c[h] = p.name, l[h] = f.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(u) {
      return new Promise(function(h) {
        s.decodeDracoFile(
          u,
          function(f) {
            for (const p in f.attributes) {
              const y = f.attributes[p], g = l[p];
              g !== void 0 && (y.normalized = g);
            }
            h(f);
          },
          a,
          c
        );
      });
    });
  }
}
class Uu {
  constructor() {
    this.name = De.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class Nu {
  constructor() {
    this.name = De.KHR_MESH_QUANTIZATION;
  }
}
class Ua extends Cl {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, i = e * s * 3 + s;
    for (let r = 0; r !== s; r++)
      t[r] = n[i + r];
    return t;
  }
  interpolate_(e, t, n, s) {
    const i = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, u = s - t, h = (n - t) / u, f = h * h, p = f * h, y = e * c, g = y - c, v = -2 * p + 3 * f, d = p - f, w = 1 - v, x = d - f + h;
    for (let T = 0; T !== a; T++) {
      const P = r[g + T + a], S = r[g + T + l] * u, M = r[y + T + a], m = r[y + T] * u;
      i[T] = w * P + x * S + v * M + d * m;
    }
    return i;
  }
}
const zu = new He();
class Hu extends Ua {
  interpolate_(e, t, n, s) {
    const i = super.interpolate_(e, t, n, s);
    return zu.fromArray(i).normalize().toArray(i), i;
  }
}
const Tt = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Qn = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, to = {
  9728: ta,
  9729: Ot,
  9984: na,
  9985: ia,
  9986: sa,
  9987: _r
}, no = {
  33071: es,
  33648: ra,
  10497: Ln
}, Pi = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ur = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...Pa >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, ln = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, ju = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: yr,
  STEP: ea
}, Ci = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Gu(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new Ss({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Ms
  })), o.DefaultMaterial;
}
function Mn(o, e, t) {
  for (const n in t.extensions)
    o[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function mn(o, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function Vu(o, e, t) {
  let n = !1, s = !1, i = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (n = !0), h.NORMAL !== void 0 && (s = !0), h.COLOR_0 !== void 0 && (i = !0), n && s && i)
      break;
  }
  if (!n && !s && !i)
    return Promise.resolve(o);
  const r = [], a = [], l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (n) {
      const f = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : o.attributes.position;
      r.push(f);
    }
    if (s) {
      const f = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : o.attributes.normal;
      a.push(f);
    }
    if (i) {
      const f = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : o.attributes.color;
      l.push(f);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(c) {
    const u = c[0], h = c[1], f = c[2];
    return n && (o.morphAttributes.position = u), s && (o.morphAttributes.normal = h), i && (o.morphAttributes.color = f), o.morphTargetsRelative = !0, o;
  });
}
function Yu(o, e) {
  if (o.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      o.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (o.morphTargetInfluences.length === t.length) {
      o.morphTargetDictionary = {};
      for (let n = 0, s = t.length; n < s; n++)
        o.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Wu(o) {
  let e;
  const t = o.extensions && o.extensions[De.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Ii(t.attributes) : e = o.indices + ":" + Ii(o.attributes) + ":" + o.mode, o.targets !== void 0)
    for (let n = 0, s = o.targets.length; n < s; n++)
      e += ":" + Ii(o.targets[n]);
  return e;
}
function Ii(o) {
  let e = "";
  const t = Object.keys(o).sort();
  for (let n = 0, s = t.length; n < s; n++)
    e += t[n] + ":" + o[t[n]] + ";";
  return e;
}
function hr(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function Xu(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const $u = new Pe();
class Zu {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new _u(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, s = !1, i = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, i = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && i < 98 ? this.textureLoader = new xr(this.options.manager) : this.textureLoader = new Sl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Fn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, s = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(
      this._invokeAll(function(r) {
        return r.beforeRoot && r.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(r) {
      const a = {
        scene: r[0][s.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: s.asset,
        parser: n,
        userData: {}
      };
      Mn(i, a, s), mn(a, s), Promise.all(
        n._invokeAll(function(l) {
          return l.afterRoot && l.afterRoot(a);
        })
      ).then(function() {
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let s = 0, i = t.length; s < i; s++) {
      const r = t[s].joints;
      for (let a = 0, l = r.length; a < l; a++)
        e[r[a]].isBone = !0;
    }
    for (let s = 0, i = e.length; s < i; s++) {
      const r = e[s];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (n[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const s = n.clone(), i = (r, a) => {
      const l = this.associations.get(r);
      l != null && this.associations.set(a, l);
      for (const [c, u] of r.children.entries())
        i(u, a.children[c]);
    };
    return i(n, s), s.name += "_instance_" + e.uses[t]++, s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      if (s)
        return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let s = 0; s < t.length; s++) {
      const i = e(t[s]);
      i && n.push(i);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let s = this.cache.get(n);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (s = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !s)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, s);
    }
    return s;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        s.map(function(i, r) {
          return n.getDependency(e, r);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[De.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(i, r) {
      n.load(Ht.resolveURL(t.uri, s.path), i, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const s = t.byteLength || 0, i = t.byteOffset || 0;
      return n.slice(i, i + s);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const r = Pi[s.type], a = Qn[s.componentType], l = s.normalized === !0, c = new a(s.count * r);
      return Promise.resolve(new mt(c, r, l));
    }
    const i = [];
    return s.bufferView !== void 0 ? i.push(this.getDependency("bufferView", s.bufferView)) : i.push(null), s.sparse !== void 0 && (i.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(i).then(function(r) {
      const a = r[0], l = Pi[s.type], c = Qn[s.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, f = s.byteOffset || 0, p = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, y = s.normalized === !0;
      let g, v;
      if (p && p !== h) {
        const d = Math.floor(f / p), w = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + d + ":" + s.count;
        let x = t.cache.get(w);
        x || (g = new c(a, d * p, s.count * p / u), x = new wr(g, p / u), t.cache.add(w, x)), v = new Kt(
          x,
          l,
          f % p / u,
          y
        );
      } else
        a === null ? g = new c(s.count * l) : g = new c(a, f, s.count * l), v = new mt(g, l, y);
      if (s.sparse !== void 0) {
        const d = Pi.SCALAR, w = Qn[s.sparse.indices.componentType], x = s.sparse.indices.byteOffset || 0, T = s.sparse.values.byteOffset || 0, P = new w(
          r[1],
          x,
          s.sparse.count * d
        ), S = new c(r[2], T, s.sparse.count * l);
        a !== null && (v = new mt(
          v.array.slice(),
          v.itemSize,
          v.normalized
        ));
        for (let M = 0, m = P.length; M < m; M++) {
          const b = P[M];
          if (v.setX(b, S[M * l]), l >= 2 && v.setY(b, S[M * l + 1]), l >= 3 && v.setZ(b, S[M * l + 2]), l >= 4 && v.setW(b, S[M * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return v;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, i = t.textures[e].source, r = t.images[i];
    let a = this.textureLoader;
    if (r.uri) {
      const l = n.manager.getHandler(r.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, i, a);
  }
  loadTextureImage(e, t, n) {
    const s = this, i = this.json, r = i.textures[e], a = i.images[t], l = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(u) {
      u.flipY = !1, u.name = r.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
      const f = (i.samplers || {})[r.sampler] || {};
      return u.magFilter = to[f.magFilter] || Ot, u.minFilter = to[f.minFilter] || _r, u.wrapS = no[f.wrapS] || Ln, u.wrapT = no[f.wrapT] || Ln, s.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, s = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const r = s.images[e], a = self.URL || self.webkitURL;
    let l = r.uri || "", c = !1;
    if (r.bufferView !== void 0)
      l = n.getDependency("bufferView", r.bufferView).then(function(h) {
        c = !0;
        const f = new Blob([h], { type: r.mimeType });
        return l = a.createObjectURL(f), l;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(l).then(function(h) {
      return new Promise(function(f, p) {
        let y = f;
        t.isImageBitmapLoader === !0 && (y = function(g) {
          const v = new Jn(g);
          v.needsUpdate = !0, f(v);
        }), t.load(Ht.resolveURL(h, i.path), y, void 0, p);
      });
    }).then(function(h) {
      return c === !0 && a.revokeObjectURL(l), h.userData.mimeType = r.mimeType || Xu(r.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, s) {
    const i = this;
    return this.getDependency("texture", n.index).then(function(r) {
      if (!r)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (r = r.clone(), r.channel = n.texCoord), i.extensions[De.KHR_TEXTURE_TRANSFORM]) {
        const a = n.extensions !== void 0 ? n.extensions[De.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = i.associations.get(r);
          r = i.extensions[De.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), i.associations.set(r, l);
        }
      }
      return s !== void 0 && ("colorSpace" in r ? r.colorSpace = s === 3001 ? "srgb" : "srgb-linear" : r.encoding = s), e[t] = r, r;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const s = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, r = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new Ml(), yi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new ts(), yi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
    }
    if (s || i || r) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      s && (a += "derivative-tangents:"), i && (a += "vertex-colors:"), r && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = n.clone(), i && (l.vertexColors = !0), r && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return Ss;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, s = this.extensions, i = n.materials[e];
    let r;
    const a = {}, l = i.extensions || {}, c = [];
    if (l[De.KHR_MATERIALS_UNLIT]) {
      const h = s[De.KHR_MATERIALS_UNLIT];
      r = h.getMaterialType(), c.push(h.extendParams(a, i, t));
    } else {
      const h = i.pbrMetallicRoughness || {};
      if (a.color = new Re(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const f = h.baseColorFactor;
        a.color.fromArray(f), a.opacity = f[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, 3001)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), r = this._invokeOne(function(f) {
        return f.getMaterialType && f.getMaterialType(e);
      }), c.push(
        Promise.all(
          this._invokeAll(function(f) {
            return f.extendMaterialParams && f.extendMaterialParams(e, a);
          })
        )
      );
    }
    i.doubleSided === !0 && (a.side = wn);
    const u = i.alphaMode || Ci.OPAQUE;
    if (u === Ci.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === Ci.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && r !== Zt && (c.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new ge(1, 1), i.normalTexture.scale !== void 0)) {
      const h = i.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    return i.occlusionTexture !== void 0 && r !== Zt && (c.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && r !== Zt && (a.emissive = new Re().fromArray(i.emissiveFactor)), i.emissiveTexture !== void 0 && r !== Zt && c.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(c).then(function() {
      const h = new r(a);
      return i.name && (h.name = i.name), mn(h, i), t.associations.set(h, { materials: e }), i.extensions && Mn(s, h, i), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Jt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, s = this.primitiveCache;
    function i(a) {
      return n[De.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return so(l, a, t);
      });
    }
    const r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], u = Wu(c), h = s[u];
      if (h)
        r.push(h.promise);
      else {
        let f;
        c.extensions && c.extensions[De.KHR_DRACO_MESH_COMPRESSION] ? f = i(c) : f = so(new at(), c, t), s[u] = { primitive: c, promise: f }, r.push(f);
      }
    }
    return Promise.all(r);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, s = this.extensions, i = n.meshes[e], r = i.primitives, a = [];
    for (let l = 0, c = r.length; l < c; l++) {
      const u = r[l].material === void 0 ? Gu(this.cache) : this.getDependency("material", r[l].material);
      a.push(u);
    }
    return a.push(t.loadGeometries(r)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
      for (let p = 0, y = u.length; p < y; p++) {
        const g = u[p], v = r[p];
        let d;
        const w = c[p];
        if (v.mode === Tt.TRIANGLES || v.mode === Tt.TRIANGLE_STRIP || v.mode === Tt.TRIANGLE_FAN || v.mode === void 0)
          d = i.isSkinnedMesh === !0 ? new ua(g, w) : new le(g, w), d.isSkinnedMesh === !0 && d.normalizeSkinWeights(), v.mode === Tt.TRIANGLE_STRIP ? d.geometry = Gr(d.geometry, Qo) : v.mode === Tt.TRIANGLE_FAN && (d.geometry = Gr(d.geometry, Ji));
        else if (v.mode === Tt.LINES)
          d = new Al(g, w);
        else if (v.mode === Tt.LINE_STRIP)
          d = new Ie(g, w);
        else if (v.mode === Tt.LINE_LOOP)
          d = new Pl(g, w);
        else if (v.mode === Tt.POINTS)
          d = new ha(g, w);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
        Object.keys(d.geometry.morphAttributes).length > 0 && Yu(d, i), d.name = t.createUniqueName(i.name || "mesh_" + e), mn(d, i), v.extensions && Mn(s, d, v), t.assignFinalMaterial(d), h.push(d);
      }
      for (let p = 0, y = h.length; p < y; p++)
        t.associations.set(h[p], {
          meshes: e,
          primitives: p
        });
      if (h.length === 1)
        return i.extensions && Mn(s, h[0], i), h[0];
      const f = new Dn();
      i.extensions && Mn(s, f, i), t.associations.set(f, { meshes: e });
      for (let p = 0, y = h.length; p < y; p++)
        f.add(h[p]);
      return f;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], s = n[n.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new St(
      Ze.radToDeg(s.yfov),
      s.aspectRatio || 1,
      s.znear || 1,
      s.zfar || 2e6
    ) : n.type === "orthographic" && (t = new qt(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), mn(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let s = 0, i = t.joints.length; s < i; s++)
      n.push(this._loadNodeShallow(t.joints[s]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
      const i = s.pop(), r = s, a = [], l = [];
      for (let c = 0, u = r.length; c < u; c++) {
        const h = r[c];
        if (h) {
          a.push(h);
          const f = new Pe();
          i !== null && f.fromArray(i.array, c * 16), l.push(f);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new fa(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const n = this.json.animations[e], s = n.name ? n.name : "animation_" + e, i = [], r = [], a = [], l = [], c = [];
    for (let u = 0, h = n.channels.length; u < h; u++) {
      const f = n.channels[u], p = n.samplers[f.sampler], y = f.target, g = y.node, v = n.parameters !== void 0 ? n.parameters[p.input] : p.input, d = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      y.node !== void 0 && (i.push(this.getDependency("node", g)), r.push(this.getDependency("accessor", v)), a.push(this.getDependency("accessor", d)), l.push(p), c.push(y));
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(r),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c)
    ]).then(function(u) {
      const h = u[0], f = u[1], p = u[2], y = u[3], g = u[4], v = [];
      for (let d = 0, w = h.length; d < w; d++) {
        const x = h[d], T = f[d], P = p[d], S = y[d], M = g[d];
        if (x === void 0)
          continue;
        x.updateMatrix();
        let m;
        switch (ln[M.path]) {
          case ln.weights:
            m = ma;
            break;
          case ln.rotation:
            m = nr;
            break;
          case ln.position:
          case ln.scale:
          default:
            m = pa;
            break;
        }
        const b = x.name ? x.name : x.uuid, _ = S.interpolation !== void 0 ? ju[S.interpolation] : yr, I = [];
        ln[M.path] === ln.weights ? x.traverse(function(z) {
          z.morphTargetInfluences && I.push(z.name ? z.name : z.uuid);
        }) : I.push(b);
        let R = P.array;
        if (P.normalized) {
          const z = hr(R.constructor), k = new Float32Array(R.length);
          for (let G = 0, U = R.length; G < U; G++)
            k[G] = R[G] * z;
          R = k;
        }
        for (let z = 0, k = I.length; z < k; z++) {
          const G = new m(
            I[z] + "." + ln[M.path],
            T.array,
            R,
            _
          );
          S.interpolation === "CUBICSPLINE" && (G.createInterpolant = function(q) {
            const $ = this instanceof nr ? Hu : Ua;
            return new $(this.times, this.values, this.getValueSize() / 3, q);
          }, G.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), v.push(G);
        }
      }
      return new da(s, void 0, v);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, s = t.nodes[e];
    return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(i) {
      const r = n._getNodeRef(n.meshCache, s.mesh, i);
      return s.weights !== void 0 && r.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = s.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = s.weights[l];
      }), r;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, s = t.nodes[e], i = n._loadNodeShallow(e), r = [], a = s.children || [];
    for (let c = 0, u = a.length; c < u; c++)
      r.push(n.getDependency("node", a[c]));
    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
    return Promise.all([i, Promise.all(r), l]).then(function(c) {
      const u = c[0], h = c[1], f = c[2];
      f !== null && u.traverse(function(p) {
        p.isSkinnedMesh && p.bind(f, $u);
      });
      for (let p = 0, y = h.length; p < y; p++)
        u.add(h[p]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, s = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], r = i.name ? s.createUniqueName(i.name) : "", a = [], l = s._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && a.push(l), i.camera !== void 0 && a.push(
      s.getDependency("camera", i.camera).then(function(c) {
        return s._getNodeRef(s.cameraCache, i.camera, c);
      })
    ), s._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[e] = Promise.all(a).then(function(c) {
      let u;
      if (i.isBone === !0 ? u = new tr() : c.length > 1 ? u = new Dn() : c.length === 1 ? u = c[0] : u = new Mt(), u !== c[0])
        for (let h = 0, f = c.length; h < f; h++)
          u.add(c[h]);
      if (i.name && (u.userData.name = i.name, u.name = r), mn(u, i), i.extensions && Mn(n, u, i), i.matrix !== void 0) {
        const h = new Pe();
        h.fromArray(i.matrix), u.applyMatrix4(h);
      } else
        i.translation !== void 0 && u.position.fromArray(i.translation), i.rotation !== void 0 && u.quaternion.fromArray(i.rotation), i.scale !== void 0 && u.scale.fromArray(i.scale);
      return s.associations.has(u) || s.associations.set(u, {}), s.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], s = this, i = new Dn();
    n.name && (i.name = s.createUniqueName(n.name)), mn(i, n), n.extensions && Mn(t, i, n);
    const r = n.nodes || [], a = [];
    for (let l = 0, c = r.length; l < c; l++)
      a.push(s.getDependency("node", r[l]));
    return Promise.all(a).then(function(l) {
      for (let u = 0, h = l.length; u < h; u++)
        i.add(l[u]);
      const c = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [f, p] of s.associations)
          (f instanceof yi || f instanceof Jn) && h.set(f, p);
        return u.traverse((f) => {
          const p = s.associations.get(f);
          p != null && h.set(f, p);
        }), h;
      };
      return s.associations = c(i), i;
    });
  }
}
function qu(o, e, t) {
  const n = e.attributes, s = new bt();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (s.set(new Z(l[0], l[1], l[2]), new Z(c[0], c[1], c[2])), a.normalized) {
        const u = hr(Qn[a.componentType]);
        s.min.multiplyScalar(u), s.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const a = new Z(), l = new Z();
    for (let c = 0, u = i.length; c < u; c++) {
      const h = i[c];
      if (h.POSITION !== void 0) {
        const f = t.json.accessors[h.POSITION], p = f.min, y = f.max;
        if (p !== void 0 && y !== void 0) {
          if (l.setX(Math.max(Math.abs(p[0]), Math.abs(y[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(y[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(y[2]))), f.normalized) {
            const g = hr(Qn[f.componentType]);
            l.multiplyScalar(g);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(a);
  }
  o.boundingBox = s;
  const r = new fi();
  s.getCenter(r.center), r.radius = s.min.distanceTo(s.max) / 2, o.boundingSphere = r;
}
function so(o, e, t) {
  const n = e.attributes, s = [];
  function i(r, a) {
    return t.getDependency("accessor", r).then(function(l) {
      o.setAttribute(a, l);
    });
  }
  for (const r in n) {
    const a = ur[r] || r.toLowerCase();
    a in o.attributes || s.push(i(n[r], a));
  }
  if (e.indices !== void 0 && !o.index) {
    const r = t.getDependency("accessor", e.indices).then(function(a) {
      o.setIndex(a);
    });
    s.push(r);
  }
  return mn(o, e), qu(o, e, t), Promise.all(s).then(function() {
    return e.targets !== void 0 ? Vu(o, e.targets, t) : o;
  });
}
const us = new Z();
function xt(o, e, t, n, s, i) {
  const r = 2 * Math.PI * s / 4, a = Math.max(i - 2 * s, 0), l = Math.PI / 4;
  us.copy(e), us[n] = 0, us.normalize();
  const c = 0.5 * r / (r + a), u = 1 - us.angleTo(o) / l;
  return Math.sign(us[t]) === 1 ? u * c : a / (r + a) + c + c * (1 - u);
}
class Ku extends $t {
  constructor(e = 1, t = 1, n = 1, s = 2, i = 0.1) {
    if (s = s * 2 + 1, i = Math.min(e / 2, t / 2, n / 2, i), super(1, 1, 1, s, s, s), s === 1)
      return;
    const r = this.toNonIndexed();
    this.index = null, this.attributes.position = r.attributes.position, this.attributes.normal = r.attributes.normal, this.attributes.uv = r.attributes.uv;
    const a = new Z(), l = new Z(), c = new Z(e, t, n).divideScalar(2).subScalar(i), u = this.attributes.position.array, h = this.attributes.normal.array, f = this.attributes.uv.array, p = u.length / 6, y = new Z(), g = 0.5 / s;
    for (let v = 0, d = 0; v < u.length; v += 3, d += 2)
      switch (a.fromArray(u, v), l.copy(a), l.x -= Math.sign(l.x) * g, l.y -= Math.sign(l.y) * g, l.z -= Math.sign(l.z) * g, l.normalize(), u[v + 0] = c.x * Math.sign(a.x) + l.x * i, u[v + 1] = c.y * Math.sign(a.y) + l.y * i, u[v + 2] = c.z * Math.sign(a.z) + l.z * i, h[v + 0] = l.x, h[v + 1] = l.y, h[v + 2] = l.z, Math.floor(v / p)) {
        case 0:
          y.set(1, 0, 0), f[d + 0] = xt(y, l, "z", "y", i, n), f[d + 1] = 1 - xt(y, l, "y", "z", i, t);
          break;
        case 1:
          y.set(-1, 0, 0), f[d + 0] = 1 - xt(y, l, "z", "y", i, n), f[d + 1] = 1 - xt(y, l, "y", "z", i, t);
          break;
        case 2:
          y.set(0, 1, 0), f[d + 0] = 1 - xt(y, l, "x", "z", i, e), f[d + 1] = xt(y, l, "z", "x", i, n);
          break;
        case 3:
          y.set(0, -1, 0), f[d + 0] = 1 - xt(y, l, "x", "z", i, e), f[d + 1] = 1 - xt(y, l, "z", "x", i, n);
          break;
        case 4:
          y.set(0, 0, 1), f[d + 0] = 1 - xt(y, l, "x", "y", i, e), f[d + 1] = 1 - xt(y, l, "y", "x", i, t);
          break;
        case 5:
          y.set(0, 0, -1), f[d + 0] = xt(y, l, "x", "y", i, e), f[d + 1] = 1 - xt(y, l, "y", "x", i, t);
          break;
      }
  }
}
class io extends Il {
  constructor(e, t = {}) {
    const {
      bevelEnabled: n = !1,
      bevelSize: s = 8,
      bevelThickness: i = 10,
      font: r,
      height: a = 50,
      size: l = 100,
      lineHeight: c = 1,
      letterSpacing: u = 0,
      ...h
    } = t;
    if (r === void 0)
      super();
    else {
      const f = r.generateShapes(e, l, { lineHeight: c, letterSpacing: u });
      super(f, { ...h, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });
    }
    this.type = "TextGeometry";
  }
}
const Qu = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
}, Ju = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
function Na(o, e, t) {
  const n = t.length - o - 1;
  if (e >= t[n])
    return n - 1;
  if (e <= t[o])
    return o;
  let s = o, i = n, r = Math.floor((s + i) / 2);
  for (; e < t[r] || e >= t[r + 1]; )
    e < t[r] ? i = r : s = r, r = Math.floor((s + i) / 2);
  return r;
}
function eh(o, e, t, n) {
  const s = [], i = [], r = [];
  s[0] = 1;
  for (let a = 1; a <= t; ++a) {
    i[a] = e - n[o + 1 - a], r[a] = n[o + a] - e;
    let l = 0;
    for (let c = 0; c < a; ++c) {
      const u = r[c + 1], h = i[a - c], f = s[c] / (u + h);
      s[c] = l + u * f, l = h * f;
    }
    s[a] = l;
  }
  return s;
}
function th(o, e, t, n) {
  const s = Na(o, n, e), i = eh(s, n, o, e), r = new lt(0, 0, 0, 0);
  for (let a = 0; a <= o; ++a) {
    const l = t[s - o + a], c = i[a], u = l.w * c;
    r.x += l.x * u, r.y += l.y * u, r.z += l.z * u, r.w += l.w * c;
  }
  return r;
}
function nh(o, e, t, n, s) {
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = 0;
  const r = [];
  for (let h = 0; h <= n; ++h)
    r[h] = i.slice(0);
  const a = [];
  for (let h = 0; h <= t; ++h)
    a[h] = i.slice(0);
  a[0][0] = 1;
  const l = i.slice(0), c = i.slice(0);
  for (let h = 1; h <= t; ++h) {
    l[h] = e - s[o + 1 - h], c[h] = s[o + h] - e;
    let f = 0;
    for (let p = 0; p < h; ++p) {
      const y = c[p + 1], g = l[h - p];
      a[h][p] = y + g;
      const v = a[p][h - 1] / a[h][p];
      a[p][h] = f + y * v, f = g * v;
    }
    a[h][h] = f;
  }
  for (let h = 0; h <= t; ++h)
    r[0][h] = a[h][t];
  for (let h = 0; h <= t; ++h) {
    let f = 0, p = 1;
    const y = [];
    for (let g = 0; g <= t; ++g)
      y[g] = i.slice(0);
    y[0][0] = 1;
    for (let g = 1; g <= n; ++g) {
      let v = 0;
      const d = h - g, w = t - g;
      h >= g && (y[p][0] = y[f][0] / a[w + 1][d], v = y[p][0] * a[d][w]);
      const x = d >= -1 ? 1 : -d, T = h - 1 <= w ? g - 1 : t - h;
      for (let S = x; S <= T; ++S)
        y[p][S] = (y[f][S] - y[f][S - 1]) / a[w + 1][d + S], v += y[p][S] * a[d + S][w];
      h <= w && (y[p][g] = -y[f][g - 1] / a[w + 1][h], v += y[p][g] * a[h][w]), r[g][h] = v;
      const P = f;
      f = p, p = P;
    }
  }
  let u = t;
  for (let h = 1; h <= n; ++h) {
    for (let f = 0; f <= t; ++f)
      r[h][f] *= u;
    u *= t - h;
  }
  return r;
}
function sh(o, e, t, n, s) {
  const i = s < o ? s : o, r = [], a = Na(o, n, e), l = nh(a, n, o, i, e), c = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), f = h.w;
    h.x *= f, h.y *= f, h.z *= f, c[u] = h;
  }
  for (let u = 0; u <= i; ++u) {
    const h = c[a - o].clone().multiplyScalar(l[u][0]);
    for (let f = 1; f <= o; ++f)
      h.add(c[a - o + f].clone().multiplyScalar(l[u][f]));
    r[u] = h;
  }
  for (let u = i + 1; u <= s + 1; ++u)
    r[u] = new lt(0, 0, 0);
  return r;
}
function ih(o, e) {
  let t = 1;
  for (let s = 2; s <= o; ++s)
    t *= s;
  let n = 1;
  for (let s = 2; s <= e; ++s)
    n *= s;
  for (let s = 2; s <= o - e; ++s)
    n *= s;
  return t / n;
}
function rh(o) {
  const e = o.length, t = [], n = [];
  for (let i = 0; i < e; ++i) {
    const r = o[i];
    t[i] = new Z(r.x, r.y, r.z), n[i] = r.w;
  }
  const s = [];
  for (let i = 0; i < e; ++i) {
    const r = t[i].clone();
    for (let a = 1; a <= i; ++a)
      r.sub(s[i - a].clone().multiplyScalar(ih(i, a) * n[a]));
    s[i] = r.divideScalar(n[0]);
  }
  return s;
}
function oh(o, e, t, n, s) {
  const i = sh(o, e, t, n, s);
  return rh(i);
}
class ro extends Rl {
  constructor(e, t, n, s, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = i || this.knots.length - 1;
    for (let r = 0; r < n.length; ++r) {
      const a = n[r];
      this.controlPoints[r] = new lt(a.x, a.y, a.z, a.w);
    }
  }
  getPoint(e, t) {
    const n = t || new Z(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = th(this.degree, this.knots, this.controlPoints, s);
    return i.w != 1 && i.divideScalar(i.w), n.set(i.x, i.y, i.z);
  }
  getTangent(e, t) {
    const n = t || new Z(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = oh(this.degree, this.knots, this.controlPoints, s, 1);
    return n.copy(i[1]).normalize(), n;
  }
}
let Ae, Ke, pt;
class ah extends Es {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = this, r = i.path === "" ? Ht.extractUrlBase(e) : i.path, a = new Fn(this.manager);
    a.setPath(i.path), a.setResponseType("arraybuffer"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(
      e,
      function(l) {
        try {
          t(i.parse(l, r));
        } catch (c) {
          s ? s(c) : console.error(c), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e, t) {
    if (dh(e))
      Ae = new fh().parse(e);
    else {
      const s = Ga(e);
      if (!ph(s))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (ao(s) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + ao(s));
      Ae = new hh().parse(s);
    }
    const n = new xr(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new lh(n, this.manager).parse(Ae);
  }
}
class lh {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Ke = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new ch().parse(s);
    return this.parseScene(s, i, n), pt;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ae && Ae.Connections.connections.forEach(function(n) {
      const s = n[0], i = n[1], r = n[2];
      e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: i, relationship: r };
      e.get(s).parents.push(a), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const l = { ID: s, relationship: r };
      e.get(i).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ae.Objects) {
      const n = Ae.Objects.Video;
      for (const s in n) {
        const i = n[s], r = parseInt(s);
        if (e[r] = i.RelativeFilename || i.Filename, "Content" in i) {
          const a = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, l = typeof i.Content == "string" && i.Content !== "";
          if (a || l) {
            const c = this.parseImage(n[s]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const n in e) {
      const s = e[n];
      t[s] !== void 0 ? e[n] = t[s] : e[n] = e[n].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, n = e.RelativeFilename || e.Filename, s = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (s) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + s + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const r = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([r], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ae.Objects) {
      const n = Ae.Objects.Texture;
      for (const s in n) {
        const i = this.parseTexture(n[s], e);
        t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    n.ID = e.id, n.name = e.attrName;
    const s = e.WrapModeU, i = e.WrapModeV, r = s !== void 0 ? s.value : 0, a = i !== void 0 ? i.value : 0;
    if (n.wrapS = r === 0 ? Ln : es, n.wrapT = a === 0 ? Ln : es, "Scaling" in e) {
      const l = e.Scaling.value;
      n.repeat.x = l[0], n.repeat.y = l[1];
    }
    return n;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let n;
    const s = this.textureLoader.path, i = Ke.get(e.id).children;
    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (n = t[i[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let r;
    const a = e.FileName.slice(-3).toLowerCase();
    if (a === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), r = new Jn()) : (l.setPath(this.textureLoader.path), r = l.load(n));
    } else
      a === "psd" ? (console.warn(
        "FBXLoader: PSD textures are not supported, creating placeholder texture for",
        e.RelativeFilename
      ), r = new Jn()) : r = this.textureLoader.load(n);
    return this.textureLoader.setPath(s), r;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ae.Objects) {
      const n = Ae.Objects.Material;
      for (const s in n) {
        const i = this.parseMaterial(n[s], e);
        i !== null && t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const n = e.id, s = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !Ke.has(n))
      return null;
    const r = this.parseParameters(e, t, n);
    let a;
    switch (i.toLowerCase()) {
      case "phong":
        a = new _i();
        break;
      case "lambert":
        a = new Dl();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new _i();
        break;
    }
    return a.setValues(r), a.name = s, a;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, n) {
    const s = {};
    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new Re().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new Re().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new Re().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new Re().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new Re().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new Re().fromArray(e.SpecularColor.value));
    const i = this;
    return Ke.get(n).children.forEach(function(r) {
      const a = r.relationship;
      switch (a) {
        case "Bump":
          s.bumpMap = i.getTexture(t, r.ID);
          break;
        case "Maya|TEX_ao_map":
          s.aoMap = i.getTexture(t, r.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          s.map = i.getTexture(t, r.ID), s.map !== void 0 && ("colorSpace" in s.map ? s.map.colorSpace = "srgb" : s.map.encoding = 3001);
          break;
        case "DisplacementColor":
          s.displacementMap = i.getTexture(t, r.ID);
          break;
        case "EmissiveColor":
          s.emissiveMap = i.getTexture(t, r.ID), s.emissiveMap !== void 0 && ("colorSpace" in s.emissiveMap ? s.emissiveMap.colorSpace = "srgb" : s.emissiveMap.encoding = 3001);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          s.normalMap = i.getTexture(t, r.ID);
          break;
        case "ReflectionColor":
          s.envMap = i.getTexture(t, r.ID), s.envMap !== void 0 && (s.envMap.mapping = sr, "colorSpace" in s.envMap ? s.envMap.colorSpace = "srgb" : s.envMap.encoding = 3001);
          break;
        case "SpecularColor":
          s.specularMap = i.getTexture(t, r.ID), s.specularMap !== void 0 && ("colorSpace" in s.specularMap ? s.specularMap.colorSpace = "srgb" : s.specularMap.encoding = 3001);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          s.alphaMap = i.getTexture(t, r.ID), s.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
          break;
      }
    }), s;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ae.Objects && t in Ae.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Ke.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ae.Objects) {
      const n = Ae.Objects.Deformer;
      for (const s in n) {
        const i = n[s], r = Ke.get(parseInt(s));
        if (i.attrType === "Skin") {
          const a = this.parseSkeleton(r, n);
          a.ID = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = r.parents[0].ID, e[s] = a;
        } else if (i.attrType === "BlendShape") {
          const a = {
            id: s
          };
          a.rawTargets = this.parseMorphTargets(r, n), a.id = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[s] = a;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const n = [];
    return e.children.forEach(function(s) {
      const i = t[s.ID];
      if (i.attrType !== "Cluster")
        return;
      const r = {
        ID: s.ID,
        indices: [],
        weights: [],
        transformLink: new Pe().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (r.indices = i.Indexes.a, r.weights = i.Weights.a), n.push(r);
    }), {
      rawBones: n,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const n = [];
    for (let s = 0; s < e.children.length; s++) {
      const i = e.children[s], r = t[i.ID], a = {
        name: r.attrName,
        initialWeight: r.DeformPercent,
        id: r.id,
        fullWeights: r.FullWeights.a
      };
      if (r.attrType !== "BlendShapeChannel")
        return;
      a.geoID = Ke.get(parseInt(i.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, n.push(a);
    }
    return n;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, n) {
    pt = new Dn();
    const s = this.parseModels(e.skeletons, t, n), i = Ae.Objects.Model, r = this;
    s.forEach(function(l) {
      const c = i[l.ID];
      r.setLookAtProperties(l, c), Ke.get(l.ID).parents.forEach(function(h) {
        const f = s.get(h.ID);
        f !== void 0 && f.add(l);
      }), l.parent === null && pt.add(l);
    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), pt.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = Ha(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const a = new uh().parse();
    pt.children.length === 1 && pt.children[0].isGroup && (pt.children[0].animations = a, pt = pt.children[0]), pt.animations = a;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, n) {
    const s = /* @__PURE__ */ new Map(), i = Ae.Objects.Model;
    for (const r in i) {
      const a = parseInt(r), l = i[r], c = Ke.get(a);
      let u = this.buildSkeleton(c, e, a, l.attrName);
      if (!u) {
        switch (l.attrType) {
          case "Camera":
            u = this.createCamera(c);
            break;
          case "Light":
            u = this.createLight(c);
            break;
          case "Mesh":
            u = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            u = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            u = new tr();
            break;
          case "Null":
          default:
            u = new Dn();
            break;
        }
        u.name = l.attrName ? Jt.sanitizeNodeName(l.attrName) : "", u.ID = a;
      }
      this.getTransformData(u, l), s.set(a, u);
    }
    return s;
  }
  buildSkeleton(e, t, n, s) {
    let i = null;
    return e.parents.forEach(function(r) {
      for (const a in t) {
        const l = t[a];
        l.rawBones.forEach(function(c, u) {
          if (c.ID === r.ID) {
            const h = i;
            i = new tr(), i.matrixWorld.copy(c.transformLink), i.name = s ? Jt.sanitizeNodeName(s) : "", i.ID = n, l.bones[u] = i, h !== null && i.add(h);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ae.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new Mt();
    else {
      let s = 0;
      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);
      let i = 1;
      n.NearPlane !== void 0 && (i = n.NearPlane.value / 1e3);
      let r = 1e3;
      n.FarPlane !== void 0 && (r = n.FarPlane.value / 1e3);
      let a = window.innerWidth, l = window.innerHeight;
      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, l = n.AspectHeight.value);
      const c = a / l;
      let u = 45;
      n.FieldOfView !== void 0 && (u = n.FieldOfView.value);
      const h = n.FocalLength ? n.FocalLength.value : null;
      switch (s) {
        case 0:
          t = new St(u, c, i, r), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new qt(
            -a / 2,
            a / 2,
            l / 2,
            -l / 2,
            i,
            r
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new Mt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ae.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new Mt();
    else {
      let s;
      n.LightType === void 0 ? s = 0 : s = n.LightType.value;
      let i = 16777215;
      n.Color !== void 0 && (i = new Re().fromArray(n.Color.value));
      let r = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (r = 0);
      let a = 0;
      n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
      const l = 1;
      switch (s) {
        case 0:
          t = new er(i, r, a, l);
          break;
        case 1:
          t = new ca(i, r);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = Ze.degToRad(n.InnerAngle.value));
          let u = 0;
          n.OuterAngle !== void 0 && (u = Ze.degToRad(n.OuterAngle.value), u = Math.max(u, 1)), t = new la(i, r, a, c, u, l);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."
          ), t = new er(i, r);
          break;
      }
      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let s, i = null, r = null;
    const a = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (i = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));
    }), a.length > 1 ? r = a : a.length > 0 ? r = a[0] : (r = new _i({ color: 13421772 }), a.push(r)), "color" in i.attributes && a.forEach(function(l) {
      l.vertexColors = !0;
    }), i.FBX_Deformer ? (s = new ua(i, r), s.normalizeSkinWeights()) : s = new le(i, r), s;
  }
  createCurve(e, t) {
    const n = e.children.reduce(function(i, r) {
      return t.has(r.ID) && (i = t.get(r.ID)), i;
    }, null), s = new ts({ color: 3342591, linewidth: 1 });
    return new Ie(n, s);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = ja(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Ke.get(e.ID).children.forEach(function(s) {
      if (s.relationship === "LookAtProperty") {
        const i = Ae.Objects.Model[s.ID];
        if ("Lcl_Translation" in i) {
          const r = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(r), pt.add(e.target)) : e.lookAt(new Z().fromArray(r));
        }
      }
    });
  }
  bindSkeleton(e, t, n) {
    const s = this.parsePoseNodes();
    for (const i in e) {
      const r = e[i];
      Ke.get(parseInt(r.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          Ke.get(c).parents.forEach(function(h) {
            n.has(h.ID) && n.get(h.ID).bind(new fa(r.bones), s[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ae.Objects) {
      const t = Ae.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const s = t[n].PoseNode;
          Array.isArray(s) ? s.forEach(function(i) {
            e[i.Node] = new Pe().fromArray(i.Matrix.a);
          }) : e[s.Node] = new Pe().fromArray(s.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ae && "AmbientColor" in Ae.GlobalSettings) {
      const e = Ae.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];
      if (t !== 0 || n !== 0 || s !== 0) {
        const i = new Re(t, n, s);
        pt.add(new Ol(i, 1));
      }
    }
  }
}
class ch {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ae.Objects) {
      const n = Ae.Objects.Geometry;
      for (const s in n) {
        const i = Ke.get(parseInt(s)), r = this.parseGeometry(i, n[s], e);
        t.set(parseInt(s), r);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, n) {
    const s = n.skeletons, i = [], r = e.parents.map(function(h) {
      return Ae.Objects.Model[h.ID];
    });
    if (r.length === 0)
      return;
    const a = e.children.reduce(function(h, f) {
      return s[f.ID] !== void 0 && (h = s[f.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      n.morphTargets[h.ID] !== void 0 && i.push(n.morphTargets[h.ID]);
    });
    const l = r[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = ja(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const u = Ha(c);
    return this.genGeometry(t, a, i, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, n, s) {
    const i = new at();
    e.attrName && (i.name = e.attrName);
    const r = this.parseGeoNode(e, t), a = this.genBuffers(r), l = new rt(a.vertex, 3);
    if (l.applyMatrix4(s), i.setAttribute("position", l), a.colors.length > 0 && i.setAttribute("color", new rt(a.colors, 3)), t && (i.setAttribute("skinIndex", new Ll(a.weightsIndices, 4)), i.setAttribute("skinWeight", new rt(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {
      const c = new In().getNormalMatrix(s), u = new rt(a.normal, 3);
      u.applyNormalMatrix(c), i.setAttribute("normal", u);
    }
    if (a.uvs.forEach(function(c, u) {
      let h = "uv" + (u + 1).toString();
      u === 0 && (h = "uv"), i.setAttribute(h, new rt(a.uvs[u], 2));
    }), r.material && r.material.mappingType !== "AllSame") {
      let c = a.materialIndex[0], u = 0;
      if (a.materialIndex.forEach(function(h, f) {
        h !== c && (i.addGroup(u, f - u, c), c = h, u = f);
      }), i.groups.length > 0) {
        const h = i.groups[i.groups.length - 1], f = h.start + h.count;
        f !== a.materialIndex.length && i.addGroup(f, a.materialIndex.length - f, c);
      }
      i.groups.length === 0 && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, n, s), i;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      n.uv = [];
      let s = 0;
      for (; e.LayerElementUV[s]; )
        e.LayerElementUV[s].UV && n.uv.push(this.parseUVs(e.LayerElementUV[s])), s++;
    }
    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(s, i) {
      s.indices.forEach(function(r, a) {
        n.weightTable[r] === void 0 && (n.weightTable[r] = []), n.weightTable[r].push({
          id: i,
          weight: s.weights[a]
        });
      });
    })), n;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let n = 0, s = 0, i = !1, r = [], a = [], l = [], c = [], u = [], h = [];
    const f = this;
    return e.vertexIndices.forEach(function(p, y) {
      let g, v = !1;
      p < 0 && (p = p ^ -1, v = !0);
      let d = [], w = [];
      if (r.push(p * 3, p * 3 + 1, p * 3 + 2), e.color) {
        const x = Vs(y, n, p, e.color);
        l.push(x[0], x[1], x[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(x) {
          w.push(x.weight), d.push(x.id);
        }), w.length > 4) {
          i || (console.warn(
            "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
          ), i = !0);
          const x = [0, 0, 0, 0], T = [0, 0, 0, 0];
          w.forEach(function(P, S) {
            let M = P, m = d[S];
            T.forEach(function(b, _, I) {
              if (M > b) {
                I[_] = M, M = b;
                const R = x[_];
                x[_] = m, m = R;
              }
            });
          }), d = x, w = T;
        }
        for (; w.length < 4; )
          w.push(0), d.push(0);
        for (let x = 0; x < 4; ++x)
          u.push(w[x]), h.push(d[x]);
      }
      if (e.normal) {
        const x = Vs(y, n, p, e.normal);
        a.push(x[0], x[1], x[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (g = Vs(y, n, p, e.material)[0]), e.uv && e.uv.forEach(function(x, T) {
        const P = Vs(y, n, p, x);
        c[T] === void 0 && (c[T] = []), c[T].push(P[0]), c[T].push(P[1]);
      }), s++, v && (f.genFace(
        t,
        e,
        r,
        g,
        a,
        l,
        c,
        u,
        h,
        s
      ), n++, s = 0, r = [], a = [], l = [], c = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, n, s, i, r, a, l, c, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[h * 3]]), e.vertex.push(t.vertexPositions[n[h * 3 + 1]]), e.vertex.push(t.vertexPositions[n[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(h - 1) * 4]), e.vertexWeights.push(l[(h - 1) * 4 + 1]), e.vertexWeights.push(l[(h - 1) * 4 + 2]), e.vertexWeights.push(l[(h - 1) * 4 + 3]), e.vertexWeights.push(l[h * 4]), e.vertexWeights.push(l[h * 4 + 1]), e.vertexWeights.push(l[h * 4 + 2]), e.vertexWeights.push(l[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(r[0]), e.colors.push(r[1]), e.colors.push(r[2]), e.colors.push(r[(h - 1) * 3]), e.colors.push(r[(h - 1) * 3 + 1]), e.colors.push(r[(h - 1) * 3 + 2]), e.colors.push(r[h * 3]), e.colors.push(r[h * 3 + 1]), e.colors.push(r[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(h - 1) * 3]), e.normal.push(i[(h - 1) * 3 + 1]), e.normal.push(i[(h - 1) * 3 + 2]), e.normal.push(i[h * 3]), e.normal.push(i[h * 3 + 1]), e.normal.push(i[h * 3 + 2])), t.uv && t.uv.forEach(function(f, p) {
        e.uvs[p] === void 0 && (e.uvs[p] = []), e.uvs[p].push(a[p][0]), e.uvs[p].push(a[p][1]), e.uvs[p].push(a[p][(h - 1) * 2]), e.uvs[p].push(a[p][(h - 1) * 2 + 1]), e.uvs[p].push(a[p][h * 2]), e.uvs[p].push(a[p][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, n, s) {
    if (n.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    n.forEach(function(r) {
      r.rawTargets.forEach(function(a) {
        const l = Ae.Objects.Geometry[a.geoID];
        l !== void 0 && i.genMorphGeometry(e, t, l, s, a.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, n, s, i) {
    const r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, u = new Float32Array(c);
    for (let y = 0; y < l.length; y++) {
      const g = l[y] * 3;
      u[g] = a[y * 3], u[g + 1] = a[y * 3 + 1], u[g + 2] = a[y * 3 + 2];
    }
    const h = {
      vertexIndices: r,
      vertexPositions: u
    }, f = this.genBuffers(h), p = new rt(f.vertex, 3);
    p.name = i || n.attrName, p.applyMatrix4(s), e.morphAttributes.position.push(p);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Normals.a;
    let i = [];
    return n === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.UV.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Colors.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.ColorIndex.a), {
      dataSize: 4,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
    const s = e.Materials.a, i = [];
    for (let r = 0; r < s.length; ++r)
      i.push(r);
    return {
      dataSize: 1,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    if (ro === void 0)
      return console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      ), new at();
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new at();
    const n = t - 1, s = e.KnotVector.a, i = [], r = e.Points.a;
    for (let h = 0, f = r.length; h < f; h += 4)
      i.push(new lt().fromArray(r, h));
    let a, l;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      a = n, l = s.length - 1 - a;
      for (let h = 0; h < n; ++h)
        i.push(i[h]);
    }
    const u = new ro(n, s, i, a, l).getPoints(i.length * 12);
    return new at().setFromPoints(u);
  }
}
class uh {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const s = t[n], i = this.addClip(s);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (Ae.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ae.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const n in e) {
      const s = e[n];
      if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: s.id,
          attr: s.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ae.Objects.AnimationCurve;
    for (const n in t) {
      const s = {
        id: t[n].id,
        times: t[n].KeyTime.a.map(mh),
        values: t[n].KeyValueFloat.a
      }, i = Ke.get(s.id);
      if (i !== void 0) {
        const r = i.parents[0].ID, a = i.parents[0].relationship;
        a.match(/X/) ? e.get(r).curves.x = s : a.match(/Y/) ? e.get(r).curves.y = s : a.match(/Z/) ? e.get(r).curves.z = s : a.match(/d|DeformPercent/) && e.has(r) && (e.get(r).curves.morph = s);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ae.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
    for (const s in t) {
      const i = [], r = Ke.get(parseInt(s));
      r !== void 0 && (r.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const u = e.get(l.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (i[c] === void 0) {
              const h = Ke.get(l.ID).parents.filter(function(f) {
                return f.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const f = Ae.Objects.Model[h.toString()];
                if (f === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const p = {
                  modelName: f.attrName ? Jt.sanitizeNodeName(f.attrName) : "",
                  ID: f.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                pt.traverse(function(y) {
                  y.ID === f.id && (p.transform = y.matrix, y.userData.transformData && (p.eulerOrder = y.userData.transformData.eulerOrder));
                }), p.transform || (p.transform = new Pe()), "PreRotation" in f && (p.preRotation = f.PreRotation.value), "PostRotation" in f && (p.postRotation = f.PostRotation.value), i[c] = p;
              }
            }
            i[c] && (i[c][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const h = Ke.get(l.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID, f = Ke.get(h).parents[0].ID, p = Ke.get(f).parents[0].ID, y = Ke.get(p).parents[0].ID, g = Ae.Objects.Model[y], v = {
                modelName: g.attrName ? Jt.sanitizeNodeName(g.attrName) : "",
                morphName: Ae.Objects.Deformer[h].attrName
              };
              i[c] = v;
            }
            i[c][u.attr] = u;
          }
        }
      }), n.set(parseInt(s), i));
    }
    return n;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ae.Objects.AnimationStack, n = {};
    for (const s in t) {
      const i = Ke.get(parseInt(s)).children;
      i.length > 1 && console.warn(
        "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
      );
      const r = e.get(i[0].ID);
      n[s] = {
        name: t[s].attrName,
        layer: r
      };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return e.layer.forEach(function(s) {
      t = t.concat(n.generateTracks(s));
    }), new da(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let n = new Z(), s = new He(), i = new Z();
    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new Rn().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const r = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        n,
        "position"
      );
      r !== void 0 && t.push(r);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const r = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        s,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      r !== void 0 && t.push(r);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const r = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
      r !== void 0 && t.push(r);
    }
    if (e.DeformPercent !== void 0) {
      const r = this.generateMorphTrack(e);
      r !== void 0 && t.push(r);
    }
    return t;
  }
  generateVectorTrack(e, t, n, s) {
    const i = this.getTimesForAllAxes(t), r = this.getKeyframeTrackValues(i, t, n);
    return new pa(e + "." + s, i, r);
  }
  generateRotationTrack(e, t, n, s, i, r) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Ze.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Ze.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Ze.degToRad));
    const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);
    s !== void 0 && (s = s.map(Ze.degToRad), s.push(r), s = new Rn().fromArray(s), s = new He().setFromEuler(s)), i !== void 0 && (i = i.map(Ze.degToRad), i.push(r), i = new Rn().fromArray(i), i = new He().setFromEuler(i).invert());
    const c = new He(), u = new Rn(), h = [];
    for (let f = 0; f < l.length; f += 3)
      u.set(l[f], l[f + 1], l[f + 2], r), c.setFromEuler(u), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(h, f / 3 * 4);
    return new nr(e + ".quaternion", a, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, n = t.values.map(function(i) {
      return i / 100;
    }), s = pt.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new ma(
      e.modelName + ".morphTargetInfluences[" + s + "]",
      t.times,
      n
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, s) {
      return n - s;
    }), t.length > 1) {
      let n = 1, s = t[0];
      for (let i = 1; i < t.length; i++) {
        const r = t[i];
        r !== s && (t[n] = r, s = r, n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const s = n, i = [];
    let r = -1, a = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (r = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), r !== -1) {
        const u = t.x.values[r];
        i.push(u), s[0] = u;
      } else
        i.push(s[0]);
      if (a !== -1) {
        const u = t.y.values[a];
        i.push(u), s[1] = u;
      } else
        i.push(s[1]);
      if (l !== -1) {
        const u = t.z.values[l];
        i.push(u), s[2] = u;
      } else
        i.push(s[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const n = e.values[t - 1], s = e.values[t] - n, i = Math.abs(s);
      if (i >= 180) {
        const r = i / 180, a = s / r;
        let l = n + a;
        const c = e.times[t - 1], h = (e.times[t] - c) / r;
        let f = c + h;
        const p = [], y = [];
        for (; f < e.times[t]; )
          p.push(f), f += h, y.push(l), l += a;
        e.times = lo(e.times, t, p), e.values = lo(e.values, t, y);
      }
    }
  }
}
class hh {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new za(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, n = e.split(/[\r\n]+/);
    return n.forEach(function(s, i) {
      const r = s.match(/^[\s\t]*;/), a = s.match(/^[\s\t]*$/);
      if (r || a)
        return;
      const l = s.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = s.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = s.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(s, l) : c ? t.parseNodeProperty(s, c, n[++i]) : u ? t.popStack() : s.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(s);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), s = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: n }, r = this.parseNodeAttr(s), a = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(n, i) : n in a ? (n === "PoseNode" ? a.PoseNode.push(i) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), r.id !== "" && (a[n][r.id] = i)) : typeof r.id == "number" ? (a[n] = {}, a[n][r.id] = i) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [i] : a[n] = i), typeof r.id == "number" && (i.id = r.id), r.name !== "" && (i.attrName = r.name), r.type !== "" && (i.attrType = r.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let n = "", s = "";
    return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), s = e[2]), { id: t, name: n, type: s };
  }
  parseNodeProperty(e, t, n) {
    let s = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    s === "Content" && i === "," && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
    const r = this.getCurrentNode();
    if (r.name === "Properties70") {
      this.parseNodeSpecialProperty(e, s, i);
      return;
    }
    if (s === "C") {
      const l = i.split(",").slice(1), c = parseInt(l[0]), u = parseInt(l[1]);
      let h = i.split(",").slice(3);
      h = h.map(function(f) {
        return f.trim().replace(/^"/, "");
      }), s = "connections", i = [c, u], vh(i, h), r[s] === void 0 && (r[s] = []);
    }
    s === "Node" && (r.id = i), s in r && Array.isArray(r[s]) ? r[s].push(i) : s !== "a" ? r[s] = i : r.a = i, this.setCurrentProp(r, s), s === "a" && i.slice(-1) !== "," && (r.a = Di(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Di(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, n) {
    const s = n.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = s[0], r = s[1], a = s[2], l = s[3];
    let c = s[4];
    switch (r) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = Di(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: r,
      type2: a,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class fh {
  parse(e) {
    const t = new oo(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
    const s = new za();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, n);
      i !== null && s.add(i.name, i);
    }
    return s;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const n = {}, s = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const r = e.getUint8(), a = e.getString(r);
    if (s === 0)
      return null;
    const l = [];
    for (let f = 0; f < i; f++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", u = l.length > 1 ? l[1] : "", h = l.length > 2 ? l[2] : "";
    for (n.singleProperty = i === 1 && e.getOffset() === s; s > e.getOffset(); ) {
      const f = this.parseNode(e, t);
      f !== null && this.parseSubNode(a, n, f);
    }
    return n.propertyList = l, typeof c == "number" && (n.id = c), u !== "" && (n.attrName = u), h !== "" && (n.attrType = h), a !== "" && (n.name = a), n;
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const s = n.propertyList[0];
      Array.isArray(s) ? (t[n.name] = n, n.a = s) : t[n.name] = s;
    } else if (e === "Connections" && n.name === "C") {
      const s = [];
      n.propertyList.forEach(function(i, r) {
        r !== 0 && s.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(s);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function(i) {
        t[i] = n[i];
      });
    else if (e === "Properties70" && n.name === "P") {
      let s = n.propertyList[0], i = n.propertyList[1];
      const r = n.propertyList[2], a = n.propertyList[3];
      let l;
      s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4], t[s] = {
        type: i,
        type2: r,
        flag: a,
        value: l
      };
    } else
      t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return n = e.getUint32(), e.getArrayBuffer(n);
      case "S":
        return n = e.getUint32(), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const s = e.getUint32(), i = e.getUint32(), r = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(s);
            case "d":
              return e.getFloat64Array(s);
            case "f":
              return e.getFloat32Array(s);
            case "i":
              return e.getInt32Array(s);
            case "l":
              return e.getInt64Array(s);
          }
        const a = eu(new Uint8Array(e.getArrayBuffer(r))), l = new oo(a.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(s);
          case "d":
            return l.getFloat64Array(s);
          case "f":
            return l.getFloat32Array(s);
          case "i":
            return l.getInt32Array(s);
          case "l":
            return l.getInt64Array(s);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class oo {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let s = 0; s < e; s++)
      t[s] = this.getUint8();
    const n = t.indexOf(0);
    return n >= 0 && (t = t.slice(0, n)), Ht.decodeText(new Uint8Array(t));
  }
}
class za {
  add(e, t) {
    this[e] = t;
  }
}
function dh(o) {
  const e = "Kaydara FBX Binary  \0";
  return o.byteLength >= e.length && e === Ga(o, 0, e.length);
}
function ph(o) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let t = 0;
  function n(s) {
    const i = o[s - 1];
    return o = o.slice(t + s), t++, i;
  }
  for (let s = 0; s < e.length; ++s)
    if (n(1) === e[s])
      return !1;
  return !0;
}
function ao(o) {
  const e = /FBXVersion: (\d+)/, t = o.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function mh(o) {
  return o / 46186158e3;
}
const gh = [];
function Vs(o, e, t, n) {
  let s;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      s = o;
      break;
    case "ByPolygon":
      s = e;
      break;
    case "ByVertice":
      s = t;
      break;
    case "AllSame":
      s = n.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
  }
  n.referenceType === "IndexToDirect" && (s = n.indices[s]);
  const i = s * n.dataSize, r = i + n.dataSize;
  return yh(gh, n.buffer, i, r);
}
const Ri = new Rn(), jn = new Z();
function Ha(o) {
  const e = new Pe(), t = new Pe(), n = new Pe(), s = new Pe(), i = new Pe(), r = new Pe(), a = new Pe(), l = new Pe(), c = new Pe(), u = new Pe(), h = new Pe(), f = new Pe(), p = o.inheritType ? o.inheritType : 0;
  if (o.translation && e.setPosition(jn.fromArray(o.translation)), o.preRotation) {
    const _ = o.preRotation.map(Ze.degToRad);
    _.push(o.eulerOrder), t.makeRotationFromEuler(Ri.fromArray(_));
  }
  if (o.rotation) {
    const _ = o.rotation.map(Ze.degToRad);
    _.push(o.eulerOrder), n.makeRotationFromEuler(Ri.fromArray(_));
  }
  if (o.postRotation) {
    const _ = o.postRotation.map(Ze.degToRad);
    _.push(o.eulerOrder), s.makeRotationFromEuler(Ri.fromArray(_)), s.invert();
  }
  o.scale && i.scale(jn.fromArray(o.scale)), o.scalingOffset && a.setPosition(jn.fromArray(o.scalingOffset)), o.scalingPivot && r.setPosition(jn.fromArray(o.scalingPivot)), o.rotationOffset && l.setPosition(jn.fromArray(o.rotationOffset)), o.rotationPivot && c.setPosition(jn.fromArray(o.rotationPivot)), o.parentMatrixWorld && (h.copy(o.parentMatrix), u.copy(o.parentMatrixWorld));
  const y = t.clone().multiply(n).multiply(s), g = new Pe();
  g.extractRotation(u);
  const v = new Pe();
  v.copyPosition(u);
  const d = v.clone().invert().multiply(u), w = g.clone().invert().multiply(d), x = i, T = new Pe();
  if (p === 0)
    T.copy(g).multiply(y).multiply(w).multiply(x);
  else if (p === 1)
    T.copy(g).multiply(w).multiply(y).multiply(x);
  else {
    const I = new Pe().scale(new Z().setFromMatrixScale(h)).clone().invert(), R = w.clone().multiply(I);
    T.copy(g).multiply(y).multiply(R).multiply(x);
  }
  const P = c.clone().invert(), S = r.clone().invert();
  let M = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(P).multiply(a).multiply(r).multiply(i).multiply(S);
  const m = new Pe().copyPosition(M), b = u.clone().multiply(m);
  return f.copyPosition(b), M = f.clone().multiply(T), M.premultiply(u.invert()), M;
}
function ja(o) {
  o = o || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return o === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[o];
}
function Di(o) {
  return o.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Ga(o, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = o.byteLength), Ht.decodeText(new Uint8Array(o, e, t));
}
function vh(o, e) {
  for (let t = 0, n = o.length, s = e.length; t < s; t++, n++)
    o[n] = e[t];
}
function yh(o, e, t, n) {
  for (let s = t, i = 0; s < n; s++, i++)
    o[i] = e[s];
  return o;
}
function lo(o, e, t) {
  return o.slice(0, e).concat(t).concat(o.slice(e));
}
var _h = Object.defineProperty, xh = (o, e, t) => e in o ? _h(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Ar = (o, e, t) => (xh(o, typeof e != "symbol" ? e + "" : e, t), t);
class wh extends Es {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = new Fn(this.manager);
    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (r) => {
        if (typeof r != "string")
          throw new Error("unsupported data type");
        const a = JSON.parse(r), l = this.parse(a);
        t && t(l);
      },
      n,
      s
    );
  }
  loadAsync(e, t) {
    return super.loadAsync(e, t);
  }
  parse(e) {
    return new Pr(e);
  }
}
class Pr {
  constructor(e) {
    Ar(this, "data"), this.data = e;
  }
  generateShapes(e, t = 100, n) {
    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, r = Th(e, t, this.data, i);
    for (let a = 0, l = r.length; a < l; a++)
      Array.prototype.push.apply(s, r[a].toShapes(!1));
    return s;
  }
}
Ar(Pr, "isFont");
Ar(Pr, "type");
function Th(o, e, t, n) {
  const s = Array.from(o), i = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];
  let l = 0, c = 0;
  for (let u = 0; u < s.length; u++) {
    const h = s[u];
    if (h === `
`)
      l = 0, c -= r * n.lineHeight;
    else {
      const f = bh(h, i, l, c, t);
      f && (l += f.offsetX + n.letterSpacing, a.push(f.path));
    }
  }
  return a;
}
function bh(o, e, t, n, s) {
  const i = s.glyphs[o] || s.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + o + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const r = new hn();
  let a, l, c, u, h, f, p, y;
  if (i.o) {
    const g = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let v = 0, d = g.length; v < d; )
      switch (g[v++]) {
        case "m":
          a = parseInt(g[v++]) * e + t, l = parseInt(g[v++]) * e + n, r.moveTo(a, l);
          break;
        case "l":
          a = parseInt(g[v++]) * e + t, l = parseInt(g[v++]) * e + n, r.lineTo(a, l);
          break;
        case "q":
          c = parseInt(g[v++]) * e + t, u = parseInt(g[v++]) * e + n, h = parseInt(g[v++]) * e + t, f = parseInt(g[v++]) * e + n, r.quadraticCurveTo(h, f, c, u);
          break;
        case "b":
          c = parseInt(g[v++]) * e + t, u = parseInt(g[v++]) * e + n, h = parseInt(g[v++]) * e + t, f = parseInt(g[v++]) * e + n, p = parseInt(g[v++]) * e + t, y = parseInt(g[v++]) * e + n, r.bezierCurveTo(h, f, p, y, c, u);
          break;
      }
  }
  return { offsetX: i.ha * e, path: r };
}
class co extends Fl {
  constructor(e) {
    super(e), this.type = Qt;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const r = function(m, b) {
      switch (m) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (b || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (b || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (b || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (b || ""));
      }
    }, u = `
`, h = function(m, b, _) {
      b = b || 1024;
      let R = m.pos, z = -1, k = 0, G = "", U = String.fromCharCode.apply(null, new Uint16Array(m.subarray(R, R + 128)));
      for (; 0 > (z = U.indexOf(u)) && k < b && R < m.byteLength; )
        G += U, k += U.length, R += 128, U += String.fromCharCode.apply(null, new Uint16Array(m.subarray(R, R + 128)));
      return -1 < z ? (m.pos += k + z + 1, G + U.slice(0, z)) : !1;
    }, f = function(m) {
      const b = /^#\?(\S+)/, _ = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, I = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, R = /^\s*FORMAT=(\S+)\s*$/, z = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, k = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let G, U;
      for ((m.pos >= m.byteLength || !(G = h(m))) && r(1, "no header found"), (U = G.match(b)) || r(3, "bad initial token"), k.valid |= 1, k.programtype = U[1], k.string += G + `
`; G = h(m), G !== !1; ) {
        if (k.string += G + `
`, G.charAt(0) === "#") {
          k.comments += G + `
`;
          continue;
        }
        if ((U = G.match(_)) && (k.gamma = parseFloat(U[1])), (U = G.match(I)) && (k.exposure = parseFloat(U[1])), (U = G.match(R)) && (k.valid |= 2, k.format = U[1]), (U = G.match(z)) && (k.valid |= 4, k.height = parseInt(U[1], 10), k.width = parseInt(U[2], 10)), k.valid & 2 && k.valid & 4)
          break;
      }
      return k.valid & 2 || r(3, "missing format specifier"), k.valid & 4 || r(3, "missing image size specifier"), k;
    }, p = function(m, b, _) {
      const I = b;
      if (
        // run length encoding is not allowed so read flat
        I < 8 || I > 32767 || // this file is not run length encoded
        m[0] !== 2 || m[1] !== 2 || m[2] & 128
      )
        return new Uint8Array(m);
      I !== (m[2] << 8 | m[3]) && r(3, "wrong scanline width");
      const R = new Uint8Array(4 * b * _);
      R.length || r(4, "unable to allocate buffer space");
      let z = 0, k = 0;
      const G = 4 * I, U = new Uint8Array(4), q = new Uint8Array(G);
      let $ = _;
      for (; $ > 0 && k < m.byteLength; ) {
        k + 4 > m.byteLength && r(1), U[0] = m[k++], U[1] = m[k++], U[2] = m[k++], U[3] = m[k++], (U[0] != 2 || U[1] != 2 || (U[2] << 8 | U[3]) != I) && r(3, "bad rgbe scanline format");
        let te = 0, ee;
        for (; te < G && k < m.byteLength; ) {
          ee = m[k++];
          const de = ee > 128;
          if (de && (ee -= 128), (ee === 0 || te + ee > G) && r(3, "bad scanline data"), de) {
            const xe = m[k++];
            for (let C = 0; C < ee; C++)
              q[te++] = xe;
          } else
            q.set(m.subarray(k, k + ee), te), te += ee, k += ee;
        }
        const oe = I;
        for (let de = 0; de < oe; de++) {
          let xe = 0;
          R[z] = q[de + xe], xe += I, R[z + 1] = q[de + xe], xe += I, R[z + 2] = q[de + xe], xe += I, R[z + 3] = q[de + xe], z += 4;
        }
        $--;
      }
      return R;
    }, y = function(m, b, _, I) {
      const R = m[b + 3], z = Math.pow(2, R - 128) / 255;
      _[I + 0] = m[b + 0] * z, _[I + 1] = m[b + 1] * z, _[I + 2] = m[b + 2] * z, _[I + 3] = 1;
    }, g = function(m, b, _, I) {
      const R = m[b + 3], z = Math.pow(2, R - 128) / 255;
      _[I + 0] = Bs.toHalfFloat(Math.min(m[b + 0] * z, 65504)), _[I + 1] = Bs.toHalfFloat(Math.min(m[b + 1] * z, 65504)), _[I + 2] = Bs.toHalfFloat(Math.min(m[b + 2] * z, 65504)), _[I + 3] = Bs.toHalfFloat(1);
    }, v = new Uint8Array(e);
    v.pos = 0;
    const d = f(v), w = d.width, x = d.height, T = p(v.subarray(v.pos), w, x);
    let P, S, M;
    switch (this.type) {
      case si:
        M = T.length / 4;
        const m = new Float32Array(M * 4);
        for (let _ = 0; _ < M; _++)
          y(T, _ * 4, m, _ * 4);
        P = m, S = si;
        break;
      case Qt:
        M = T.length / 4;
        const b = new Uint16Array(M * 4);
        for (let _ = 0; _ < M; _++)
          g(T, _ * 4, b, _ * 4);
        P = b, S = Qt;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: w,
      height: x,
      data: P,
      header: d.string,
      gamma: d.gamma,
      exposure: d.exposure,
      type: S
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, s) {
    function i(r, a) {
      switch (r.type) {
        case si:
        case Qt:
          "colorSpace" in r ? r.colorSpace = "srgb-linear" : r.encoding = 3e3, r.minFilter = Ot, r.magFilter = Ot, r.generateMipmaps = !1, r.flipY = !0;
          break;
      }
      t && t(r, a);
    }
    return super.load(e, i, n, s);
  }
}
const Eh = "srgb";
class xs extends Es {
  constructor(e) {
    super(e), this.defaultDPI = 90, this.defaultUnit = "px";
  }
  load(e, t, n, s) {
    const i = this, r = new Fn(i.manager);
    r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(
      e,
      function(a) {
        try {
          t(i.parse(a));
        } catch (l) {
          s ? s(l) : console.error(l), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e) {
    const t = this;
    function n(C, B) {
      if (C.nodeType !== 1)
        return;
      const L = T(C);
      let O = !1, N = null;
      switch (C.nodeName) {
        case "svg":
          B = y(C, B);
          break;
        case "style":
          i(C);
          break;
        case "g":
          B = y(C, B);
          break;
        case "path":
          B = y(C, B), C.hasAttribute("d") && (N = s(C));
          break;
        case "rect":
          B = y(C, B), N = l(C);
          break;
        case "polygon":
          B = y(C, B), N = c(C);
          break;
        case "polyline":
          B = y(C, B), N = u(C);
          break;
        case "circle":
          B = y(C, B), N = h(C);
          break;
        case "ellipse":
          B = y(C, B), N = f(C);
          break;
        case "line":
          B = y(C, B), N = p(C);
          break;
        case "defs":
          O = !0;
          break;
        case "use":
          B = y(C, B);
          const D = (C.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1), W = C.viewportElement.getElementById(D);
          W ? n(W, B) : console.warn("SVGLoader: 'use node' references non-existent node id: " + D);
          break;
      }
      N && (B.fill !== void 0 && B.fill !== "none" && N.color.setStyle(B.fill, Eh), S(N, oe), R.push(N), N.userData = { node: C, style: B });
      const E = C.childNodes;
      for (let A = 0; A < E.length; A++) {
        const D = E[A];
        O && D.nodeName !== "style" && D.nodeName !== "defs" || n(D, B);
      }
      L && (k.pop(), k.length > 0 ? oe.copy(k[k.length - 1]) : oe.identity());
    }
    function s(C) {
      const B = new hn(), L = new ge(), O = new ge(), N = new ge();
      let E = !0, A = !1;
      const D = C.getAttribute("d");
      if (D === "" || D === "none")
        return null;
      const W = D.match(/[a-df-z][^a-df-z]*/gi);
      for (let Y = 0, j = W.length; Y < j; Y++) {
        const J = W[Y], ne = J.charAt(0), se = J.slice(1).trim();
        E === !0 && (A = !0, E = !1);
        let V;
        switch (ne) {
          case "M":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 2)
              L.x = V[F + 0], L.y = V[F + 1], O.x = L.x, O.y = L.y, F === 0 ? B.moveTo(L.x, L.y) : B.lineTo(L.x, L.y), F === 0 && N.copy(L);
            break;
          case "H":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F++)
              L.x = V[F], O.x = L.x, O.y = L.y, B.lineTo(L.x, L.y), F === 0 && A === !0 && N.copy(L);
            break;
          case "V":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F++)
              L.y = V[F], O.x = L.x, O.y = L.y, B.lineTo(L.x, L.y), F === 0 && A === !0 && N.copy(L);
            break;
          case "L":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 2)
              L.x = V[F + 0], L.y = V[F + 1], O.x = L.x, O.y = L.y, B.lineTo(L.x, L.y), F === 0 && A === !0 && N.copy(L);
            break;
          case "C":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 6)
              B.bezierCurveTo(
                V[F + 0],
                V[F + 1],
                V[F + 2],
                V[F + 3],
                V[F + 4],
                V[F + 5]
              ), O.x = V[F + 2], O.y = V[F + 3], L.x = V[F + 4], L.y = V[F + 5], F === 0 && A === !0 && N.copy(L);
            break;
          case "S":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 4)
              B.bezierCurveTo(
                g(L.x, O.x),
                g(L.y, O.y),
                V[F + 0],
                V[F + 1],
                V[F + 2],
                V[F + 3]
              ), O.x = V[F + 0], O.y = V[F + 1], L.x = V[F + 2], L.y = V[F + 3], F === 0 && A === !0 && N.copy(L);
            break;
          case "Q":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 4)
              B.quadraticCurveTo(V[F + 0], V[F + 1], V[F + 2], V[F + 3]), O.x = V[F + 0], O.y = V[F + 1], L.x = V[F + 2], L.y = V[F + 3], F === 0 && A === !0 && N.copy(L);
            break;
          case "T":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 2) {
              const fe = g(L.x, O.x), Me = g(L.y, O.y);
              B.quadraticCurveTo(fe, Me, V[F + 0], V[F + 1]), O.x = fe, O.y = Me, L.x = V[F + 0], L.y = V[F + 1], F === 0 && A === !0 && N.copy(L);
            }
            break;
          case "A":
            V = v(se, [3, 4], 7);
            for (let F = 0, re = V.length; F < re; F += 7) {
              if (V[F + 5] == L.x && V[F + 6] == L.y)
                continue;
              const fe = L.clone();
              L.x = V[F + 5], L.y = V[F + 6], O.x = L.x, O.y = L.y, r(
                B,
                V[F],
                V[F + 1],
                V[F + 2],
                V[F + 3],
                V[F + 4],
                fe,
                L
              ), F === 0 && A === !0 && N.copy(L);
            }
            break;
          case "m":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 2)
              L.x += V[F + 0], L.y += V[F + 1], O.x = L.x, O.y = L.y, F === 0 ? B.moveTo(L.x, L.y) : B.lineTo(L.x, L.y), F === 0 && N.copy(L);
            break;
          case "h":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F++)
              L.x += V[F], O.x = L.x, O.y = L.y, B.lineTo(L.x, L.y), F === 0 && A === !0 && N.copy(L);
            break;
          case "v":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F++)
              L.y += V[F], O.x = L.x, O.y = L.y, B.lineTo(L.x, L.y), F === 0 && A === !0 && N.copy(L);
            break;
          case "l":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 2)
              L.x += V[F + 0], L.y += V[F + 1], O.x = L.x, O.y = L.y, B.lineTo(L.x, L.y), F === 0 && A === !0 && N.copy(L);
            break;
          case "c":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 6)
              B.bezierCurveTo(
                L.x + V[F + 0],
                L.y + V[F + 1],
                L.x + V[F + 2],
                L.y + V[F + 3],
                L.x + V[F + 4],
                L.y + V[F + 5]
              ), O.x = L.x + V[F + 2], O.y = L.y + V[F + 3], L.x += V[F + 4], L.y += V[F + 5], F === 0 && A === !0 && N.copy(L);
            break;
          case "s":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 4)
              B.bezierCurveTo(
                g(L.x, O.x),
                g(L.y, O.y),
                L.x + V[F + 0],
                L.y + V[F + 1],
                L.x + V[F + 2],
                L.y + V[F + 3]
              ), O.x = L.x + V[F + 0], O.y = L.y + V[F + 1], L.x += V[F + 2], L.y += V[F + 3], F === 0 && A === !0 && N.copy(L);
            break;
          case "q":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 4)
              B.quadraticCurveTo(
                L.x + V[F + 0],
                L.y + V[F + 1],
                L.x + V[F + 2],
                L.y + V[F + 3]
              ), O.x = L.x + V[F + 0], O.y = L.y + V[F + 1], L.x += V[F + 2], L.y += V[F + 3], F === 0 && A === !0 && N.copy(L);
            break;
          case "t":
            V = v(se);
            for (let F = 0, re = V.length; F < re; F += 2) {
              const fe = g(L.x, O.x), Me = g(L.y, O.y);
              B.quadraticCurveTo(fe, Me, L.x + V[F + 0], L.y + V[F + 1]), O.x = fe, O.y = Me, L.x = L.x + V[F + 0], L.y = L.y + V[F + 1], F === 0 && A === !0 && N.copy(L);
            }
            break;
          case "a":
            V = v(se, [3, 4], 7);
            for (let F = 0, re = V.length; F < re; F += 7) {
              if (V[F + 5] == 0 && V[F + 6] == 0)
                continue;
              const fe = L.clone();
              L.x += V[F + 5], L.y += V[F + 6], O.x = L.x, O.y = L.y, r(
                B,
                V[F],
                V[F + 1],
                V[F + 2],
                V[F + 3],
                V[F + 4],
                fe,
                L
              ), F === 0 && A === !0 && N.copy(L);
            }
            break;
          case "Z":
          case "z":
            B.currentPath.autoClose = !0, B.currentPath.curves.length > 0 && (L.copy(N), B.currentPath.currentPoint.copy(L), E = !0);
            break;
          default:
            console.warn(J);
        }
        A = !1;
      }
      return B;
    }
    function i(C) {
      if (!(!C.sheet || !C.sheet.cssRules || !C.sheet.cssRules.length))
        for (let B = 0; B < C.sheet.cssRules.length; B++) {
          const L = C.sheet.cssRules[B];
          if (L.type !== 1)
            continue;
          const O = L.selectorText.split(/,/gm).filter(Boolean).map((N) => N.trim());
          for (let N = 0; N < O.length; N++) {
            const E = Object.fromEntries(Object.entries(L.style).filter(([, A]) => A !== ""));
            z[O[N]] = Object.assign(z[O[N]] || {}, E);
          }
        }
    }
    function r(C, B, L, O, N, E, A, D) {
      if (B == 0 || L == 0) {
        C.lineTo(D.x, D.y);
        return;
      }
      O = O * Math.PI / 180, B = Math.abs(B), L = Math.abs(L);
      const W = (A.x - D.x) / 2, Y = (A.y - D.y) / 2, j = Math.cos(O) * W + Math.sin(O) * Y, J = -Math.sin(O) * W + Math.cos(O) * Y;
      let ne = B * B, se = L * L;
      const V = j * j, F = J * J, re = V / ne + F / se;
      if (re > 1) {
        const Un = Math.sqrt(re);
        B = Un * B, L = Un * L, ne = B * B, se = L * L;
      }
      const fe = ne * F + se * V, Me = (ne * se - fe) / fe;
      let Xe = Math.sqrt(Math.max(0, Me));
      N === E && (Xe = -Xe);
      const je = Xe * B * J / L, _t = -Xe * L * j / B, nn = Math.cos(O) * je - Math.sin(O) * _t + (A.x + D.x) / 2, gt = Math.sin(O) * je + Math.cos(O) * _t + (A.y + D.y) / 2, sn = a(1, 0, (j - je) / B, (J - _t) / L), is = a((j - je) / B, (J - _t) / L, (-j - je) / B, (-J - _t) / L) % (Math.PI * 2);
      C.currentPath.absellipse(nn, gt, B, L, sn, sn + is, E === 0, O);
    }
    function a(C, B, L, O) {
      const N = C * L + B * O, E = Math.sqrt(C * C + B * B) * Math.sqrt(L * L + O * O);
      let A = Math.acos(Math.max(-1, Math.min(1, N / E)));
      return C * O - B * L < 0 && (A = -A), A;
    }
    function l(C) {
      const B = x(C.getAttribute("x") || 0), L = x(C.getAttribute("y") || 0), O = x(C.getAttribute("rx") || C.getAttribute("ry") || 0), N = x(C.getAttribute("ry") || C.getAttribute("rx") || 0), E = x(C.getAttribute("width")), A = x(C.getAttribute("height")), D = 1 - 0.551915024494, W = new hn();
      return W.moveTo(B + O, L), W.lineTo(B + E - O, L), (O !== 0 || N !== 0) && W.bezierCurveTo(B + E - O * D, L, B + E, L + N * D, B + E, L + N), W.lineTo(B + E, L + A - N), (O !== 0 || N !== 0) && W.bezierCurveTo(B + E, L + A - N * D, B + E - O * D, L + A, B + E - O, L + A), W.lineTo(B + O, L + A), (O !== 0 || N !== 0) && W.bezierCurveTo(B + O * D, L + A, B, L + A - N * D, B, L + A - N), W.lineTo(B, L + N), (O !== 0 || N !== 0) && W.bezierCurveTo(B, L + N * D, B + O * D, L, B + O, L), W;
    }
    function c(C) {
      function B(E, A, D) {
        const W = x(A), Y = x(D);
        N === 0 ? O.moveTo(W, Y) : O.lineTo(W, Y), N++;
      }
      const L = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, O = new hn();
      let N = 0;
      return C.getAttribute("points").replace(L, B), O.currentPath.autoClose = !0, O;
    }
    function u(C) {
      function B(E, A, D) {
        const W = x(A), Y = x(D);
        N === 0 ? O.moveTo(W, Y) : O.lineTo(W, Y), N++;
      }
      const L = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, O = new hn();
      let N = 0;
      return C.getAttribute("points").replace(L, B), O.currentPath.autoClose = !1, O;
    }
    function h(C) {
      const B = x(C.getAttribute("cx") || 0), L = x(C.getAttribute("cy") || 0), O = x(C.getAttribute("r") || 0), N = new xi();
      N.absarc(B, L, O, 0, Math.PI * 2);
      const E = new hn();
      return E.subPaths.push(N), E;
    }
    function f(C) {
      const B = x(C.getAttribute("cx") || 0), L = x(C.getAttribute("cy") || 0), O = x(C.getAttribute("rx") || 0), N = x(C.getAttribute("ry") || 0), E = new xi();
      E.absellipse(B, L, O, N, 0, Math.PI * 2);
      const A = new hn();
      return A.subPaths.push(E), A;
    }
    function p(C) {
      const B = x(C.getAttribute("x1") || 0), L = x(C.getAttribute("y1") || 0), O = x(C.getAttribute("x2") || 0), N = x(C.getAttribute("y2") || 0), E = new hn();
      return E.moveTo(B, L), E.lineTo(O, N), E.currentPath.autoClose = !1, E;
    }
    function y(C, B) {
      B = Object.assign({}, B);
      let L = {};
      if (C.hasAttribute("class")) {
        const A = C.getAttribute("class").split(/\s/).filter(Boolean).map((D) => D.trim());
        for (let D = 0; D < A.length; D++)
          L = Object.assign(L, z["." + A[D]]);
      }
      C.hasAttribute("id") && (L = Object.assign(L, z["#" + C.getAttribute("id")]));
      function O(A, D, W) {
        W === void 0 && (W = function(j) {
          return j.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), j;
        }), C.hasAttribute(A) && (B[D] = W(C.getAttribute(A))), L[A] && (B[D] = W(L[A])), C.style && C.style[A] !== "" && (B[D] = W(C.style[A]));
      }
      function N(A) {
        return Math.max(0, Math.min(1, x(A)));
      }
      function E(A) {
        return Math.max(0, x(A));
      }
      return O("fill", "fill"), O("fill-opacity", "fillOpacity", N), O("fill-rule", "fillRule"), O("opacity", "opacity", N), O("stroke", "stroke"), O("stroke-opacity", "strokeOpacity", N), O("stroke-width", "strokeWidth", E), O("stroke-linejoin", "strokeLineJoin"), O("stroke-linecap", "strokeLineCap"), O("stroke-miterlimit", "strokeMiterLimit", E), O("visibility", "visibility"), B;
    }
    function g(C, B) {
      return C - (B - C);
    }
    function v(C, B, L) {
      if (typeof C != "string")
        throw new TypeError("Invalid input: " + typeof C);
      const O = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      }, N = 0, E = 1, A = 2, D = 3;
      let W = N, Y = !0, j = "", J = "";
      const ne = [];
      function se(fe, Me, Xe) {
        const je = new SyntaxError('Unexpected character "' + fe + '" at index ' + Me + ".");
        throw je.partial = Xe, je;
      }
      function V() {
        j !== "" && (J === "" ? ne.push(Number(j)) : ne.push(Number(j) * Math.pow(10, Number(J)))), j = "", J = "";
      }
      let F;
      const re = C.length;
      for (let fe = 0; fe < re; fe++) {
        if (F = C[fe], Array.isArray(B) && B.includes(ne.length % L) && O.FLAGS.test(F)) {
          W = E, j = F, V();
          continue;
        }
        if (W === N) {
          if (O.WHITESPACE.test(F))
            continue;
          if (O.DIGIT.test(F) || O.SIGN.test(F)) {
            W = E, j = F;
            continue;
          }
          if (O.POINT.test(F)) {
            W = A, j = F;
            continue;
          }
          O.COMMA.test(F) && (Y && se(F, fe, ne), Y = !0);
        }
        if (W === E) {
          if (O.DIGIT.test(F)) {
            j += F;
            continue;
          }
          if (O.POINT.test(F)) {
            j += F, W = A;
            continue;
          }
          if (O.EXP.test(F)) {
            W = D;
            continue;
          }
          O.SIGN.test(F) && j.length === 1 && O.SIGN.test(j[0]) && se(F, fe, ne);
        }
        if (W === A) {
          if (O.DIGIT.test(F)) {
            j += F;
            continue;
          }
          if (O.EXP.test(F)) {
            W = D;
            continue;
          }
          O.POINT.test(F) && j[j.length - 1] === "." && se(F, fe, ne);
        }
        if (W === D) {
          if (O.DIGIT.test(F)) {
            J += F;
            continue;
          }
          if (O.SIGN.test(F)) {
            if (J === "") {
              J += F;
              continue;
            }
            J.length === 1 && O.SIGN.test(J) && se(F, fe, ne);
          }
        }
        O.WHITESPACE.test(F) ? (V(), W = N, Y = !1) : O.COMMA.test(F) ? (V(), W = N, Y = !0) : O.SIGN.test(F) ? (V(), W = E, j = F) : O.POINT.test(F) ? (V(), W = A, j = F) : se(F, fe, ne);
      }
      return V(), ne;
    }
    const d = ["mm", "cm", "in", "pt", "pc", "px"], w = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function x(C) {
      let B = "px";
      if (typeof C == "string" || C instanceof String)
        for (let O = 0, N = d.length; O < N; O++) {
          const E = d[O];
          if (C.endsWith(E)) {
            B = E, C = C.substring(0, C.length - E.length);
            break;
          }
        }
      let L;
      return B === "px" && t.defaultUnit !== "px" ? L = w.in[t.defaultUnit] / t.defaultDPI : (L = w[B][t.defaultUnit], L < 0 && (L = w[B].in * t.defaultDPI)), L * parseFloat(C);
    }
    function T(C) {
      if (!(C.hasAttribute("transform") || C.nodeName === "use" && (C.hasAttribute("x") || C.hasAttribute("y"))))
        return null;
      const B = P(C);
      return k.length > 0 && B.premultiply(k[k.length - 1]), oe.copy(B), k.push(B), B;
    }
    function P(C) {
      const B = new In(), L = G;
      if (C.nodeName === "use" && (C.hasAttribute("x") || C.hasAttribute("y"))) {
        const O = x(C.getAttribute("x")), N = x(C.getAttribute("y"));
        B.translate(O, N);
      }
      if (C.hasAttribute("transform")) {
        const O = C.getAttribute("transform").split(")");
        for (let N = O.length - 1; N >= 0; N--) {
          const E = O[N].trim();
          if (E === "")
            continue;
          const A = E.indexOf("("), D = E.length;
          if (A > 0 && A < D) {
            const W = E.slice(0, A), Y = v(E.slice(A + 1));
            switch (L.identity(), W) {
              case "translate":
                if (Y.length >= 1) {
                  const j = Y[0];
                  let J = 0;
                  Y.length >= 2 && (J = Y[1]), L.translate(j, J);
                }
                break;
              case "rotate":
                if (Y.length >= 1) {
                  let j = 0, J = 0, ne = 0;
                  j = Y[0] * Math.PI / 180, Y.length >= 3 && (J = Y[1], ne = Y[2]), U.makeTranslation(-J, -ne), q.makeRotation(j), $.multiplyMatrices(q, U), U.makeTranslation(J, ne), L.multiplyMatrices(U, $);
                }
                break;
              case "scale":
                if (Y.length >= 1) {
                  const j = Y[0];
                  let J = j;
                  Y.length >= 2 && (J = Y[1]), L.scale(j, J);
                }
                break;
              case "skewX":
                Y.length === 1 && L.set(1, Math.tan(Y[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                break;
              case "skewY":
                Y.length === 1 && L.set(1, 0, 0, Math.tan(Y[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                break;
              case "matrix":
                Y.length === 6 && L.set(Y[0], Y[2], Y[4], Y[1], Y[3], Y[5], 0, 0, 1);
                break;
            }
          }
          B.premultiply(L);
        }
      }
      return B;
    }
    function S(C, B) {
      function L(A) {
        ee.set(A.x, A.y, 1).applyMatrix3(B), A.set(ee.x, ee.y);
      }
      function O(A) {
        const D = A.xRadius, W = A.yRadius, Y = Math.cos(A.aRotation), j = Math.sin(A.aRotation), J = new Z(D * Y, D * j, 0), ne = new Z(-W * j, W * Y, 0), se = J.applyMatrix3(B), V = ne.applyMatrix3(B), F = G.set(se.x, V.x, 0, se.y, V.y, 0, 0, 0, 1), re = U.copy(F).invert(), Xe = q.copy(re).transpose().multiply(re).elements, je = I(Xe[0], Xe[1], Xe[4]), _t = Math.sqrt(je.rt1), nn = Math.sqrt(je.rt2);
        if (A.xRadius = 1 / _t, A.yRadius = 1 / nn, A.aRotation = Math.atan2(je.sn, je.cs), !((A.aEndAngle - A.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
          const sn = U.set(_t, 0, 0, 0, nn, 0, 0, 0, 1), is = q.set(je.cs, je.sn, 0, -je.sn, je.cs, 0, 0, 0, 1), Un = sn.multiply(is).multiply(F), rs = (Ds) => {
            const { x: Os, y: Ls } = new Z(Math.cos(Ds), Math.sin(Ds), 0).applyMatrix3(Un);
            return Math.atan2(Ls, Os);
          };
          A.aStartAngle = rs(A.aStartAngle), A.aEndAngle = rs(A.aEndAngle), M(B) && (A.aClockwise = !A.aClockwise);
        }
      }
      function N(A) {
        const D = b(B), W = _(B);
        A.xRadius *= D, A.yRadius *= W;
        const Y = D > Number.EPSILON ? Math.atan2(B.elements[1], B.elements[0]) : Math.atan2(-B.elements[3], B.elements[4]);
        A.aRotation += Y, M(B) && (A.aStartAngle *= -1, A.aEndAngle *= -1, A.aClockwise = !A.aClockwise);
      }
      const E = C.subPaths;
      for (let A = 0, D = E.length; A < D; A++) {
        const Y = E[A].curves;
        for (let j = 0; j < Y.length; j++) {
          const J = Y[j];
          J.isLineCurve ? (L(J.v1), L(J.v2)) : J.isCubicBezierCurve ? (L(J.v0), L(J.v1), L(J.v2), L(J.v3)) : J.isQuadraticBezierCurve ? (L(J.v0), L(J.v1), L(J.v2)) : J.isEllipseCurve && (te.set(J.aX, J.aY), L(te), J.aX = te.x, J.aY = te.y, m(B) ? O(J) : N(J));
        }
      }
    }
    function M(C) {
      const B = C.elements;
      return B[0] * B[4] - B[1] * B[3] < 0;
    }
    function m(C) {
      const B = C.elements, L = B[0] * B[3] + B[1] * B[4];
      if (L === 0)
        return !1;
      const O = b(C), N = _(C);
      return Math.abs(L / (O * N)) > Number.EPSILON;
    }
    function b(C) {
      const B = C.elements;
      return Math.sqrt(B[0] * B[0] + B[1] * B[1]);
    }
    function _(C) {
      const B = C.elements;
      return Math.sqrt(B[3] * B[3] + B[4] * B[4]);
    }
    function I(C, B, L) {
      let O, N, E, A, D;
      const W = C + L, Y = C - L, j = Math.sqrt(Y * Y + 4 * B * B);
      return W > 0 ? (O = 0.5 * (W + j), D = 1 / O, N = C * D * L - B * D * B) : W < 0 ? N = 0.5 * (W - j) : (O = 0.5 * j, N = -0.5 * j), Y > 0 ? E = Y + j : E = Y - j, Math.abs(E) > 2 * Math.abs(B) ? (D = -2 * B / E, A = 1 / Math.sqrt(1 + D * D), E = D * A) : Math.abs(B) === 0 ? (E = 1, A = 0) : (D = -0.5 * E / B, E = 1 / Math.sqrt(1 + D * D), A = D * E), Y > 0 && (D = E, E = -A, A = D), { rt1: O, rt2: N, cs: E, sn: A };
    }
    const R = [], z = {}, k = [], G = new In(), U = new In(), q = new In(), $ = new In(), te = new ge(), ee = new Z(), oe = new In(), de = new DOMParser().parseFromString(e, "image/svg+xml");
    return n(de.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    }), { paths: R, xml: de.documentElement };
  }
  static createShapes(e) {
    const n = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    }, s = {
      loc: n.ORIGIN,
      t: 0
    };
    function i(g, v, d, w) {
      const x = g.x, T = v.x, P = d.x, S = w.x, M = g.y, m = v.y, b = d.y, _ = w.y, I = (S - P) * (M - b) - (_ - b) * (x - P), R = (T - x) * (M - b) - (m - M) * (x - P), z = (_ - b) * (T - x) - (S - P) * (m - M), k = I / z, G = R / z;
      if (z === 0 && I !== 0 || k <= 0 || k >= 1 || G < 0 || G > 1)
        return null;
      if (I === 0 && z === 0) {
        for (let U = 0; U < 2; U++)
          if (r(U === 0 ? d : w, g, v), s.loc == n.ORIGIN) {
            const q = U === 0 ? d : w;
            return { x: q.x, y: q.y, t: s.t };
          } else if (s.loc == n.BETWEEN) {
            const q = +(x + s.t * (T - x)).toPrecision(10), $ = +(M + s.t * (m - M)).toPrecision(10);
            return { x: q, y: $, t: s.t };
          }
        return null;
      } else {
        for (let $ = 0; $ < 2; $++)
          if (r($ === 0 ? d : w, g, v), s.loc == n.ORIGIN) {
            const te = $ === 0 ? d : w;
            return { x: te.x, y: te.y, t: s.t };
          }
        const U = +(x + k * (T - x)).toPrecision(10), q = +(M + k * (m - M)).toPrecision(10);
        return { x: U, y: q, t: k };
      }
    }
    function r(g, v, d) {
      const w = d.x - v.x, x = d.y - v.y, T = g.x - v.x, P = g.y - v.y, S = w * P - T * x;
      if (g.x === v.x && g.y === v.y) {
        s.loc = n.ORIGIN, s.t = 0;
        return;
      }
      if (g.x === d.x && g.y === d.y) {
        s.loc = n.DESTINATION, s.t = 1;
        return;
      }
      if (S < -Number.EPSILON) {
        s.loc = n.LEFT;
        return;
      }
      if (S > Number.EPSILON) {
        s.loc = n.RIGHT;
        return;
      }
      if (w * T < 0 || x * P < 0) {
        s.loc = n.BEHIND;
        return;
      }
      if (Math.sqrt(w * w + x * x) < Math.sqrt(T * T + P * P)) {
        s.loc = n.BEYOND;
        return;
      }
      let M;
      w !== 0 ? M = T / w : M = P / x, s.loc = n.BETWEEN, s.t = M;
    }
    function a(g, v) {
      const d = [], w = [];
      for (let x = 1; x < g.length; x++) {
        const T = g[x - 1], P = g[x];
        for (let S = 1; S < v.length; S++) {
          const M = v[S - 1], m = v[S], b = i(T, P, M, m);
          b !== null && d.find(
            (_) => _.t <= b.t + Number.EPSILON && _.t >= b.t - Number.EPSILON
          ) === void 0 && (d.push(b), w.push(new ge(b.x, b.y)));
        }
      }
      return w;
    }
    function l(g, v, d) {
      const w = new ge();
      v.getCenter(w);
      const x = [];
      return d.forEach((T) => {
        T.boundingBox.containsPoint(w) && a(g, T.points).forEach((S) => {
          x.push({ identifier: T.identifier, isCW: T.isCW, point: S });
        });
      }), x.sort((T, P) => T.point.x - P.point.x), x;
    }
    function c(g, v, d, w, x) {
      (x == null || x === "") && (x = "nonzero");
      const T = new ge();
      g.boundingBox.getCenter(T);
      const P = [new ge(d, T.y), new ge(w, T.y)], S = l(P, g.boundingBox, v);
      S.sort((R, z) => R.point.x - z.point.x);
      const M = [], m = [];
      S.forEach((R) => {
        R.identifier === g.identifier ? M.push(R) : m.push(R);
      });
      const b = M[0].point.x, _ = [];
      let I = 0;
      for (; I < m.length && m[I].point.x < b; )
        _.length > 0 && _[_.length - 1] === m[I].identifier ? _.pop() : _.push(m[I].identifier), I++;
      if (_.push(g.identifier), x === "evenodd") {
        const R = _.length % 2 === 0, z = _[_.length - 2];
        return { identifier: g.identifier, isHole: R, for: z };
      } else if (x === "nonzero") {
        let R = !0, z = null, k = null;
        for (let G = 0; G < _.length; G++) {
          const U = _[G];
          R ? (k = v[U].isCW, R = !1, z = U) : k !== v[U].isCW && (k = v[U].isCW, R = !0);
        }
        return { identifier: g.identifier, isHole: R, for: z };
      } else
        console.warn('fill-rule: "' + x + '" is currently not implemented.');
    }
    let u = 999999999, h = -999999999, f = e.subPaths.map((g) => {
      const v = g.getPoints();
      let d = -999999999, w = 999999999, x = -999999999, T = 999999999;
      for (let P = 0; P < v.length; P++) {
        const S = v[P];
        S.y > d && (d = S.y), S.y < w && (w = S.y), S.x > x && (x = S.x), S.x < T && (T = S.x);
      }
      return h <= x && (h = x + 1), u >= T && (u = T - 1), {
        curves: g.curves,
        points: v,
        isCW: kl.isClockWise(v),
        identifier: -1,
        boundingBox: new ga(new ge(T, w), new ge(x, d))
      };
    });
    f = f.filter((g) => g.points.length > 1);
    for (let g = 0; g < f.length; g++)
      f[g].identifier = g;
    const p = f.map(
      (g) => c(
        g,
        f,
        u,
        h,
        e.userData ? e.userData.style.fillRule : void 0
      )
    ), y = [];
    return f.forEach((g) => {
      if (!p[g.identifier].isHole) {
        const d = new Bl();
        d.curves = g.curves, p.filter((x) => x.isHole && x.for === g.identifier).forEach((x) => {
          const T = f[x.identifier], P = new xi();
          P.curves = T.curves, d.holes.push(P);
        }), y.push(d);
      }
    }), y;
  }
  static getStrokeStyle(e, t, n, s, i) {
    return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", n = n !== void 0 ? n : "miter", s = s !== void 0 ? s : "butt", i = i !== void 0 ? i : 4, {
      strokeColor: t,
      strokeWidth: e,
      strokeLineJoin: n,
      strokeLineCap: s,
      strokeMiterLimit: i
    };
  }
  static pointsToStroke(e, t, n, s) {
    const i = [], r = [], a = [];
    if (xs.pointsToStrokeWithBuffers(e, t, n, s, i, r, a) === 0)
      return null;
    const l = new at();
    return l.setAttribute("position", new rt(i, 3)), l.setAttribute("normal", new rt(r, 3)), l.setAttribute("uv", new rt(a, 2)), l;
  }
  static pointsToStrokeWithBuffers(e, t, n, s, i, r, a, l) {
    const c = new ge(), u = new ge(), h = new ge(), f = new ge(), p = new ge(), y = new ge(), g = new ge(), v = new ge(), d = new ge(), w = new ge(), x = new ge(), T = new ge(), P = new ge(), S = new ge(), M = new ge(), m = new ge(), b = new ge();
    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = Y(e);
    const _ = e.length;
    if (_ < 2)
      return 0;
    const I = e[0].equals(e[_ - 1]);
    let R, z = e[0], k;
    const G = t.strokeWidth / 2, U = 1 / (_ - 1);
    let q = 0, $, te, ee, oe, de = !1, xe = 0, C = l * 3, B = l * 2;
    L(e[0], e[1], c).multiplyScalar(G), v.copy(e[0]).sub(c), d.copy(e[0]).add(c), w.copy(v), x.copy(d);
    for (let j = 1; j < _; j++) {
      R = e[j], j === _ - 1 ? I ? k = e[1] : k = void 0 : k = e[j + 1];
      const J = c;
      if (L(z, R, J), h.copy(J).multiplyScalar(G), T.copy(R).sub(h), P.copy(R).add(h), $ = q + U, te = !1, k !== void 0) {
        L(R, k, u), h.copy(u).multiplyScalar(G), S.copy(R).sub(h), M.copy(R).add(h), ee = !0, h.subVectors(k, z), J.dot(h) < 0 && (ee = !1), j === 1 && (de = ee), h.subVectors(k, R), h.normalize();
        const ne = Math.abs(J.dot(h));
        if (ne > Number.EPSILON) {
          const se = G / ne;
          h.multiplyScalar(-se), f.subVectors(R, z), p.copy(f).setLength(se).add(h), m.copy(p).negate();
          const V = p.length(), F = f.length();
          f.divideScalar(F), y.subVectors(k, R);
          const re = y.length();
          switch (y.divideScalar(re), f.dot(m) < F && y.dot(m) < re && (te = !0), b.copy(p).add(R), m.add(R), oe = !1, te ? ee ? (M.copy(m), P.copy(m)) : (S.copy(m), T.copy(m)) : E(), t.strokeLineJoin) {
            case "bevel":
              A(ee, te, $);
              break;
            case "round":
              D(ee, te), ee ? N(R, T, S, $, 0) : N(R, M, P, $, 1);
              break;
            case "miter":
            case "miter-clip":
            default:
              const fe = G * t.strokeMiterLimit / V;
              if (fe < 1)
                if (t.strokeLineJoin !== "miter-clip") {
                  A(ee, te, $);
                  break;
                } else
                  D(ee, te), ee ? (y.subVectors(b, T).multiplyScalar(fe).add(T), g.subVectors(b, S).multiplyScalar(fe).add(S), O(T, $, 0), O(y, $, 0), O(R, $, 0.5), O(R, $, 0.5), O(y, $, 0), O(g, $, 0), O(R, $, 0.5), O(g, $, 0), O(S, $, 0)) : (y.subVectors(b, P).multiplyScalar(fe).add(P), g.subVectors(b, M).multiplyScalar(fe).add(M), O(P, $, 1), O(y, $, 1), O(R, $, 0.5), O(R, $, 0.5), O(y, $, 1), O(g, $, 1), O(R, $, 0.5), O(g, $, 1), O(M, $, 1));
              else
                te ? (ee ? (O(d, q, 1), O(v, q, 0), O(b, $, 0), O(d, q, 1), O(b, $, 0), O(m, $, 1)) : (O(d, q, 1), O(v, q, 0), O(b, $, 1), O(v, q, 0), O(m, $, 0), O(b, $, 1)), ee ? S.copy(b) : M.copy(b)) : ee ? (O(T, $, 0), O(b, $, 0), O(R, $, 0.5), O(R, $, 0.5), O(b, $, 0), O(S, $, 0)) : (O(P, $, 1), O(b, $, 1), O(R, $, 0.5), O(R, $, 0.5), O(b, $, 1), O(M, $, 1)), oe = !0;
              break;
          }
        } else
          E();
      } else
        E();
      !I && j === _ - 1 && W(e[0], w, x, ee, !0, q), q = $, z = R, v.copy(S), d.copy(M);
    }
    if (!I)
      W(R, T, P, ee, !1, $);
    else if (te && i) {
      let j = b, J = m;
      de !== ee && (j = m, J = b), ee ? (oe || de) && (J.toArray(i, 0 * 3), J.toArray(i, 3 * 3), oe && j.toArray(i, 1 * 3)) : (oe || !de) && (J.toArray(i, 1 * 3), J.toArray(i, 3 * 3), oe && j.toArray(i, 0 * 3));
    }
    return xe;
    function L(j, J, ne) {
      return ne.subVectors(J, j), ne.set(-ne.y, ne.x).normalize();
    }
    function O(j, J, ne) {
      i && (i[C] = j.x, i[C + 1] = j.y, i[C + 2] = 0, r && (r[C] = 0, r[C + 1] = 0, r[C + 2] = 1), C += 3, a && (a[B] = J, a[B + 1] = ne, B += 2)), xe += 3;
    }
    function N(j, J, ne, se, V) {
      c.copy(J).sub(j).normalize(), u.copy(ne).sub(j).normalize();
      let F = Math.PI;
      const re = c.dot(u);
      Math.abs(re) < 1 && (F = Math.abs(Math.acos(re))), F /= n, h.copy(J);
      for (let fe = 0, Me = n - 1; fe < Me; fe++)
        f.copy(h).rotateAround(j, F), O(h, se, V), O(f, se, V), O(j, se, 0.5), h.copy(f);
      O(f, se, V), O(ne, se, V), O(j, se, 0.5);
    }
    function E() {
      O(d, q, 1), O(v, q, 0), O(T, $, 0), O(d, q, 1), O(T, $, 0), O(P, $, 1);
    }
    function A(j, J, ne) {
      J ? j ? (O(d, q, 1), O(v, q, 0), O(T, $, 0), O(d, q, 1), O(T, $, 0), O(m, $, 1), O(T, ne, 0), O(S, ne, 0), O(m, ne, 0.5)) : (O(d, q, 1), O(v, q, 0), O(P, $, 1), O(v, q, 0), O(m, $, 0), O(P, $, 1), O(P, ne, 1), O(m, ne, 0), O(M, ne, 1)) : j ? (O(T, ne, 0), O(S, ne, 0), O(R, ne, 0.5)) : (O(P, ne, 1), O(M, ne, 0), O(R, ne, 0.5));
    }
    function D(j, J) {
      J && (j ? (O(d, q, 1), O(v, q, 0), O(T, $, 0), O(d, q, 1), O(T, $, 0), O(m, $, 1), O(T, q, 0), O(R, $, 0.5), O(m, $, 1), O(R, $, 0.5), O(S, q, 0), O(m, $, 1)) : (O(d, q, 1), O(v, q, 0), O(P, $, 1), O(v, q, 0), O(m, $, 0), O(P, $, 1), O(P, q, 1), O(m, $, 0), O(R, $, 0.5), O(R, $, 0.5), O(m, $, 0), O(M, q, 1)));
    }
    function W(j, J, ne, se, V, F) {
      switch (t.strokeLineCap) {
        case "round":
          V ? N(j, ne, J, F, 0.5) : N(j, J, ne, F, 0.5);
          break;
        case "square":
          if (V)
            c.subVectors(J, j), u.set(c.y, -c.x), h.addVectors(c, u).add(j), f.subVectors(u, c).add(j), se ? (h.toArray(i, 1 * 3), f.toArray(i, 0 * 3), f.toArray(i, 3 * 3)) : (h.toArray(i, 1 * 3), a[3 * 2 + 1] === 1 ? f.toArray(i, 3 * 3) : h.toArray(i, 3 * 3), f.toArray(i, 0 * 3));
          else {
            c.subVectors(ne, j), u.set(c.y, -c.x), h.addVectors(c, u).add(j), f.subVectors(u, c).add(j);
            const re = i.length;
            se ? (h.toArray(i, re - 1 * 3), f.toArray(i, re - 2 * 3), f.toArray(i, re - 4 * 3)) : (f.toArray(i, re - 2 * 3), h.toArray(i, re - 1 * 3), f.toArray(i, re - 4 * 3));
          }
          break;
      }
    }
    function Y(j) {
      let J = !1;
      for (let se = 1, V = j.length - 1; se < V; se++)
        if (j[se].distanceTo(j[se + 1]) < s) {
          J = !0;
          break;
        }
      if (!J)
        return j;
      const ne = [];
      ne.push(j[0]);
      for (let se = 1, V = j.length - 1; se < V; se++)
        j[se].distanceTo(j[se + 1]) >= s && ne.push(j[se]);
      return ne.push(j[j.length - 1]), ne;
    }
  }
}
const Oi = /* @__PURE__ */ new WeakMap();
class Sh extends Es {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, s) {
    const i = new Fn(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (r) => {
        const a = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(r, a).then(t).catch(s);
      },
      n,
      s
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, n, s) {
    const i = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!n
    };
    this.decodeGeometry(e, i).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const c = t.attributeTypes[l];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
    }
    const n = JSON.stringify(t);
    if (Oi.has(e)) {
      const l = Oi.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const i = this.workerNextTaskID++, r = e.byteLength, a = this._getWorker(i, r).then((l) => (s = l, new Promise((c, u) => {
      s._callbacks[i] = { resolve: c, reject: u }, s.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return a.catch(() => !0).then(() => {
      s && i && this._releaseTask(s, i);
    }), Oi.set(e, {
      key: n,
      promise: a
    }), a;
  }
  _createGeometry(e) {
    const t = new at();
    e.index && t.setIndex(new mt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const s = e.attributes[n], i = s.name, r = s.array, a = s.itemSize;
      t.setAttribute(i, new mt(r, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new Fn(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, i) => {
      n.load(e, s, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const s = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const i = Mh.toString(), r = [
        "/* draco decoder */",
        s,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([r]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: "init", decoderConfig: this.decoderConfig }), s.onmessage = function(i) {
          const r = i.data;
          switch (r.type) {
            case "decode":
              s._callbacks[r.id].resolve(r);
              break;
            case "error":
              s._callbacks[r.id].reject(r);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
          }
        }, this.workerPool.push(s);
      } else
        this.workerPool.sort(function(s, i) {
          return s._taskLoad > i._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function Mh() {
  let o, e;
  onmessage = function(r) {
    const a = r.data;
    switch (a.type) {
      case "init":
        o = a.decoderConfig, e = new Promise(function(u) {
          o.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(o);
        });
        break;
      case "decode":
        const l = a.buffer, c = a.taskConfig;
        e.then((u) => {
          const h = u.draco, f = new h.Decoder(), p = new h.DecoderBuffer();
          p.Init(new Int8Array(l), l.byteLength);
          try {
            const y = t(h, f, p, c), g = y.attributes.map((v) => v.array.buffer);
            y.index && g.push(y.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: y }, g);
          } catch (y) {
            console.error(y), self.postMessage({ type: "error", id: a.id, error: y.message });
          } finally {
            h.destroy(p), h.destroy(f);
          }
        });
        break;
    }
  };
  function t(r, a, l, c) {
    const u = c.attributeIDs, h = c.attributeTypes;
    let f, p;
    const y = a.GetEncodedGeometryType(l);
    if (y === r.TRIANGULAR_MESH)
      f = new r.Mesh(), p = a.DecodeBufferToMesh(l, f);
    else if (y === r.POINT_CLOUD)
      f = new r.PointCloud(), p = a.DecodeBufferToPointCloud(l, f);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!p.ok() || f.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + p.error_msg());
    const g = { index: null, attributes: [] };
    for (const v in u) {
      const d = self[h[v]];
      let w, x;
      if (c.useUniqueIDs)
        x = u[v], w = a.GetAttributeByUniqueId(f, x);
      else {
        if (x = a.GetAttributeId(f, r[u[v]]), x === -1)
          continue;
        w = a.GetAttribute(f, x);
      }
      g.attributes.push(s(r, a, f, v, d, w));
    }
    return y === r.TRIANGULAR_MESH && (g.index = n(r, a, f)), r.destroy(f), g;
  }
  function n(r, a, l) {
    const u = l.num_faces() * 3, h = u * 4, f = r._malloc(h);
    a.GetTrianglesUInt32Array(l, h, f);
    const p = new Uint32Array(r.HEAPF32.buffer, f, u).slice();
    return r._free(f), { array: p, itemSize: 1 };
  }
  function s(r, a, l, c, u, h) {
    const f = h.num_components(), y = l.num_points() * f, g = y * u.BYTES_PER_ELEMENT, v = i(r, u), d = r._malloc(g);
    a.GetAttributeDataArrayForAllPoints(l, h, v, g, d);
    const w = new u(r.HEAPF32.buffer, d, y).slice();
    return r._free(d), {
      name: c,
      array: w,
      itemSize: f
    };
  }
  function i(r, a) {
    switch (a) {
      case Float32Array:
        return r.DT_FLOAT32;
      case Int8Array:
        return r.DT_INT8;
      case Int16Array:
        return r.DT_INT16;
      case Int32Array:
        return r.DT_INT32;
      case Uint8Array:
        return r.DT_UINT8;
      case Uint16Array:
        return r.DT_UINT16;
      case Uint32Array:
        return r.DT_UINT32;
    }
  }
}
class Va extends Ie {
  constructor(e, t) {
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new at();
    s.setAttribute("position", new rt(n, 3)), s.computeBoundingSphere();
    const i = new ts({ fog: !1 });
    super(s, i), this.light = e, this.color = t, this.type = "RectAreaLightHelper";
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new at();
    a.setAttribute("position", new rt(r, 3)), a.computeBoundingSphere(), this.add(new le(a, new Zt({ side: va, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const e = this.material.color, t = Math.max(e.r, e.g, e.b);
      t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const Ah = ["args", "center"], rg = /* @__PURE__ */ me({
  __name: "Text3D",
  props: {
    font: {},
    text: {},
    size: { default: 0.5 },
    height: { default: 0.2 },
    curveSegments: { default: 5 },
    bevelEnabled: { type: Boolean, default: !0 },
    bevelThickness: { default: 0.05 },
    bevelSize: { default: 0.02 },
    bevelOffset: { default: 0 },
    bevelSegments: { default: 4 },
    center: { type: Boolean, default: !1 },
    needUpdates: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, {
      center: i,
      font: r,
      text: a,
      needUpdates: l,
      size: c,
      height: u,
      curveSegments: h,
      bevelEnabled: f,
      bevelThickness: p,
      bevelSize: y,
      bevelOffset: g,
      bevelSegments: v
    } = Oe(s), { extend: d } = ke();
    d({ TextGeometry: io });
    const w = new wh(), x = br(), T = Fe(() => {
      var m;
      return a != null && a.value ? a.value : x.default ? (m = x.default()[0].children) == null ? void 0 : m.trim() : l.value ? "" : "TresJS";
    }), P = pe();
    e({
      value: P
    });
    const S = ([t, n] = Bn(() => new Promise((m, b) => {
      try {
        typeof r.value == "string" ? w.load(r.value, (_) => {
          m(_);
        }) : m(r.value);
      } catch (_) {
        b(console.error("cientos", _));
      }
    })), t = await t, n(), t), M = Fe(() => ({
      font: S,
      size: on(c),
      height: on(u),
      curveSegments: on(h),
      bevelEnabled: on(f),
      bevelThickness: on(p),
      bevelSize: on(y),
      bevelOffset: on(g),
      bevelSegments: on(v)
    }));
    return ut(() => {
      P.value && l.value && (P.value.geometry.dispose(), P.value.geometry = new io(T.value, M.value), i.value && P.value.geometry.center());
    }), (m, b) => H(r) ? (ce(), ue("TresMesh", {
      key: 0,
      ref_key: "text3DRef",
      ref: P
    }, [
      T.value ? (ce(), ue("TresTextGeometry", {
        key: 0,
        args: [T.value, M.value],
        center: H(i)
      }, null, 8, Ah)) : jt("", !0),
      Ve(m.$slots, "default")
    ], 512)) : jt("", !0);
  }
});
function og(o, e) {
  const t = he(e), n = new Ul(t.value), s = Ta({});
  o.forEach((r) => {
    const a = n.clipAction(r, t.value);
    s[r.name] = a;
  });
  const { onLoop: i } = qe();
  return i(({ delta: r }) => {
    n.update(r);
  }), {
    actions: s,
    mixer: n
  };
}
const ag = /* @__PURE__ */ me({
  __name: "Levioso",
  props: {
    speed: { default: 1 },
    rotationFactor: { default: 1 },
    floatFactor: { default: 1 },
    range: { default: () => [-0.1, 0.1] }
  },
  setup(o, { expose: e }) {
    const t = o, n = pe();
    e({
      value: n
    });
    {
      const l = Math.random() * 1e4, { onLoop: c } = qe();
      let u = l;
      c(({ delta: h }) => {
        if (!n.value)
          return;
        u += h * t.speed;
        const f = u * 0.25, p = n.value;
        p.rotation.x = Math.cos(f) * 0.125 * t.rotationFactor, p.rotation.y = Math.sin(f) * 0.125 * t.rotationFactor, p.rotation.z = Math.sin(f) * 0.05 * t.rotationFactor, p.position.y = Ze.mapLinear(Math.sin(f), -1, 1, t.range[0], t.range[1]) * t.floatFactor;
      });
    }
    return (s, i) => (ce(), ue("TresGroup", We(s.$attrs, {
      ref_key: "groupRef",
      ref: n
    }), [
      Ve(s.$slots, "default")
    ], 16));
  }
});
class Ts extends le {
  constructor(e, t = {}) {
    super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new St();
    const n = this, s = t.color !== void 0 ? new Re(t.color) : new Re(8355711), i = t.textureWidth || 512, r = t.textureHeight || 512, a = t.clipBias || 0, l = t.shader || Ts.ReflectorShader, c = t.multisample !== void 0 ? t.multisample : 4, u = new hi(), h = new Z(), f = new Z(), p = new Z(), y = new Pe(), g = new Z(0, 0, -1), v = new lt(), d = new Z(), w = new Z(), x = new lt(), T = new Pe(), P = this.camera, S = new Tn(i, r, { samples: c, type: Qt }), M = new Dt({
      name: l.name !== void 0 ? l.name : "unspecified",
      uniforms: ns.clone(l.uniforms),
      fragmentShader: l.fragmentShader,
      vertexShader: l.vertexShader
    });
    M.uniforms.tDiffuse.value = S.texture, M.uniforms.color.value = s, M.uniforms.textureMatrix.value = T, this.material = M, this.onBeforeRender = function(m, b, _) {
      if (f.setFromMatrixPosition(n.matrixWorld), p.setFromMatrixPosition(_.matrixWorld), y.extractRotation(n.matrixWorld), h.set(0, 0, 1), h.applyMatrix4(y), d.subVectors(f, p), d.dot(h) > 0)
        return;
      d.reflect(h).negate(), d.add(f), y.extractRotation(_.matrixWorld), g.set(0, 0, -1), g.applyMatrix4(y), g.add(p), w.subVectors(f, g), w.reflect(h).negate(), w.add(f), P.position.copy(d), P.up.set(0, 1, 0), P.up.applyMatrix4(y), P.up.reflect(h), P.lookAt(w), P.far = _.far, P.updateMatrixWorld(), P.projectionMatrix.copy(_.projectionMatrix), T.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), T.multiply(P.projectionMatrix), T.multiply(P.matrixWorldInverse), T.multiply(n.matrixWorld), u.setFromNormalAndCoplanarPoint(h, f), u.applyMatrix4(P.matrixWorldInverse), v.set(u.normal.x, u.normal.y, u.normal.z, u.constant);
      const I = P.projectionMatrix;
      x.x = (Math.sign(v.x) + I.elements[8]) / I.elements[0], x.y = (Math.sign(v.y) + I.elements[9]) / I.elements[5], x.z = -1, x.w = (1 + I.elements[10]) / I.elements[14], v.multiplyScalar(2 / v.dot(x)), I.elements[2] = v.x, I.elements[6] = v.y, I.elements[10] = v.z + 1 - a, I.elements[14] = v.w, n.visible = !1;
      const R = m.getRenderTarget(), z = m.xr.enabled, k = m.shadowMap.autoUpdate;
      m.xr.enabled = !1, m.shadowMap.autoUpdate = !1, m.setRenderTarget(S), m.state.buffers.depth.setMask(!0), m.autoClear === !1 && m.clear(), m.render(b, P), m.xr.enabled = z, m.shadowMap.autoUpdate = k, m.setRenderTarget(R);
      const G = _.viewport;
      G !== void 0 && m.state.viewport(G), n.visible = !0;
    }, this.getRenderTarget = function() {
      return S;
    }, this.dispose = function() {
      S.dispose(), n.material.dispose();
    };
  }
}
Ts.ReflectorShader = {
  name: "ReflectorShader",
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const Ph = ["args", "material-uniforms-color-value"], Ch = /* @__PURE__ */ _e("TresPlaneGeometry", { args: [5, 5] }, null, -1), lg = /* @__PURE__ */ me({
  __name: "Reflector",
  props: {
    color: { default: "#333" },
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    clipBias: { default: 0 },
    multisample: { default: 4 },
    shader: { default: Ts.ReflectorShader }
  },
  setup(o, { expose: e }) {
    const t = o, { extend: n } = ke(), s = pe();
    n({ Reflector: Ts });
    const { color: i, textureWidth: r, textureHeight: a, clipBias: l, multisample: c, shader: u } = Oe(t);
    return e({
      reflectorRef: s
    }), (h, f) => (ce(), ue("TresReflector", {
      ref_key: "reflectorRef",
      ref: s,
      args: [void 0, { textureWidth: H(r), textureHeight: H(a), clipBias: H(l), multisample: H(c), shader: H(u) }],
      "material-uniforms-color-value": H(i)
    }, [
      Ve(h.$slots, "default", {}, () => [
        Ch
      ])
    ], 8, Ph));
  }
});
function Cr(o) {
  return uc() ? (hc(o), !0) : !1;
}
function vt(o) {
  return typeof o == "function" ? o() : H(o);
}
const Ih = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Rh = Object.prototype.toString, Dh = (o) => Rh.call(o) === "[object Object]", kn = () => {
};
function Ir(o, e) {
  function t(...n) {
    return new Promise((s, i) => {
      Promise.resolve(o(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(s).catch(i);
    });
  }
  return t;
}
const Oh = (o) => o();
function Lh(o, e = {}) {
  let t, n, s = kn;
  const i = (a) => {
    clearTimeout(a), s(), s = kn;
  };
  return (a) => {
    const l = vt(o), c = vt(e.maxWait);
    return t && i(t), l <= 0 || c !== void 0 && c <= 0 ? (n && (i(n), n = null), Promise.resolve(a())) : new Promise((u, h) => {
      s = e.rejectOnCancel ? h : u, c && !n && (n = setTimeout(() => {
        t && i(t), n = null, u(a());
      }, c)), t = setTimeout(() => {
        n && i(n), n = null, u(a());
      }, l);
    });
  };
}
function Ya(...o) {
  let e = 0, t, n = !0, s = kn, i, r, a, l, c;
  !oi(o[0]) && typeof o[0] == "object" ? { delay: r, trailing: a = !0, leading: l = !0, rejectOnCancel: c = !1 } = o[0] : [r, a = !0, l = !0, c = !1] = o;
  const u = () => {
    t && (clearTimeout(t), t = void 0, s(), s = kn);
  };
  return (f) => {
    const p = vt(r), y = Date.now() - e, g = () => i = f();
    return u(), p <= 0 ? (e = Date.now(), g()) : (y > p && (l || !n) ? (e = Date.now(), g()) : a && (i = new Promise((v, d) => {
      s = c ? d : v, t = setTimeout(() => {
        e = Date.now(), n = !0, v(g()), u();
      }, Math.max(0, p - y));
    })), !l && !t && (t = setTimeout(() => n = !0, p)), n = !1, i);
  };
}
function Fh(o) {
  return ba();
}
function kh(o, e = 200, t = {}) {
  return Ir(
    Lh(e, t),
    o
  );
}
function Bh(o, e = 200, t = !1, n = !0, s = !1) {
  return Ir(
    Ya(e, t, n, s),
    o
  );
}
function Uh(o, e, t = {}) {
  const {
    eventFilter: n = Oh,
    ...s
  } = t;
  return ve(
    o,
    Ir(
      n,
      e
    ),
    s
  );
}
function Rr(o, e = !0, t) {
  Fh() ? En(o, t) : e ? o() : Er(o);
}
function Nh(o, e, t = {}) {
  const {
    throttle: n = 0,
    trailing: s = !0,
    leading: i = !0,
    ...r
  } = t;
  return Uh(
    o,
    e,
    {
      ...r,
      eventFilter: Ya(n, s, i)
    }
  );
}
function _n(o) {
  var e;
  const t = vt(o);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const en = Ih ? window : void 0;
function Ye(...o) {
  let e, t, n, s;
  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([t, n, s] = o, e = en) : [e, t, n, s] = o, !e)
    return kn;
  Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);
  const i = [], r = () => {
    i.forEach((u) => u()), i.length = 0;
  }, a = (u, h, f, p) => (u.addEventListener(h, f, p), () => u.removeEventListener(h, f, p)), l = ve(
    () => [_n(e), vt(s)],
    ([u, h]) => {
      if (r(), !u)
        return;
      const f = Dh(h) ? { ...h } : h;
      i.push(
        ...t.flatMap((p) => n.map((y) => a(u, p, y, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), r();
  };
  return Cr(c), c;
}
function zh(o) {
  return typeof o == "function" ? o : typeof o == "string" ? (e) => e.key === o : Array.isArray(o) ? (e) => o.includes(e.key) : () => !0;
}
function An(...o) {
  let e, t, n = {};
  o.length === 3 ? (e = o[0], t = o[1], n = o[2]) : o.length === 2 ? typeof o[1] == "object" ? (e = !0, t = o[0], n = o[1]) : (e = o[0], t = o[1]) : (e = !0, t = o[0]);
  const {
    target: s = en,
    eventName: i = "keydown",
    passive: r = !1,
    dedupe: a = !1
  } = n, l = zh(e);
  return Ye(s, i, (u) => {
    u.repeat && vt(a) || l(u) && t(u);
  }, r);
}
function Hh() {
  const o = he(!1), e = ba();
  return e && En(() => {
    o.value = !0;
  }, e), o;
}
function Wa(o) {
  const e = Hh();
  return Fe(() => (e.value, !!o()));
}
function jh(o, e = {}) {
  const { window: t = en } = e, n = Wa(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let s;
  const i = he(!1), r = (c) => {
    i.value = c.matches;
  }, a = () => {
    s && ("removeEventListener" in s ? s.removeEventListener("change", r) : s.removeListener(r));
  }, l = ut(() => {
    n.value && (a(), s = t.matchMedia(vt(o)), "addEventListener" in s ? s.addEventListener("change", r) : s.addListener(r), i.value = s.matches);
  });
  return Cr(() => {
    l(), a(), s = void 0;
  }), i;
}
function Gh(o, e, t = {}) {
  const { window: n = en, ...s } = t;
  let i;
  const r = Wa(() => n && "ResizeObserver" in n), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = Fe(() => Array.isArray(o) ? o.map((h) => _n(h)) : [_n(o)]), c = ve(
    l,
    (h) => {
      if (a(), r.value && n) {
        i = new ResizeObserver(e);
        for (const f of h)
          f && i.observe(f, s);
      }
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    a(), c();
  };
  return Cr(u), {
    isSupported: r,
    stop: u
  };
}
function Vh(o, e = { width: 0, height: 0 }, t = {}) {
  const { window: n = en, box: s = "content-box" } = t, i = Fe(() => {
    var h, f;
    return (f = (h = _n(o)) == null ? void 0 : h.namespaceURI) == null ? void 0 : f.includes("svg");
  }), r = he(e.width), a = he(e.height), { stop: l } = Gh(
    o,
    ([h]) => {
      const f = s === "border-box" ? h.borderBoxSize : s === "content-box" ? h.contentBoxSize : h.devicePixelContentBoxSize;
      if (n && i.value) {
        const p = _n(o);
        if (p) {
          const y = n.getComputedStyle(p);
          r.value = Number.parseFloat(y.width), a.value = Number.parseFloat(y.height);
        }
      } else if (f) {
        const p = Array.isArray(f) ? f : [f];
        r.value = p.reduce((y, { inlineSize: g }) => y + g, 0), a.value = p.reduce((y, { blockSize: g }) => y + g, 0);
      } else
        r.value = h.contentRect.width, a.value = h.contentRect.height;
    },
    t
  );
  Rr(() => {
    const h = _n(o);
    h && (r.value = "offsetWidth" in h ? h.offsetWidth : e.width, a.value = "offsetHeight" in h ? h.offsetHeight : e.height);
  });
  const c = ve(
    () => _n(o),
    (h) => {
      r.value = h ? e.width : 0, a.value = h ? e.height : 0;
    }
  );
  function u() {
    l(), c();
  }
  return {
    width: r,
    height: a,
    stop: u
  };
}
const uo = 1;
function Yh(o, e = {}) {
  const {
    throttle: t = 0,
    idle: n = 200,
    onStop: s = kn,
    onScroll: i = kn,
    offset: r = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: a = {
      capture: !1,
      passive: !0
    },
    behavior: l = "auto",
    window: c = en,
    onError: u = (M) => {
      console.error(M);
    }
  } = e, h = he(0), f = he(0), p = Fe({
    get() {
      return h.value;
    },
    set(M) {
      g(M, void 0);
    }
  }), y = Fe({
    get() {
      return f.value;
    },
    set(M) {
      g(void 0, M);
    }
  });
  function g(M, m) {
    var b, _, I;
    if (!c)
      return;
    const R = vt(o);
    R && ((I = R instanceof Document ? c.document.body : R) == null || I.scrollTo({
      top: (b = vt(m)) != null ? b : y.value,
      left: (_ = vt(M)) != null ? _ : p.value,
      behavior: vt(l)
    }));
  }
  const v = he(!1), d = or({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), w = or({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), x = (M) => {
    v.value && (v.value = !1, w.left = !1, w.right = !1, w.top = !1, w.bottom = !1, s(M));
  }, T = kh(x, t + n), P = (M) => {
    var m;
    if (!c)
      return;
    const b = ((m = M == null ? void 0 : M.document) == null ? void 0 : m.documentElement) || (M == null ? void 0 : M.documentElement) || _n(M), { display: _, flexDirection: I } = getComputedStyle(b), R = b.scrollLeft;
    w.left = R < h.value, w.right = R > h.value;
    const z = Math.abs(R) <= (r.left || 0), k = Math.abs(R) + b.clientWidth >= b.scrollWidth - (r.right || 0) - uo;
    _ === "flex" && I === "row-reverse" ? (d.left = k, d.right = z) : (d.left = z, d.right = k), h.value = R;
    let G = b.scrollTop;
    M === c.document && !G && (G = c.document.body.scrollTop), w.top = G < f.value, w.bottom = G > f.value;
    const U = Math.abs(G) <= (r.top || 0), q = Math.abs(G) + b.clientHeight >= b.scrollHeight - (r.bottom || 0) - uo;
    _ === "flex" && I === "column-reverse" ? (d.top = q, d.bottom = U) : (d.top = U, d.bottom = q), f.value = G;
  }, S = (M) => {
    var m;
    if (!c)
      return;
    const b = (m = M.target.documentElement) != null ? m : M.target;
    P(b), v.value = !0, T(M), i(M);
  };
  return Ye(
    o,
    "scroll",
    t ? Bh(S, t, !0, !1) : S,
    a
  ), Rr(() => {
    try {
      const M = vt(o);
      if (!M)
        return;
      P(M);
    } catch (M) {
      u(M);
    }
  }), Ye(
    o,
    "scrollend",
    x,
    a
  ), {
    x: p,
    y,
    isScrolling: v,
    arrivedState: d,
    directions: w,
    measure() {
      const M = vt(o);
      c && M && P(M);
    }
  };
}
const Wh = {
  page: (o) => [o.pageX, o.pageY],
  client: (o) => [o.clientX, o.clientY],
  screen: (o) => [o.screenX, o.screenY],
  movement: (o) => o instanceof Touch ? null : [o.movementX, o.movementY]
};
function Xh(o = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: n = !1,
    initialValue: s = { x: 0, y: 0 },
    window: i = en,
    target: r = i,
    scroll: a = !0,
    eventFilter: l
  } = o;
  let c = null;
  const u = he(s.x), h = he(s.y), f = he(null), p = typeof e == "function" ? e : Wh[e], y = (P) => {
    const S = p(P);
    c = P, S && ([u.value, h.value] = S, f.value = "mouse");
  }, g = (P) => {
    if (P.touches.length > 0) {
      const S = p(P.touches[0]);
      S && ([u.value, h.value] = S, f.value = "touch");
    }
  }, v = () => {
    if (!c || !i)
      return;
    const P = p(c);
    c instanceof MouseEvent && P && (u.value = P[0] + i.scrollX, h.value = P[1] + i.scrollY);
  }, d = () => {
    u.value = s.x, h.value = s.y;
  }, w = l ? (P) => l(() => y(P), {}) : (P) => y(P), x = l ? (P) => l(() => g(P), {}) : (P) => g(P), T = l ? () => l(() => v(), {}) : () => v();
  if (r) {
    const P = { passive: !0 };
    Ye(r, ["mousemove", "dragover"], w, P), t && e !== "movement" && (Ye(r, ["touchstart", "touchmove"], x, P), n && Ye(r, "touchend", d, P)), a && e === "page" && Ye(i, "scroll", T, { passive: !0 });
  }
  return {
    x: u,
    y: h,
    sourceType: f
  };
}
function $h(o = {}) {
  const { window: e = en, behavior: t = "auto" } = o;
  if (!e)
    return {
      x: he(0),
      y: he(0)
    };
  const n = he(e.scrollX), s = he(e.scrollY), i = Fe({
    get() {
      return n.value;
    },
    set(a) {
      scrollTo({ left: a, behavior: t });
    }
  }), r = Fe({
    get() {
      return s.value;
    },
    set(a) {
      scrollTo({ top: a, behavior: t });
    }
  });
  return Ye(
    e,
    "scroll",
    () => {
      n.value = e.scrollX, s.value = e.scrollY;
    },
    {
      capture: !1,
      passive: !0
    }
  ), { x: i, y: r };
}
function Xa(o = {}) {
  const {
    window: e = en,
    initialWidth: t = Number.POSITIVE_INFINITY,
    initialHeight: n = Number.POSITIVE_INFINITY,
    listenOrientation: s = !0,
    includeScrollbar: i = !0
  } = o, r = he(t), a = he(n), l = () => {
    e && (i ? (r.value = e.innerWidth, a.value = e.innerHeight) : (r.value = e.document.documentElement.clientWidth, a.value = e.document.documentElement.clientHeight));
  };
  if (l(), Rr(l), Ye("resize", l, { passive: !0 }), s) {
    const c = jh("(orientation: portrait)");
    ve(c, () => l());
  }
  return { width: r, height: a };
}
const cg = /* @__PURE__ */ me({
  __name: "MouseParallax",
  props: {
    disabled: { type: Boolean, default: !1 },
    factor: { default: 2.5 },
    ease: { default: 0.1 },
    local: { type: Boolean, default: !1 }
  },
  setup(o) {
    const e = o, { camera: t, renderer: n } = ke(), { disabled: s, factor: i, ease: r, local: a } = Oe(e), l = {};
    a.value && (l.target = n.value.domElement, l.type = "client");
    const { x: c, y: u } = Xh(l), { width: h, height: f } = a.value ? Vh(n.value.domElement) : Xa(), p = he(), y = Fe(() => (c.value / h.value - 0.5) * i.value), g = Fe(() => -(u.value / f.value - 0.5) * i.value), { onLoop: v } = qe();
    return v(({ delta: d }) => {
      s.value || !p.value || Number.isNaN(y.value) || Number.isNaN(g.value) || (p.value.position.x += (y.value - p.value.position.x) * r.value * d, p.value.position.y += (g.value - p.value.position.y) * r.value * d);
    }), ve(
      () => p.value,
      (d) => d == null ? void 0 : d.add(t.value)
    ), (d, w) => (ce(), ue("TresGroup", {
      ref_key: "cameraGroupRef",
      ref: p
    }, null, 512));
  }
}), ug = me({
  name: "GlobalAudio",
  props: [
    "src",
    "loop",
    "volume",
    "playbackRate",
    "playTrigger",
    "stopTrigger"
  ],
  async setup(o, { expose: e, emit: t }) {
    var h;
    const { camera: n, renderer: s } = ke(), i = new ya();
    (h = n.value) == null || h.add(i);
    const r = new Nl(i), a = new _a();
    e({ sound: r }), ct(() => {
      r && r.disconnect();
    }), ve(() => [o.playbackRate], () => r.setPlaybackRate(o.playbackRate ?? 1), { immediate: !0 }), ve(() => [o.volume], () => r.setVolume(o.volume ?? 0.5), { immediate: !0 }), ve(() => [o.loop], () => r.setLoop(o.loop ?? !1), { immediate: !0 }), ve(() => [o.src], async () => {
      const f = await a.loadAsync(o.src);
      r.setBuffer(f);
    }, { immediate: !0 });
    const c = document.getElementById(o.playTrigger ?? "") || s.value.domElement;
    Ye(c, "click", () => {
      r.isPlaying ? r.pause() : r.play(), t("isPlaying", r.isPlaying);
    });
    const u = document.getElementById(o.stopTrigger ?? "");
    return u && Ye(u, "click", () => {
      r.stop(), t("isPlaying", r.isPlaying);
    }), null;
  }
});
class bs extends le {
  constructor() {
    super(bs.Geometry, new Zt({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0;
    const e = new Z(), t = new Z(), n = new jr(16, 16), s = new jr(16, 16);
    let i = ir;
    const r = bs.Geometry, a = new wi({
      uniforms: {
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`
      ),
      depthTest: !0,
      depthWrite: !1,
      transparent: !1
    }), l = new wi({
      uniforms: {
        map: { value: n },
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`
      ),
      depthTest: !1,
      depthWrite: !1,
      transparent: !1
    }), c = new le(r, a), u = [], h = $a.Shader, f = new wi({
      name: h.name,
      uniforms: {
        map: { value: null },
        occlusionMap: { value: s },
        color: { value: new Re(16777215) },
        scale: { value: new ge() },
        screenPosition: { value: new Z() }
      },
      vertexShader: h.vertexShader,
      fragmentShader: h.fragmentShader,
      blending: Tr,
      transparent: !0,
      depthWrite: !1
    }), p = new le(r, f);
    this.addElement = function(w) {
      u.push(w);
    };
    const y = new ge(), g = new ge(), v = new ga(), d = new lt();
    this.onBeforeRender = function(w, x, T) {
      w.getCurrentViewport(d);
      const P = w.getRenderTarget(), S = P !== null ? P.texture.type : ir;
      i !== S && (n.dispose(), s.dispose(), n.type = s.type = S, i = S);
      const M = d.w / d.z, m = d.z / 2, b = d.w / 2;
      let _ = 16 / d.w;
      if (y.set(_ * M, _), v.min.set(d.x, d.y), v.max.set(d.x + (d.z - 16), d.y + (d.w - 16)), t.setFromMatrixPosition(this.matrixWorld), t.applyMatrix4(T.matrixWorldInverse), !(t.z > 0) && (e.copy(t).applyMatrix4(T.projectionMatrix), g.x = d.x + e.x * m + m - 8, g.y = d.y + e.y * b + b - 8, v.containsPoint(g))) {
        w.copyFramebufferToTexture(g, n);
        let I = a.uniforms;
        I.scale.value = y, I.screenPosition.value = e, w.renderBufferDirect(T, null, r, a, c, null), w.copyFramebufferToTexture(g, s), I = l.uniforms, I.scale.value = y, I.screenPosition.value = e, w.renderBufferDirect(T, null, r, l, c, null);
        const R = -e.x * 2, z = -e.y * 2;
        for (let k = 0, G = u.length; k < G; k++) {
          const U = u[k], q = f.uniforms;
          q.color.value.copy(U.color), q.map.value = U.texture, q.screenPosition.value.x = e.x + R * U.distance, q.screenPosition.value.y = e.y + z * U.distance, _ = U.size / d.w;
          const $ = d.w / d.z;
          q.scale.value.set(_ * $, _), f.uniformsNeedUpdate = !0, w.renderBufferDirect(T, null, r, f, p, null);
        }
      }
    }, this.dispose = function() {
      a.dispose(), l.dispose(), f.dispose(), n.dispose(), s.dispose();
      for (let w = 0, x = u.length; w < x; w++)
        u[w].texture.dispose();
    };
  }
}
class $a {
  constructor(e, t = 1, n = 0, s = new Re(16777215)) {
    this.texture = e, this.size = t, this.distance = n, this.color = s;
  }
}
$a.Shader = {
  name: "LensflareElementShader",
  uniforms: {
    map: { value: null },
    occlusionMap: { value: null },
    color: { value: null },
    scale: { value: null },
    screenPosition: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
  )
};
bs.Geometry = function() {
  const o = new at(), e = new Float32Array([
    -1,
    -1,
    0,
    0,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    -1,
    1,
    0,
    0,
    1
  ]), t = new wr(e, 5);
  return o.setIndex([0, 1, 2, 0, 2, 3]), o.setAttribute("position", new Kt(t, 3, 0, !1)), o.setAttribute("uv", new Kt(t, 2, 3, !1)), o;
}();
function Zh(o) {
  return o;
}
function qh(o) {
  return o * o * o;
}
function Kh(o) {
  return o < 0.5 ? 4 * o * o * o : 1 - (-2 * o + 2) ** 3 / 2;
}
function Qh(o) {
  return o * o * o * o;
}
function Jh(o) {
  return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
}
const ho = Ze.clamp;
class fo {
  /**
   * Create a new seeded pseudorandom number generator.
   * @param [seed] - the seed for the generator
   * @param [getSeededRandomGenerator] - a function that returns a pseudorandom number generator
   * @constructor
   */
  constructor(e = 0, t) {
    ae(this, "_getNext");
    ae(this, "_getGenerator");
    this._getGenerator = t ?? this.getMulberry32, this._getNext = this._getGenerator(e);
  }
  /**
   * Reseed the pseudorandom number generator
   */
  seed(e) {
    this._getNext = this._getGenerator(e);
  }
  /**
   * Return the next pseudorandom number in the interval [0, 1]
   */
  rand() {
    return this._getNext();
  }
  /**
   * Random float from <low, high> interval
   * @param low - Low value of the interval
   * @param high - High value of the interval
   */
  float(e, t) {
    return e + this._getNext() * (t - e);
  }
  /**
   * Random float from <-range/2, range/2> interval
   * @param range - Interval range
   */
  floatSpread(e) {
    return this.float(-0.5 * e, 0.5 * e);
  }
  /**
   * Random integer from <low, high> interval
   * @param low Low value of the interval
   * @param high High value of the interval
   */
  int(e, t) {
    return e + Math.floor(this._getNext() * (t - e + 1));
  }
  /**
   * Choose an element from an array.
   * @param array The array to choose from
   * @returns An element from the array or null if the array is empty
   */
  choice(e) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : null;
  }
  /**
   * Choose an element from an array or return defaultValue if array is empty.
   * @param array The array to choose from
   * @param defaultValue The value to return if the array is empty
   * @returns An element from the array or defaultValue if the array is empty
   */
  defaultChoice(e, t) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : t;
  }
  /**
   * Return n elements from an array.
   * @param array The array to sample
   * @param sampleSizeMin The minimum sample size
   * @param sampleSizeMax The maximum sample size
   */
  sample(e, t, n) {
    const s = e.length;
    t = ho(t, 0, s - 1), n = ho(n ?? s - 1, 0, s - 1);
    const i = this.int(t, n), r = this.shuffle(e.map((l, c) => c)), a = Math.min(e.length, i);
    return r.slice(0, a).sort().map((l) => e[l]);
  }
  /**
   * Shuffle an array. Not in-place.
   * @param array The array to shuffle
   */
  shuffle(e) {
    return e.map((t) => ({ value: t, sort: this._getNext() })).sort((t, n) => t.sort - n.sort).map(({ value: t }) => t);
  }
  /**
   * The default pseudorandom generator.
   */
  getMulberry32(e = 0) {
    return e > 0 && e < 1 && (e = Math.floor(e * 2 ** 16)), () => {
      e += 1831565813;
      let t = e;
      return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
}
const tn = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/", Dr = `${tn}circle.png`, di = `${tn}circleBlur.png`, ef = `${tn}circleRainbow.png`, tf = `${tn}line.png`, Za = `${tn}poly6.png`, qa = `${tn}polyStroke6.png`, nf = `${tn}rays.png`, pi = `${tn}ring.png`, sf = `${tn}starThin6.png`, rf = {
  texture: [tf, pi],
  color: ["white"],
  distance: [0, 0],
  size: [750, 1024],
  length: [0, 2]
}, of = {
  texture: [di],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, af = {
  texture: [nf],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, lf = {
  texture: [Dr, ef, pi, sf],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [2, 3]
}, [Ka, Qa] = [3679071, 132442], cf = {
  texture: [di, Dr, pi, Za, qa],
  color: ["dimgray", "gray", "darkgray", Ka, Qa],
  distance: [0.5, 2.5],
  size: [20, 180],
  length: [5, 21]
}, uf = {
  texture: [di, Dr, pi, Za, qa],
  color: ["dimgray", "gray", "darkgray", Ka, Qa],
  distance: [-0.6, -0.1],
  size: [180, 360],
  length: [0, 5]
}, fr = [rf, of, af, lf, cf, uf], li = {
  color: "white",
  distance: 0,
  size: 512,
  texture: di
}, hf = [
  Zh,
  qh,
  Kh,
  Qh,
  Jh
], po = Ze.lerp, mo = (o = 0, e = fr) => {
  const n = new fo(o).choice(hf);
  return e.map((s, i) => {
    const r = new fo(
      o * (i * 7907 + 1) + (typeof s.seed == "number" ? s.seed : 0)
    ), a = r.int(s.length[0], s.length[1]);
    return Array.from({ length: a }).fill(0).map(() => {
      const l = n(r.rand());
      return {
        texture: r.defaultChoice(
          s.texture,
          li.texture
        ),
        size: po(s.size[0], s.size[1], n(1 - l)),
        distance: po(s.distance[0], s.distance[1], l),
        color: r.defaultChoice(
          s.color,
          li.color
        )
      };
    });
  }).flat();
}, go = (o, e, t = void 0, n = void 0, s = li) => {
  if (o !== void 0 && o.length > 0 && (typeof t == "number" || typeof n < "u")) {
    const a = mo(t ?? 0, n ?? fr), l = a.length, c = o.length;
    return l >= c ? a.map(
      (u, h) => Object.assign(u, e, h < c ? o[h] : {})
    ) : o.map(
      (u, h) => Object.assign({}, s, h < l ? a[h] : {}, e, u)
    );
  }
  if (o !== void 0 && o.length > 0) {
    const a = Object.assign({}, s, e);
    return o.map((l) => Object.assign({}, a, l));
  }
  const i = n === void 0 || n.length === 0 ? fr : n;
  return mo(t ?? 0, i).map((a) => Object.assign({}, a, e));
};
function ff(o) {
  return df(o, (e, t) => t in li && e !== void 0);
}
function df(o, e) {
  const t = {};
  return Object.keys(o).forEach((n) => {
    e(o[n], n) && (t[n] = o[n]);
  }), t;
}
const hg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    scale: { default: 1 },
    elements: { default: void 0 },
    seed: { default: void 0 },
    seedProps: { default: void 0 },
    color: { default: void 0 },
    distance: { default: void 0 },
    size: { default: void 0 },
    texture: { default: void 0 }
  },
  setup(o, { expose: e }) {
    const t = o, n = pe(), s = pe([]), i = pe(ff(t));
    e({
      value: n
    });
    const r = new xr(), a = new bs(), l = [], c = () => {
      var p, y, g;
      for (; l.length; )
        l.pop();
      (p = n.value) == null || p.children.forEach((v) => {
        "dispose" in v && v.dispose();
      }), (y = n.value) == null || y.remove(...n.value.children), (g = n.value) == null || g.dispose();
    }, u = (p) => {
      if (typeof p.texture == "string") {
        const y = p.texture;
        p.texture = r.load(y), p.texture.name = y;
      }
      return p.color = gn(p.color), p;
    }, h = () => {
      for (let p = s.value.length - 1; p < l.length; p++)
        l[p].size = 0;
      s.value.forEach((p, y) => {
        l[y].size = p.size * t.scale;
      });
    }, f = () => {
      for (; s.value.length > l.length; ) {
        const y = { ...u(s.value[l.length]) };
        l.push(y), a.addElement(y);
      }
      s.value.forEach((p, y) => {
        const g = l[y], { texture: v, size: d, distance: w, color: x } = p;
        if (typeof v == "string") {
          if (g.texture.name !== v) {
            g.texture.dispose();
            const T = v;
            g.texture = r.load(T), g.texture.name = T;
          }
        } else
          g.texture !== v && (g.texture.dispose(), g.texture = v);
        g.size = d, g.distance = w, g.color = gn(x);
      }), h();
    };
    return ct(() => {
      c();
    }), En(() => {
      var p;
      (p = n.value) == null || p.add(a), s.value = go(t.elements, i.value, t.seed, t.seedProps);
    }), ve(() => [t.color, t.distance, t.size, t.texture], () => {
      i.value = {
        color: t.color,
        distance: t.distance,
        size: t.size,
        texture: t.texture
      };
    }), ve(() => [i.value, t.elements, t.seed, t.seedProps], () => {
      s.value = go(t.elements, i.value, t.seed, t.seedProps);
    }), ve(() => t.scale, () => {
      h();
    }), ve(() => s.value, () => {
      f();
    }), (p, y) => (ce(), ue("TresGroup", {
      ref_key: "lensflareRef",
      ref: n
    }, null, 512));
  }
});
function pf(o) {
  const e = he(null), { height: t, width: n, settings: s, depth: i } = fc(o) ? Oe(o) : Oe(or(o)), { onLoop: r } = qe(), { camera: a, renderer: l, scene: c, sizes: u } = ke();
  return ut(() => {
    var h;
    (h = e.value) == null || h.dispose(), e.value = new Tn((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {
      minFilter: Ot,
      magFilter: Ot,
      type: Qt,
      ...s == null ? void 0 : s.value
    }), i != null && i.value && (e.value.depthTexture = new xa(
      (n == null ? void 0 : n.value) || u.width.value,
      (t == null ? void 0 : t.value) || u.height.value,
      si
    ));
  }), r(() => {
    l.value.setRenderTarget(e.value), l.value.clear(), l.value.render(c.value, a.value), l.value.setRenderTarget(null);
  }), Sr(() => {
    var h;
    (h = e.value) == null || h.dispose();
  }), e;
}
const fg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    width: {},
    height: {},
    depth: { type: Boolean, default: !1 },
    settings: { default: void 0 }
  },
  setup(o, { expose: e }) {
    const n = pf(o);
    return e({
      value: n
    }), () => {
    };
  }
}), mf = (o, e = 16, t, n, s) => {
  const i = new Float32Array(e * 16), r = he(new wr(i, 16));
  return (() => {
    if (!o)
      return;
    const l = new su(o);
    n && l.setWeightAttribute(n), l.build();
    const c = new Z(), u = new Z(), h = new Re(), f = new Mt();
    o.updateMatrixWorld(!0);
    for (let p = 0; p < e; p++)
      l.sample(c, u, h), typeof s == "function" ? s(
        {
          dummy: f,
          sampledMesh: o,
          position: c,
          normal: u,
          color: h
        },
        p
      ) : f.position.copy(c), f.updateMatrix(), t && t.setMatrixAt(p, f.matrix), f.matrix.toArray(r.value.array, p * 16);
    t && (t.instanceMatrix.needsUpdate = !0), r.value.needsUpdate = !0;
  })(), { buffer: r };
}, dg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    transform: { type: Function },
    weight: {},
    count: {},
    mesh: {},
    instanceMesh: {}
  },
  setup(o, { expose: e }) {
    const t = o, n = he(), s = he(), i = he();
    return ut(() => {
      var r, a;
      s.value = t.instanceMesh ?? ((r = n.value) == null ? void 0 : r.children.find((l) => Object.prototype.hasOwnProperty.call(l, "instanceMatrix"))), i.value = t.mesh ?? ((a = n.value) == null ? void 0 : a.children.find((l) => l.type === "Mesh")), mf(i.value, t.count, s.value, t.weight, t.transform);
    }), e({
      samplerRef: n
    }), (r, a) => (ce(), ue("TresGroup", {
      ref_key: "samplerRef",
      ref: n
    }, [
      Ve(r.$slots, "default")
    ], 512));
  }
});
class gf extends Ie {
  constructor(e, t = 1, n = 16, s = 2) {
    const i = new at(), r = n + s * 2, a = new Float32Array((r * 3 + 3) * 3);
    i.setAttribute("position", new mt(a, 3));
    const l = new ts({ color: 65280 }), c = new ts({ color: 16776960 });
    super(i, [c, l]), this.audio = e, this.range = t, this.divisionsInnerAngle = n, this.divisionsOuterAngle = s, this.type = "PositionalAudioHelper", this.update();
  }
  update() {
    const e = this.audio, t = this.range, n = this.divisionsInnerAngle, s = this.divisionsOuterAngle, i = Ze.degToRad(e.panner.coneInnerAngle), r = Ze.degToRad(e.panner.coneOuterAngle), a = i / 2, l = r / 2;
    let c = 0, u = 0, h, f;
    const p = this.geometry, y = p.attributes.position;
    p.clearGroups();
    function g(v, d, w, x) {
      const T = (d - v) / w;
      for (y.setXYZ(c, 0, 0, 0), u++, h = v; h < d; h += T)
        f = c + u, y.setXYZ(f, Math.sin(h) * t, 0, Math.cos(h) * t), y.setXYZ(f + 1, Math.sin(Math.min(h + T, d)) * t, 0, Math.cos(Math.min(h + T, d)) * t), y.setXYZ(f + 2, 0, 0, 0), u += 3;
      p.addGroup(c, u, x), c += u, u = 0;
    }
    g(-l, -a, s, 0), g(-a, a, n, 1), g(a, l, s, 0), y.needsUpdate = !0, i === r && (this.material[0].visible = !1);
  }
  dispose() {
    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
  }
}
const vf = ["args"], pg = /* @__PURE__ */ me({
  __name: "PositionalAudio",
  props: {
    ready: { type: Boolean, default: !1 },
    url: {},
    distance: { default: 2 },
    helper: { type: Boolean, default: !1 },
    loop: { type: Boolean, default: !1 },
    autoplay: { type: Boolean, default: !1 },
    innerAngle: { default: 360 },
    outerAngle: { default: 360 },
    outerGain: { default: 0 }
  },
  emits: ["isPlaying"],
  async setup(o, { expose: e, emit: t }) {
    let n, s;
    const i = o, r = t, { ready: a, url: l, distance: c, helper: u, loop: h, autoplay: f, innerAngle: p, outerAngle: y, outerGain: g } = Oe(i), { camera: v } = ke(), d = pe(null), w = pe(null), x = pe(null), T = Ta(new ya()), P = () => {
      var z, k, G;
      (z = d == null ? void 0 : d.value) != null && z.isPlaying || ((k = d == null ? void 0 : d.value) == null || k.play(), r("isPlaying", (G = d == null ? void 0 : d.value) == null ? void 0 : G.isPlaying));
    }, S = () => {
      var z, k;
      (z = d == null ? void 0 : d.value) != null && z.isPlaying && (d.value.pause(), r("isPlaying", (k = d == null ? void 0 : d.value) == null ? void 0 : k.isPlaying));
    }, M = () => {
      var z;
      d.value && (d.value.stop(), r("isPlaying", (z = d == null ? void 0 : d.value) == null ? void 0 : z.isPlaying));
    }, m = () => {
      if (!(d != null && d.value))
        return;
      M();
      const z = d.value;
      z.source && z.disconnect();
    }, b = () => {
      var z, k;
      !(d != null && d.value) || !(w != null && w.value) || ((z = w == null ? void 0 : w.value) == null || z.dispose(), (k = d == null ? void 0 : d.value) == null || k.remove(w == null ? void 0 : w.value));
    }, _ = () => {
      var z;
      if (d.value && (d.value.setBuffer(x.value), d.value.setRefDistance(c.value), d.value.setLoop(h.value), d.value.setDirectionalCone(p.value, y.value, g.value), (z = w == null ? void 0 : w.value) == null || z.update(), w != null && w.value)) {
        const k = w.value.material[0];
        !k.visible && y.value !== p.value && (k.visible = !0);
      }
    }, I = () => {
      var U, q;
      _();
      const z = (U = d.value) == null ? void 0 : U.parent, k = new bt().setFromObject(z), G = (k.max.z - k.min.z) * 2;
      w.value = new gf(d.value, G, 32, 16), (q = d == null ? void 0 : d.value) == null || q.add(w.value), w.value.update();
    }, R = () => {
      var z;
      (z = v == null ? void 0 : v.value) == null || z.remove(T), m(), b();
    };
    return e({
      root: d,
      play: P,
      stop: M,
      pause: S,
      dispose: R
    }), x.value = ([n, s] = Bn(() => ss(_a, l.value)), n = await n, s(), n), ve(d, () => {
      d != null && d.value && (u.value && I(), a.value && f && P());
    }), ve(u, () => {
      u.value ? I() : b();
    }), ve(a, () => {
      a.value && _(), f.value && a.value && P(), !f.value && a.value && M();
    }), ve([c, h, x, p, y, g, f], () => {
      _();
    }), En(() => {
      var z;
      (z = v == null ? void 0 : v.value) == null || z.add(T);
    }), Sr(() => {
      R();
    }), (z, k) => (ce(), ue("TresPositionalAudio", We({
      ref_key: "positionalAudioRef",
      ref: d,
      args: [H(T)]
    }, z.$attrs), null, 16, vf));
  }
}), Ys = {
  sunset: "venice/venice_sunset_1k.hdr",
  studio: "studio/poly_haven_studio_1k.hdr",
  city: "city/canary_wharf_1k.hdr",
  umbrellas: "outdoor/outdoor_umbrellas_1k.hdr",
  night: "outdoor/satara_night_1k.hdr",
  forest: "outood/mossy_forest_1k.hdr",
  snow: "outdoor/snowy_forest_path_01_1k.hdr",
  dawn: "kiara/kiara_1_dawn_1k.hdr",
  hangar: "indoor/small_hangar_01_1k.hdr",
  urban: "indoor/abandoned_games_room_02_1k.hdr",
  modern: "city/modern_buildings_2_1k.hdr",
  shangai: "city/shanghai_bund_1k.hdr"
}, yf = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
async function _f(o, e) {
  const { scene: t } = ke(), {
    preset: n,
    blur: s,
    files: i = [],
    path: r = "",
    background: a
  } = Oe(o), l = he(), c = Fe(() => Array.isArray(i.value)), u = Fe(() => c.value ? zl : co), h = he(null);
  return ve(() => [i, r], async ([f, p]) => {
    if (f.value.length > 0 && !n.value) {
      try {
        h.value = await ss(
          H(u),
          c.value ? [H(f)] : H(f),
          (y) => {
            p.value && y.setPath(H(p));
          }
        );
      } catch (y) {
        throw new Error(`Failed to load environment map: ${y}`);
      }
      h.value && (l.value = c.value ? h.value[0] : h.value, l.value.mapping = c.value ? Hl : sr);
    }
  }, {
    immediate: !0
  }), ve(() => l.value, (f) => {
    t.value && (t.value.environment = f);
  }, {
    immediate: !0
  }), ve(() => [a.value, l.value], ([f, p]) => {
    if (t.value) {
      const y = e != null && e.value ? e.value.texture : p;
      t.value.background = f ? y : void 0;
    }
  }, {
    immediate: !0
  }), ve(() => s == null ? void 0 : s.value, (f) => {
    t.value && (t.value.backgroundBlurriness = f);
  }, {
    immediate: !0
  }), ve(n, async (f) => {
    if (f && f in Ys) {
      const p = yf, y = Ys[f];
      try {
        h.value = await ss(
          co,
          y,
          (g) => {
            p && g.setPath(p);
          }
        );
      } catch (g) {
        throw new Error(`Failed to load environment map: ${g}`);
      }
      h.value && (l.value = h.value, l.value.mapping = sr);
    } else if (f && !(f in Ys))
      throw new Error(`Preset must be one of: ${Object.keys(Ys).join(", ")}`);
  }, {
    immediate: !0
  }), { texture: l };
}
let xn = null;
function xf(o, e) {
  return (t) => {
    e && e(t), o.draco && (xn || (xn = new Sh()), xn.setDecoderPath(o.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader(xn));
  };
}
async function wf(o, e = {
  draco: !1
}, t) {
  const n = await ss(yu, o, xf(e, t));
  return xn == null || xn.dispose(), xn = null, n;
}
const Tf = ["object"], mg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    path: {},
    draco: { type: Boolean, default: !1 },
    decoderPath: { default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/" },
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = he();
    e({
      value: i
    });
    const { scene: r } = ([t, n] = Bn(() => wf(s.path, {
      draco: s.draco,
      decoderPath: s.decoderPath
    })), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (ce(), ue("primitive", We({
      ref_key: "modelRef",
      ref: i,
      object: H(r)
    }, a.$attrs), null, 16, Tf));
  }
});
async function bf(o) {
  return await ss(ah, o);
}
const Ef = ["object"], gg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    path: {},
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = he();
    e({
      value: i
    });
    const r = ([t, n] = Bn(() => bf(s.path)), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (ce(), ue("primitive", We({
      ref_key: "modelRef",
      ref: i,
      object: H(r)
    }, a.$attrs), null, 16, Ef));
  }
}), Sf = ["geometry", "render-order"], vg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    src: {},
    skipStrokes: { type: Boolean, default: !1 },
    skipFills: { type: Boolean, default: !1 },
    fillMaterial: {},
    strokeMaterial: {},
    fillMeshProps: {},
    strokeMeshProps: {},
    depth: { default: "renderOrder" }
  },
  setup(o, { expose: e }) {
    const t = o, { src: n, skipStrokes: s, skipFills: i, fillMaterial: r, strokeMaterial: a, fillMeshProps: l, strokeMeshProps: c, depth: u } = Oe(t), h = pe(), f = pe([]), p = pe([]);
    e({ value: h }), ut(async () => y(n.value).then((d) => p.value = d.paths)), ve([i, s, r, a, p], v);
    async function y(d) {
      const w = d.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${d}`) : d;
      return ss(xs, w);
    }
    ct(g);
    function g() {
      f.value.forEach((d) => d.geometry.dispose());
    }
    function v() {
      var P, S, M;
      g();
      const d = [], [w, x] = (() => {
        const m = { flat: !1, renderOrder: !1, offsetZ: !0 }, b = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, _ = u.value;
        return typeof _ == "number" ? [!0, _] : [m[_], b[_]];
      })();
      let T = 0;
      for (const m of p.value) {
        const b = ((P = m.userData) == null ? void 0 : P.style) ?? {}, _ = Object.assign({
          color: b.fill,
          opacity: b.fillOpacity,
          transparent: !0,
          side: wn,
          depthWrite: w
        }, t.fillMaterial);
        if (!i.value && b.fill !== void 0 && b.fill !== "none")
          for (const I of xs.createShapes(m)) {
            const R = new jl(I);
            R.scale(1, -1, 1), x && R.translate(0, 0, T++ * x), d.push({
              geometry: R,
              material: _,
              isStroke: !1
            });
          }
        if (!s.value && b.stroke !== void 0 && b.stroke !== "none") {
          const I = Object.assign({
            color: (S = m.userData) == null ? void 0 : S.style.stroke,
            opacity: (M = m.userData) == null ? void 0 : M.style.strokeOpacity,
            transparent: !0,
            side: wn,
            depthWrite: w
          }, t.strokeMaterial);
          for (const R of m.subPaths) {
            const z = R.getPoints().map((G) => new ge(G.x, -G.y)), k = xs.pointsToStroke(z, b || "none");
            x && k.translate(0, 0, T++ * x), d.push({
              geometry: k,
              material: I,
              isStroke: !0
            });
          }
        }
      }
      f.value = d;
    }
    return (d, w) => (ce(), ue("TresGroup", {
      ref_key: "svgRef",
      ref: h
    }, [
      (ce(!0), ue(Ea, null, Sa(f.value, ({ geometry: x, material: T, isStroke: P }, S) => (ce(), ue("TresMesh", We({
        key: `${S}`,
        ref_for: !0
      }, P ? H(c) : H(l), {
        geometry: x,
        "render-order": H(u) === "renderOrder" ? S : 0
      }), [
        _e("TresMeshBasicMaterial", We({ ref_for: !0 }, T), null, 16)
      ], 16, Sf))), 128))
    ], 512));
  }
}), vo = "[TresJS - Cientos   ] ";
function Or() {
  function o(n, s) {
    console.error(`${vo} ${n}`, s || "");
  }
  function e(n) {
    console.warn(`${vo} ${n}`);
  }
  function t(n, s) {
  }
  return {
    logError: o,
    logWarning: e,
    logMessage: t
  };
}
let Li = 0;
function yg() {
  const o = he(!1), e = he(0), t = he([]), { logError: n } = Or();
  return new Promise((s) => {
    Us.onStart = () => {
      o.value = !1;
    }, Us.onLoad = () => {
      o.value = !0;
    }, Us.onProgress = (i, r, a) => {
      r === a && (Li = a, o.value = !0, t.value.push(i)), e.value = Math.round((r - Li) / (a - Li) * 100 || 100, 2);
    }, Us.onError = (i) => {
      n("Error loading assets", new Error(i)), o.value = !0;
    }, s({
      items: t,
      hasFinishLoading: o,
      progress: e
    });
  });
}
async function _g(o, e) {
  const { logError: t } = Or();
  if (!o)
    return t("Error no path provided");
  const { unsuspend: n, start: s, crossOrigin: i, muted: r, loop: a, ...l } = {
    unsuspend: "loadedmetadata",
    crossOrigin: "Anonymous",
    muted: !0,
    loop: !0,
    start: !0,
    playsInline: !0,
    ...e
  };
  function c() {
    return new Promise((u, h) => {
      const f = Object.assign(document.createElement("video"), {
        src: typeof o == "string" && o || void 0,
        crossOrigin: i,
        loop: a,
        muted: r,
        autoplay: !0,
        ...l
      }), p = new Gl(f);
      return f.addEventListener(n, () => u(p)), f.addEventListener("error", () => h(new Error("Error loading video"))), p;
    });
  }
  try {
    const u = await c();
    return s && u.image && u.image.play(), u;
  } catch {
    t("Error loading resource");
  }
}
const Mf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"], xg = /* @__PURE__ */ me({
  __name: "OrbitControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: { default: () => [0, 0, 0] },
    enableDamping: { type: Boolean, default: !0 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    minZoom: { default: 0 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    touches: { default: () => ({ ONE: Nt.ROTATE, TWO: Nt.DOLLY_PAN }) },
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, {
      makeDefault: i,
      autoRotate: r,
      autoRotateSpeed: a,
      enableDamping: l,
      dampingFactor: c,
      enablePan: u,
      keyPanSpeed: h,
      maxAzimuthAngle: f,
      minAzimuthAngle: p,
      maxPolarAngle: y,
      minPolarAngle: g,
      minDistance: v,
      maxDistance: d,
      minZoom: w,
      maxZoom: x,
      enableZoom: T,
      zoomSpeed: P,
      enableRotate: S,
      touches: M,
      rotateSpeed: m,
      target: b
    } = Oe(n), { camera: _, renderer: I, extend: R, controls: z } = ke(), k = he(null);
    R({ OrbitControls: ka }), ve(k, (q) => {
      G(), q && i.value ? z.value = q : z.value = null;
    });
    function G() {
      Ye(k.value, "change", () => s("change", k.value)), Ye(k.value, "start", () => s("start", k.value)), Ye(k.value, "end", () => s("end", k.value));
    }
    const { onLoop: U } = qe();
    return U(() => {
      k.value && (l.value || r.value) && k.value.update();
    }), ct(() => {
      k.value && k.value.dispose();
    }), e({ value: k }), (q, $) => (q.camera || H(_)) && (q.domElement || H(I)) ? (ce(), ue("TresOrbitControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: k,
      target: H(b),
      "auto-rotate": H(r),
      "auto-rotate-speed": H(a),
      "enable-damping": H(l),
      "damping-factor": H(c),
      "enable-pan": H(u),
      "key-pan-speed": H(h),
      keys: q.keys,
      "max-azimuth-angle": H(f),
      "min-azimuth-angle": H(p),
      "max-polar-angle": H(y),
      "min-polar-angle": H(g),
      "min-distance": H(v),
      "max-distance": H(d),
      "min-zoom": H(w),
      "max-zoom": H(x),
      touches: H(M),
      "enable-zoom": H(T),
      "zoom-speed": H(P),
      "enable-rotate": H(S),
      "rotate-speed": H(m),
      args: [q.camera || H(_), q.domElement || H(I).domElement]
    }, null, 8, Mf)) : jt("", !0);
  }
}), Af = 5, Pf = 6, Cf = 0.3, wg = /* @__PURE__ */ me({
  __name: "KeyboardControls",
  props: {
    forward: { default: () => ["w", "W"] },
    back: { default: () => ["s", "S"] },
    left: { default: () => ["a", "A"] },
    right: { default: () => ["d", "D"] },
    jump: { default: () => [" "] },
    gravity: { default: 9.8 },
    moveSpeed: { default: 0.1 },
    headBobbing: { type: Boolean, default: !1 },
    is2D: { type: Boolean, default: !1 }
  },
  setup(o) {
    var _;
    const e = o, { forward: t, back: n, left: s, right: i, jump: r, gravity: a, moveSpeed: l, headBobbing: c, is2D: u } = Oe(e), { camera: h, controls: f } = ke(), p = he(0), y = he(0), g = he(!1), v = he(!1), d = he(0), w = pe(), x = u.value ? "y" : "z", T = ((_ = h.value.position) == null ? void 0 : _.y) || 0;
    An(
      t.value,
      () => {
        g.value = !0, y.value = l.value;
      },
      { eventName: "keydown" }
    ), An(
      n.value,
      () => {
        g.value = !0, y.value = -l.value;
      },
      { eventName: "keydown" }
    ), An(
      [...t.value, ...n.value],
      () => {
        g.value = !1, y.value = 0;
      },
      { eventName: "keyup" }
    ), An(
      s.value,
      () => {
        g.value = !0, p.value = -l.value;
      },
      { eventName: "keydown" }
    ), An(
      i.value,
      () => {
        g.value = !0, p.value = l.value;
      },
      { eventName: "keydown" }
    ), An(
      [...s.value, ...i.value],
      () => {
        g.value = !1, p.value = 0;
      },
      { eventName: "keyup" }
    ), An(r.value, () => {
      v.value || (d.value = Date.now()), v.value = !0;
    });
    const P = (I) => g.value ? Math.sin(I * Af) * Cf + T : T, S = () => (Date.now() - d.value) / 1e3 * 3, M = (I) => T + Pf * I - 0.5 * a.value * I ** 2, m = () => {
      if (v.value) {
        const I = M(S());
        return I <= T && (v.value = !1), I;
      }
      return 0;
    }, { onLoop: b } = qe();
    return b(({ elapsed: I }) => {
      var R;
      f.value instanceof cr && ((R = f.value) != null && R.isLocked) ? (f.value.moveForward(y.value), f.value.moveRight(p.value), h.value.position && (h.value.position.y = c.value ? P(I) : T, h.value.position.y += m())) : w.value.children.length > 0 && !(f.value instanceof cr) && (w.value.position.x += p.value, w.value.position[x] += u.value ? y.value : -y.value);
    }), (I, R) => (ce(), ue("TresGroup", {
      ref_key: "wrapperRef",
      ref: w
    }, [
      Ve(I.$slots, "default")
    ], 512));
  }
}), If = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], Tg = /* @__PURE__ */ me({
  __name: "TransformControls",
  props: {
    object: {},
    camera: {},
    mode: { default: "translate" },
    enabled: { type: Boolean, default: !0 },
    axis: { default: "XYZ" },
    translationSnap: {},
    rotationSnap: {},
    scaleSnap: {},
    space: { default: "world" },
    size: { default: 1 },
    showX: { type: Boolean, default: !0 },
    showY: { type: Boolean, default: !0 },
    showZ: { type: Boolean, default: !0 }
  },
  emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
  setup(o, { emit: e }) {
    const t = o, n = e, { object: s, mode: i, enabled: r, axis: a, translationSnap: l, rotationSnap: c, scaleSnap: u, space: h, size: f, showX: p, showY: y, showZ: g } = Oe(t), v = pe(), { controls: d, camera: w, renderer: x, extend: T } = ke();
    T({ TransformControls: ou });
    const P = (M) => {
      d.value && (d.value.enabled = !M.value), n("dragging", M.value);
    };
    function S() {
      Ye(v.value, "change", () => n("change")), Ye(v.value, "dragging-changed", P), Ye(v.value, "mouseDown", () => n("mouseDown")), Ye(v.value, "mouseUp", () => n("mouseUp")), Ye(v.value, "objectChange", () => n("objectChange"));
    }
    return ut(() => {
      v.value && S();
    }), ct(() => {
      v.value && v.value.dispose();
    }), (M, m) => {
      var b;
      return (M.camera || H(w)) && H(x) ? (ce(), ue("TresTransformControls", {
        ref_key: "controlsRef",
        ref: v,
        key: (b = M.camera || H(w)) == null ? void 0 : b.uuid,
        object: H(s),
        args: [M.camera || H(w), H(x).domElement],
        mode: H(i),
        enabled: H(r),
        axis: H(a),
        "translation-snap": H(l),
        "rotation-snap": H(c),
        "scale-snap": H(u),
        space: H(h),
        size: H(f),
        "show-x": H(p),
        "show-y": H(y),
        "show-z": H(g),
        visible: !0
      }, null, 8, If)) : jt("", !0);
    };
  }
}), Rf = ["args"], bg = /* @__PURE__ */ me({
  __name: "PointerLockControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    selector: {}
  },
  emits: ["isLock", "change"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, { camera: i, renderer: r, extend: a, controls: l } = ke(), c = he(null);
    let u;
    a({ PointerLockControls: cr });
    const h = (f) => {
      s("isLock", f);
    };
    return ve(c, (f) => {
      f && n.makeDefault ? l.value = f : l.value = null, u = document.getElementById(n.selector || "") || r.value.domElement, Ye(l.value, "change", () => s("change", l.value)), Ye(u, "click", () => {
        var y, g, v;
        (y = l.value) == null || y.lock(), (g = l.value) == null || g.addEventListener("lock", () => h(!0)), (v = l.value) == null || v.addEventListener("unlock", () => h(!1));
      });
    }), ct(() => {
      var f, p;
      (f = l.value) == null || f.removeEventListener("lock", () => h(!0)), (p = l.value) == null || p.removeEventListener("unlock", () => h(!1)), c.value && c.value.dispose();
    }), e({
      value: l
    }), (f, p) => (f.camera || H(i)) && (f.domElement || H(r)) ? (ce(), ue("TresPointerLockControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: c,
      args: [f.camera || H(i), f.domElement || H(r).domElement]
    }, null, 8, Rf)) : jt("", !0);
  }
}), Df = ["args"], Eg = /* @__PURE__ */ me({
  __name: "MapControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {}
  },
  setup(o) {
    const e = o, { camera: t, renderer: n, extend: s, controls: i } = ke(), r = he(null);
    return s({ MapControls: vu }), ve(i, (a) => {
      a && e.makeDefault ? i.value = a : i.value = null;
    }), ct(() => {
      r.value && r.value.dispose();
    }), (a, l) => (a.camera || H(t)) && (a.domElement || H(n)) ? (ce(), ue("TresMapControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: r,
      args: [a.camera || H(t), a.domElement || H(n).domElement]
    }, null, 8, Df)) : jt("", !0);
  }
}), Sg = /* @__PURE__ */ me({
  __name: "ScrollControls",
  props: {
    pages: { default: 4 },
    distance: { default: 4 },
    smoothScroll: { default: 0.1 },
    horizontal: { type: Boolean, default: !1 },
    htmlScroll: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(o, { emit: e }) {
    const t = o, n = e, { logWarning: s } = As();
    t.smoothScroll < 0 && s("SmoothControl must be greater than zero"), t.pages < 0 && s("Pages must be greater than zero");
    const { camera: i, controls: r, renderer: a } = ke(), l = pe(), c = document.createElement("div"), { y: u } = $h(), { x: h, y: f, isScrolling: p } = Yh(c), { height: y, width: g } = Xa();
    let v = 0;
    const d = he(!1), w = he(0), x = he(0), T = he(0), P = t.horizontal ? "x" : "y", S = ve(
      i,
      (m) => {
        if (d.value) {
          S();
          return;
        }
        v = t.horizontal ? (m == null ? void 0 : m.position.x) || 0 : (m == null ? void 0 : m.position.y) || 0, d.value = !0;
      },
      {
        immediate: !0
      }
    );
    ve(
      p,
      (m) => {
        r.value && (r.value.enabled = !m);
      },
      {
        immediate: !0
      }
    ), ve(u, (m) => {
      !p.value && !t.htmlScroll || (x.value = m / y.value / (T.value / y.value - 1), w.value = -1 * x.value, n("update:modelValue", x.value));
    }), ve(f, (m) => {
      x.value = m / y.value / (T.value / y.value), w.value = -1 * x.value, n("update:modelValue", x.value);
    }), ve(h, (m) => {
      x.value = m / g.value / (T.value / g.value - 1), w.value = +x.value, n("update:modelValue", x.value);
    }), ve(
      a,
      (m) => {
        var _, I;
        const b = m == null ? void 0 : m.domElement;
        if (t.htmlScroll && (m != null && m.domElement))
          b != null && b.style.width && (b != null && b.style.position) && (b != null && b.style.top) && (b != null && b.style.left) && (b.style.width = "100%", b.style.position = "fixed", b.style.zIndex = " -99999", b.style.top = "0", b.style.left = "0"), T.value = document.body.scrollHeight;
        else {
          const R = document.createElement("div"), z = document.createElement("div");
          c.style[t.horizontal ? "overflowX" : "overflowY"] = "auto", c.style[t.horizontal ? "overflowY" : "overflowX"] = "hidden", c.style.position = "absolute", c.style.width = "100%", c.style.height = " 100%", c.style.top = "0", c.style.left = "0", c.classList.add("scrollContainer"), R.style.position = "sticky", R.style.top = "0px", R.style.left = "0px", R.style.width = "100%", R.style.height = "100%", R.style.overflow = "hidden", c.appendChild(R), z.style.height = t.horizontal ? "100%" : `${y.value * t.pages}px`, z.style.width = t.horizontal ? `${g.value * t.pages}px` : "100vw", z.style.pointerEvents = "none", b.style.position = "fixed", b.style.zIndex = "0", b != null && b.style.width && (b.style.width = "100%"), c.appendChild(z), m.domElement.parentNode.style.position = "relative", (I = (_ = m == null ? void 0 : m.domElement) == null ? void 0 : _.parentNode) == null || I.appendChild(c), T.value = t.horizontal ? g.value * t.pages : y.value * t.pages;
        }
      },
      {
        immediate: !0
      }
    );
    const { onLoop: M } = qe();
    return M(() => {
      var m;
      if ((m = i.value) != null && m.position) {
        const b = (w.value * t.distance - i.value.position[P] + v) * t.smoothScroll;
        i.value.position[P] += b, l.value.children.length > 0 && (l.value.position[P] += b);
      }
    }), (m, b) => (ce(), ue("TresGroup", {
      ref_key: "wrapperRef",
      ref: l
    }, [
      Ve(m.$slots, "default")
    ], 512));
  }
});
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const $e = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, Q = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), Gn = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Pn(o) {
  return o.isPerspectiveCamera;
}
function fn(o) {
  return o.isOrthographicCamera;
}
const Vn = Math.PI * 2, yo = Math.PI / 2, Ja = 1e-5, hs = Math.PI / 180;
function Rt(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function ze(o, e = Ja) {
  return Math.abs(o) < e;
}
function Ue(o, e, t = Ja) {
  return ze(o - e, t);
}
function _o(o, e) {
  return Math.round(o / e) * e;
}
function fs(o) {
  return isFinite(o) ? o : o < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function ds(o) {
  return Math.abs(o) < Number.MAX_VALUE ? o : o * (1 / 0);
}
function Ws(o, e, t, n, s = 1 / 0, i) {
  n = Math.max(1e-4, n);
  const r = 2 / n, a = r * i, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let c = o - e;
  const u = e, h = s * n;
  c = Rt(c, -h, h), e = o - c;
  const f = (t.value + r * c) * i;
  t.value = (t.value - r * f) * l;
  let p = e + (c + f) * l;
  return u - o > 0 == p > u && (p = u, t.value = (p - u) / i), p;
}
function xo(o, e, t, n, s = 1 / 0, i, r) {
  n = Math.max(1e-4, n);
  const a = 2 / n, l = a * i, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let u = e.x, h = e.y, f = e.z, p = o.x - u, y = o.y - h, g = o.z - f;
  const v = u, d = h, w = f, x = s * n, T = x * x, P = p * p + y * y + g * g;
  if (P > T) {
    const G = Math.sqrt(P);
    p = p / G * x, y = y / G * x, g = g / G * x;
  }
  u = o.x - p, h = o.y - y, f = o.z - g;
  const S = (t.x + a * p) * i, M = (t.y + a * y) * i, m = (t.z + a * g) * i;
  t.x = (t.x - a * S) * c, t.y = (t.y - a * M) * c, t.z = (t.z - a * m) * c, r.x = u + (p + S) * c, r.y = h + (y + M) * c, r.z = f + (g + m) * c;
  const b = v - o.x, _ = d - o.y, I = w - o.z, R = r.x - v, z = r.y - d, k = r.z - w;
  return b * R + _ * z + I * k > 0 && (r.x = v, r.y = d, r.z = w, t.x = (r.x - v) / i, t.y = (r.y - d) / i, t.z = (r.z - w) / i), r;
}
function Fi(o, e) {
  e.set(0, 0), o.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= o.length, e.y /= o.length;
}
function ki(o, e) {
  return fn(o) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class Of {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const s = this._listeners[e];
    if (s !== void 0) {
      const i = s.indexOf(t);
      i !== -1 && s.splice(i, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const s = n.slice(0);
      for (let i = 0, r = s.length; i < r; i++)
        s[i].call(this, e);
    }
  }
}
var Bi;
const Lf = "2.8.3", Xs = 1 / 8, Ff = /Mac/.test((Bi = globalThis == null ? void 0 : globalThis.navigator) === null || Bi === void 0 ? void 0 : Bi.platform);
let ye, wo, $s, Ui, ht, Se, Le, Yn, ps, Lt, Ft, Cn, To, bo, wt, ms, Wn, Eo, Ni, So, zi, Hi, Zs;
class ot extends Of {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    ye = e.THREE, wo = Object.freeze(new ye.Vector3(0, 0, 0)), $s = Object.freeze(new ye.Vector3(0, 1, 0)), Ui = Object.freeze(new ye.Vector3(0, 0, 1)), ht = new ye.Vector2(), Se = new ye.Vector3(), Le = new ye.Vector3(), Yn = new ye.Vector3(), ps = new ye.Vector3(), Lt = new ye.Vector3(), Ft = new ye.Vector3(), Cn = new ye.Vector3(), To = new ye.Vector3(), bo = new ye.Vector3(), wt = new ye.Spherical(), ms = new ye.Spherical(), Wn = new ye.Box3(), Eo = new ye.Box3(), Ni = new ye.Sphere(), So = new ye.Quaternion(), zi = new ye.Quaternion(), Hi = new ye.Matrix4(), Zs = new ye.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return Q;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = Q.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Gn.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new ye.Vector3(), this._focalOffsetVelocity = new ye.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (d, w, x) => {
      let T, P;
      if (Pn(this._camera)) {
        const S = Se.copy(this._camera.position).sub(this._target), M = this._camera.getEffectiveFOV() * hs, m = S.length() * Math.tan(M * 0.5);
        T = this.truckSpeed * d * m / this._elementRect.height, P = this.truckSpeed * w * m / this._elementRect.height;
      } else if (fn(this._camera)) {
        const S = this._camera;
        T = d * (S.right - S.left) / S.zoom / this._elementRect.width, P = w * (S.top - S.bottom) / S.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (x ? this.setFocalOffset(this._focalOffsetEnd.x + T, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(T, 0, !0), this.forward(-P, !0)) : x ? this.setFocalOffset(this._focalOffsetEnd.x + T, this._focalOffsetEnd.y + P, this._focalOffsetEnd.z, !0) : this.truck(T, P, !0);
    }, this._rotateInternal = (d, w) => {
      const x = Vn * this.azimuthRotateSpeed * d / this._elementRect.height, T = Vn * this.polarRotateSpeed * w / this._elementRect.height;
      this.rotate(x, T, !0);
    }, this._dollyInternal = (d, w, x) => {
      const T = Math.pow(0.95, -d * this.dollySpeed), P = this._sphericalEnd.radius, S = this._sphericalEnd.radius * T, M = Rt(S, this.minDistance, this.maxDistance), m = M - S;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(S, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(m, !0), this._dollyToNoClamp(M, !0)) : this._dollyToNoClamp(M, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? S : M) - P, this._dollyControlCoord.set(w, x)), this._lastDollyDirection = Math.sign(-d);
    }, this._zoomInternal = (d, w, x) => {
      const T = Math.pow(0.95, d * this.dollySpeed), P = this._zoom, S = this._zoom * T;
      this.zoomTo(S, !0), this.dollyToCursor && (this._changedZoom += S - P, this._dollyControlCoord.set(w, x));
    }, typeof ye > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new ye.Quaternion().setFromUnitVectors(this._camera.up, $s), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Q.NONE, this._target = new ye.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new ye.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new ye.Spherical().setFromVector3(Se.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new ye.Vector3(),
      new ye.Vector3(),
      new ye.Vector3(),
      new ye.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new ye.Box3(new ye.Vector3(-1 / 0, -1 / 0, -1 / 0), new ye.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new ye.Vector2(), this.mouseButtons = {
      left: Q.ROTATE,
      middle: Q.DOLLY,
      right: Q.TRUCK,
      wheel: Pn(this._camera) ? Q.DOLLY : fn(this._camera) ? Q.ZOOM : Q.NONE
    }, this.touches = {
      one: Q.TOUCH_ROTATE,
      two: Pn(this._camera) ? Q.TOUCH_DOLLY_TRUCK : fn(this._camera) ? Q.TOUCH_ZOOM_TRUCK : Q.NONE,
      three: Q.TOUCH_TRUCK
    };
    const n = new ye.Vector2(), s = new ye.Vector2(), i = new ye.Vector2(), r = (d) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const T = this._domElement.getBoundingClientRect(), P = d.clientX / T.width, S = d.clientY / T.height;
        if (P < this._interactiveArea.left || P > this._interactiveArea.right || S < this._interactiveArea.top || S > this._interactiveArea.bottom)
          return;
      }
      const w = d.pointerType !== "mouse" ? null : (d.buttons & $e.LEFT) === $e.LEFT ? $e.LEFT : (d.buttons & $e.MIDDLE) === $e.MIDDLE ? $e.MIDDLE : (d.buttons & $e.RIGHT) === $e.RIGHT ? $e.RIGHT : null;
      if (w !== null) {
        const T = this._findPointerByMouseButton(w);
        T && this._disposePointer(T);
      }
      if ((d.buttons & $e.LEFT) === $e.LEFT && this._lockedPointer)
        return;
      const x = {
        pointerId: d.pointerId,
        clientX: d.clientX,
        clientY: d.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: w
      };
      this._activePointers.push(x), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), this._isDragging = !0, f(d);
    }, a = (d) => {
      d.cancelable && d.preventDefault();
      const w = d.pointerId, x = this._lockedPointer || this._findPointerById(w);
      if (x) {
        if (x.clientX = d.clientX, x.clientY = d.clientY, x.deltaX = d.movementX, x.deltaY = d.movementY, this._state = 0, d.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (d.buttons & $e.LEFT) === $e.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (d.buttons & $e.MIDDLE) === $e.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (d.buttons & $e.RIGHT) === $e.RIGHT && (this._state = this._state | this.mouseButtons.right);
        p();
      }
    }, l = (d) => {
      const w = this._findPointerById(d.pointerId);
      if (!(w && w === this._lockedPointer)) {
        if (w && this._disposePointer(w), d.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = Q.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = Q.NONE;
        y();
      }
    };
    let c = -1;
    const u = (d) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === Q.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), M = d.clientX / S.width, m = d.clientY / S.height;
        if (M < this._interactiveArea.left || M > this._interactiveArea.right || m < this._interactiveArea.top || m > this._interactiveArea.bottom)
          return;
      }
      if (d.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Q.ROTATE || this.mouseButtons.wheel === Q.TRUCK) {
        const S = performance.now();
        c - S < 1e3 && this._getClientRect(this._elementRect), c = S;
      }
      const w = Ff ? -1 : -3, x = d.deltaMode === 1 ? d.deltaY / w : d.deltaY / (w * 10), T = this.dollyToCursor ? (d.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, P = this.dollyToCursor ? (d.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case Q.ROTATE: {
          this._rotateInternal(d.deltaX, d.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case Q.TRUCK: {
          this._truckInternal(d.deltaX, d.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case Q.OFFSET: {
          this._truckInternal(d.deltaX, d.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case Q.DOLLY: {
          this._dollyInternal(-x, T, P), this._isUserControllingDolly = !0;
          break;
        }
        case Q.ZOOM: {
          this._zoomInternal(-x, T, P), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, h = (d) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === ot.ACTION.NONE) {
          const w = d instanceof PointerEvent ? d.pointerId : 0, x = this._findPointerById(w);
          x && this._disposePointer(x), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l);
          return;
        }
        d.preventDefault();
      }
    }, f = (d) => {
      if (!this._enabled)
        return;
      if (Fi(this._activePointers, ht), this._getClientRect(this._elementRect), n.copy(ht), s.copy(ht), this._activePointers.length >= 2) {
        const x = ht.x - this._activePointers[1].clientX, T = ht.y - this._activePointers[1].clientY, P = Math.sqrt(x * x + T * T);
        i.set(0, P);
        const S = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, M = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        s.set(S, M);
      }
      if (this._state = 0, !d)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in d && d.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (d.buttons & $e.LEFT) === $e.LEFT && (this._state = this._state | this.mouseButtons.left), (d.buttons & $e.MIDDLE) === $e.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (d.buttons & $e.RIGHT) === $e.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & Q.ZOOM) === Q.ZOOM || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, p = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, Fi(this._activePointers, ht);
      const w = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, x = w ? -w.deltaX : s.x - ht.x, T = w ? -w.deltaY : s.y - ht.y;
      if (s.copy(ht), ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(x, T), this._isUserControllingRotate = !0), (this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.ZOOM) === Q.ZOOM) {
        const P = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, S = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, M = this.dollyDragInverted ? -1 : 1;
        (this._state & Q.DOLLY) === Q.DOLLY ? (this._dollyInternal(M * T * Xs, P, S), this._isUserControllingDolly = !0) : (this._zoomInternal(M * T * Xs, P, S), this._isUserControllingZoom = !0);
      }
      if ((this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) {
        const P = ht.x - this._activePointers[1].clientX, S = ht.y - this._activePointers[1].clientY, M = Math.sqrt(P * P + S * S), m = i.y - M;
        i.set(0, M);
        const b = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, _ = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(m * Xs, b, _), this._isUserControllingDolly = !0) : (this._zoomInternal(m * Xs, b, _), this._isUserControllingZoom = !0);
      }
      ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._truckInternal(x, T, !1), this._isUserControllingTruck = !0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._truckInternal(x, T, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, y = () => {
      Fi(this._activePointers, ht), s.copy(ht), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", g), this._domElement.ownerDocument.addEventListener("pointerlockerror", v), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), f());
    }, this.unlockPointer = () => {
      var d, w, x;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (d = this._domElement) === null || d === void 0 || d.ownerDocument.exitPointerLock(), (w = this._domElement) === null || w === void 0 || w.ownerDocument.removeEventListener("pointerlockchange", g), (x = this._domElement) === null || x === void 0 || x.ownerDocument.removeEventListener("pointerlockerror", v), this.cancel();
    };
    const g = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, v = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (d) => {
      this._domElement = d, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), this._domElement.addEventListener("pointercancel", l), this._domElement.addEventListener("wheel", u, { passive: !1 }), this._domElement.addEventListener("contextmenu", h);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("pointercancel", l), this._domElement.removeEventListener("wheel", u, { passive: !1 }), this._domElement.removeEventListener("contextmenu", h), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.removeEventListener("pointerlockchange", g), this._domElement.ownerDocument.removeEventListener("pointerlockerror", v));
    }, this.cancel = () => {
      this._state !== Q.NONE && (this._state = Q.NONE, this._activePointers.length = 0, y());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = Rt(e.width, 0, 1), this._interactiveArea.height = Rt(e.height, 0, 1), this._interactiveArea.x = Rt(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Rt(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, n = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, n = !1) {
    this._isUserControllingRotate = !1;
    const s = Rt(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Rt(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !n || Ue(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ue(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = Gn.NONE, this._changedDolly = 0, this._dollyToNoClamp(Rt(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const r = this._collisionTest(), a = Ue(r, this._spherical.radius);
      if (!(n > e) && a)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, r);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const i = !t || Ue(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(ps).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const n = !t || Ue(this._target.x, this._targetEnd.x, this.restThreshold) && Ue(this._target.y, this._targetEnd.y, this.restThreshold) && Ue(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = Rt(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const n = !t || Ue(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, n = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, n = !1) {
    this._camera.updateMatrix(), Lt.setFromMatrixColumn(this._camera.matrix, 0), Ft.setFromMatrixColumn(this._camera.matrix, 1), Lt.multiplyScalar(e), Ft.multiplyScalar(-t);
    const s = Se.copy(Lt).add(Ft), i = Le.copy(this._targetEnd).add(s);
    return this.moveTo(i.x, i.y, i.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    Se.setFromMatrixColumn(this._camera.matrix, 0), Se.crossVectors(this._camera.up, Se), Se.multiplyScalar(e);
    const n = Le.copy(this._targetEnd).add(Se);
    return this.moveTo(n.x, n.y, n.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return Se.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + Se.x, this._targetEnd.y + Se.y, this._targetEnd.z + Se.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, n, s = !1) {
    this._isUserControllingTruck = !1;
    const i = Se.set(e, t, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, s || this._target.copy(this._targetEnd);
    const r = !s || Ue(this._target.x, this._targetEnd.x, this.restThreshold) && Ue(this._target.y, this._targetEnd.y, this.restThreshold) && Ue(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, n, s = !1) {
    const a = Se.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(a.x, a.y, a.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: a = 0 } = {}) {
    const l = [], c = e.isBox3 ? Wn.copy(e) : Wn.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const u = _o(this._sphericalEnd.theta, yo), h = _o(this._sphericalEnd.phi, yo);
    l.push(this.rotateTo(u, h, t));
    const f = Se.setFromSpherical(this._sphericalEnd).normalize(), p = So.setFromUnitVectors(f, Ui), y = Ue(Math.abs(f.y), 1);
    y && p.multiply(zi.setFromAxisAngle($s, u)), p.multiply(this._yAxisUpSpaceInverse);
    const g = Eo.makeEmpty();
    Le.copy(c.min).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.min).setX(c.max.x).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.min).setY(c.max.y).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.max).setZ(c.min.z).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.min).setZ(c.max.z).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.max).setY(c.min.y).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.max).setX(c.min.x).applyQuaternion(p), g.expandByPoint(Le), Le.copy(c.max).applyQuaternion(p), g.expandByPoint(Le), g.min.x -= s, g.min.y -= r, g.max.x += i, g.max.y += a, p.setFromUnitVectors(Ui, f), y && p.premultiply(zi.invert()), p.premultiply(this._yAxisUpSpace);
    const v = g.getSize(Se), d = g.getCenter(Le).applyQuaternion(p);
    if (Pn(this._camera)) {
      const w = this.getDistanceToFitBox(v.x, v.y, v.z, n);
      l.push(this.moveTo(d.x, d.y, d.z, t)), l.push(this.dollyTo(w, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    } else if (fn(this._camera)) {
      const w = this._camera, x = w.right - w.left, T = w.top - w.bottom, P = n ? Math.max(x / v.x, T / v.y) : Math.min(x / v.x, T / v.y);
      l.push(this.moveTo(d.x, d.y, d.z, t)), l.push(this.zoomTo(P, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const n = [], i = e instanceof ye.Sphere ? Ni.copy(e) : ot.createBoundingSphere(e, Ni);
    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), Pn(this._camera)) {
      const r = this.getDistanceToFitSphere(i.radius);
      n.push(this.dollyTo(r, t));
    } else if (fn(this._camera)) {
      const r = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * i.radius, c = Math.min(r / l, a / l);
      n.push(this.zoomTo(c, t));
    }
    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, n, s, i, r, a = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Gn.NONE, this._changedDolly = 0;
    const l = Le.set(s, i, r), c = Se.set(e, t, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const u = !a || Ue(this._target.x, this._targetEnd.x, this.restThreshold) && Ue(this._target.y, this._targetEnd.y, this.restThreshold) && Ue(this._target.z, this._targetEnd.z, this.restThreshold) && Ue(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ue(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Ue(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(u);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, n, s, i, r, a, l, c, u, h, f, p, y = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Gn.NONE, this._changedDolly = 0;
    const g = Se.set(s, i, r), v = Le.set(e, t, n);
    wt.setFromVector3(v.sub(g).applyQuaternion(this._yAxisUpSpace));
    const d = Yn.set(u, h, f), w = Le.set(a, l, c);
    ms.setFromVector3(w.sub(d).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(g.lerp(d, p));
    const x = ms.theta - wt.theta, T = ms.phi - wt.phi, P = ms.radius - wt.radius;
    this._sphericalEnd.set(wt.radius + P * p, wt.phi + T * p, wt.theta + x * p), this.normalizeRotations(), this._needsUpdate = !0, y || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const S = !y || Ue(this._target.x, this._targetEnd.x, this.restThreshold) && Ue(this._target.y, this._targetEnd.y, this.restThreshold) && Ue(this._target.z, this._targetEnd.z, this.restThreshold) && Ue(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ue(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Ue(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(S);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, n, s = !1) {
    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, n, s = !1) {
    const i = this.getPosition(Se), r = this.setLookAt(i.x, i.y, i.z, e, t, n, s);
    return this._sphericalEnd.phi = Rt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, n, s = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, s || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !s || Ue(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Ue(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Ue(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, n) {
    this._camera.updateMatrixWorld(), Lt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Ft.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Cn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = Se.set(e, t, n), i = s.distanceTo(this._camera.position), r = s.sub(this._camera.position);
    Lt.multiplyScalar(r.x), Ft.multiplyScalar(r.y), Cn.multiplyScalar(r.z), Se.copy(Lt).add(Ft).add(Cn), Se.z = Se.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Se.x, Se.y, -Se.z, !1), this.moveTo(e, t, n, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, n, s) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new ye.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, n, s = !1) {
    if (ki(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = e / t, r = this._camera.getEffectiveFOV() * hs, a = this._camera.aspect;
    return ((s ? i > a : i < a) ? t : e / a) * 0.5 / Math.tan(r * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (ki(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * hs, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;
    return e / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new ye.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new ye.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e && e instanceof ye.Spherical ? e : new ye.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new ye.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Vn, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Vn), this._spherical.theta += Vn * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Vn);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!Ue(this._camera.up.x, this._cameraUp0.x) || !Ue(this._camera.up.y, this._cameraUp0.y) || !Ue(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(Se);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, $s), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = Se.subVectors(this._target, this._camera.position).normalize(), t = Le.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(Se);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = To.subVectors(this._targetEnd, this._target), r = bo.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
    if (ze(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Ws(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, h, 1 / 0, e), this._needsUpdate = !0;
    }
    if (ze(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Ws(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, h, 1 / 0, e), this._needsUpdate = !0;
    }
    if (ze(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const h = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Ws(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, h, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (ze(i.x) && ze(i.y) && ze(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const h = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      xo(this._target, this._targetEnd, this._targetVelocity, h, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (ze(r.x) && ze(r.y) && ze(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const h = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      xo(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, h, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (ze(a))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const h = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Ws(this._zoom, this._zoomEnd, this._zoomVelocity, h, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (Pn(this._camera) && this._changedDolly !== 0) {
        const h = this._spherical.radius - this._lastDistance, f = this._camera, p = this._getCameraDirection(ps), y = Se.copy(p).cross(f.up).normalize();
        y.lengthSq() === 0 && (y.x = 1);
        const g = Le.crossVectors(y, p), v = this._sphericalEnd.radius * Math.tan(f.getEffectiveFOV() * hs * 0.5), w = (this._sphericalEnd.radius - h - this._sphericalEnd.radius) / this._sphericalEnd.radius, x = Yn.copy(this._targetEnd).add(y.multiplyScalar(this._dollyControlCoord.x * v * f.aspect)).add(g.multiplyScalar(this._dollyControlCoord.y * v)), T = Se.copy(this._targetEnd).lerp(x, w), P = this._lastDollyDirection === Gn.IN && this._spherical.radius <= this.minDistance, S = this._lastDollyDirection === Gn.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (P || S)) {
          this._sphericalEnd.radius -= h, this._spherical.radius -= h;
          const m = Le.copy(p).multiplyScalar(-h);
          T.add(m);
        }
        this._boundary.clampPoint(T, T);
        const M = Le.subVectors(T, this._targetEnd);
        this._targetEnd.copy(T), this._target.add(M), this._changedDolly -= h, ze(this._changedDolly) && (this._changedDolly = 0);
      } else if (fn(this._camera) && this._changedZoom !== 0) {
        const h = this._zoom - this._lastZoom, f = this._camera, p = Se.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (f.near + f.far) / (f.near - f.far)).unproject(f), y = Le.set(0, 0, -1).applyQuaternion(f.quaternion), g = Yn.copy(p).add(y.multiplyScalar(-p.dot(f.up))), d = -(this._zoom - h - this._zoom) / this._zoom, w = this._getCameraDirection(ps), x = this._targetEnd.dot(w), T = Se.copy(this._targetEnd).lerp(g, d), P = T.dot(w), S = w.multiplyScalar(P - x);
        T.sub(S), this._boundary.clampPoint(T, T);
        const M = Le.subVectors(T, this._targetEnd);
        this._targetEnd.copy(T), this._target.add(M), this._changedZoom -= h, ze(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!ze(this._focalOffset.x) || !ze(this._focalOffset.y) || !ze(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), Lt.setFromMatrixColumn(this._camera.matrix, 0), Ft.setFromMatrixColumn(this._camera.matrix, 1), Cn.setFromMatrixColumn(this._camera.matrix, 2), Lt.multiplyScalar(this._focalOffset.x), Ft.multiplyScalar(-this._focalOffset.y), Cn.multiplyScalar(this._focalOffset.z), Se.copy(Lt).add(Ft).add(Cn), this._camera.position.add(Se)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Se.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), ze(t, this.restThreshold) && ze(n, this.restThreshold) && ze(s, this.restThreshold) && ze(i.x, this.restThreshold) && ze(i.y, this.restThreshold) && ze(i.z, this.restThreshold) && ze(r.x, this.restThreshold) && ze(r.y, this.restThreshold) && ze(r.z, this.restThreshold) && ze(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = !1, u;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: fs(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: fs(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: fs(this.maxPolarAngle),
      minAzimuthAngle: fs(this.minAzimuthAngle),
      maxAzimuthAngle: fs(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: Se.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const n = JSON.parse(e);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = ds(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = ds(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = ds(n.maxPolarAngle), this.minAzimuthAngle = ds(n.minAzimuthAngle), this.maxAzimuthAngle = ds(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), wt.setFromVector3(Se.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(wt.theta, wt.phi, t), this.dollyTo(wt.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", Lf), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, n) {
    const s = t.lengthSq();
    if (s === 0)
      return e;
    const i = Le.copy(t).add(e), a = this._boundary.clampPoint(i, Yn).sub(i), l = a.lengthSq();
    if (l === 0)
      return e.add(t);
    if (l === s)
      return e;
    if (n === 0)
      return e.add(t).add(a);
    {
      const c = 1 + n * l / t.dot(a);
      return e.add(Le.copy(t).multiplyScalar(c)).add(a.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (Pn(this._camera)) {
      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * hs, s = Math.tan(n * 0.5) * t, i = s * e.aspect;
      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
    } else if (fn(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, n = e.left * t, s = e.right * t, i = e.top * t, r = e.bottom * t;
      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(n, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || ki(this._camera, "_collisionTest"))
      return e;
    const n = this._getTargetDirection(ps);
    Hi.lookAt(wo, n, this._camera.up);
    for (let s = 0; s < 4; s++) {
      const i = Le.copy(this._nearPlaneCorners[s]);
      i.applyMatrix4(Hi);
      const r = Yn.addVectors(this._target, i);
      Zs.set(r, n), Zs.far = this._spherical.radius + 1;
      const a = Zs.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < e && (e = a[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const n = () => {
        this.removeEventListener("rest", n), t();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new ye.Sphere()) {
    const n = t, s = n.center;
    Wn.makeEmpty(), e.traverseVisible((r) => {
      r.isMesh && Wn.expandByObject(r);
    }), Wn.getCenter(s);
    let i = 0;
    return e.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const a = r, l = a.geometry.clone();
      l.applyMatrix4(a.matrixWorld);
      const u = l.attributes.position;
      for (let h = 0, f = u.count; h < f; h++)
        Se.fromBufferAttribute(u, h), i = Math.max(i, s.distanceToSquared(Se));
    }), n.radius = Math.sqrt(i), n;
  }
}
const el = (o) => !!(o && o.isPerspectiveCamera), tl = (o) => !!(o && o.isOrthographicCamera), kf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args", "mouse-buttons", "touches"], Mo = (o, e) => ({
  left: ot.ACTION.ROTATE,
  middle: ot.ACTION.DOLLY,
  right: ot.ACTION.TRUCK,
  wheel: el(o) ? ot.ACTION.DOLLY : tl(o) ? ot.ACTION.ZOOM : ot.ACTION.NONE,
  ...e
}), Ao = (o, e) => ({
  one: ot.ACTION.TOUCH_ROTATE,
  two: el(o) ? ot.ACTION.TOUCH_DOLLY_TRUCK : tl(o) ? ot.ACTION.TOUCH_ZOOM_TRUCK : ot.ACTION.NONE,
  three: ot.ACTION.TOUCH_TRUCK,
  ...e
}), Mg = /* @__PURE__ */ me({
  __name: "CameraControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    minPolarAngle: { default: 0 },
    maxPolarAngle: { default: Math.PI },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    distance: { default: () => ke().camera.value.position.z },
    minDistance: { default: Number.EPSILON },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    infinityDolly: { type: Boolean, default: !1 },
    minZoom: { default: 0.01 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    smoothTime: { default: 0.25 },
    draggingSmoothTime: { default: 0.125 },
    maxSpeed: { default: Number.POSITIVE_INFINITY },
    azimuthRotateSpeed: { default: 1 },
    polarRotateSpeed: { default: 1 },
    dollySpeed: { default: 1 },
    dollyDragInverted: { type: Boolean, default: !1 },
    truckSpeed: { default: 2 },
    dollyToCursor: { type: Boolean, default: !1 },
    dragToOffset: { type: Boolean, default: !1 },
    verticalDragToForward: { type: Boolean, default: !1 },
    boundaryFriction: { default: 0 },
    restThreshold: { default: 0.01 },
    colliderMeshes: { default: () => [] },
    mouseButtons: { default: () => Mo(ke().camera.value) },
    touches: { default: () => Ao(ke().camera.value) }
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, {
      makeDefault: i,
      minPolarAngle: r,
      maxPolarAngle: a,
      minAzimuthAngle: l,
      maxAzimuthAngle: c,
      distance: u,
      minDistance: h,
      maxDistance: f,
      infinityDolly: p,
      minZoom: y,
      maxZoom: g,
      smoothTime: v,
      draggingSmoothTime: d,
      maxSpeed: w,
      azimuthRotateSpeed: x,
      polarRotateSpeed: T,
      dollySpeed: P,
      dollyDragInverted: S,
      truckSpeed: M,
      dollyToCursor: m,
      dragToOffset: b,
      verticalDragToForward: _,
      boundaryFriction: I,
      restThreshold: R,
      colliderMeshes: z
    } = Oe(n), k = {
      Box3: bt,
      MathUtils: {
        clamp: Ze.clamp
      },
      Matrix4: Pe,
      Quaternion: He,
      Raycaster: oa,
      Sphere: fi,
      Spherical: ri,
      Vector2: ge,
      Vector3: Z,
      Vector4: lt
    };
    ot.install({ THREE: k });
    const { camera: G, renderer: U, extend: q, controls: $ } = ke(), te = Fe(() => Mo(
      n.camera || G.value,
      n.mouseButtons
    )), ee = Fe(() => Ao(
      n.camera || G.value,
      n.touches
    )), oe = he(null);
    q({ CameraControls: ot }), ut(() => {
      de(), oe.value && i.value ? $.value = oe.value : $.value = null;
    });
    function de() {
      Ye(oe.value, "update", () => s("change", oe.value)), Ye(oe.value, "controlend", () => s("end", oe.value)), Ye(oe.value, "controlstart", () => s("start", oe.value));
    }
    const { onLoop: xe } = qe();
    return xe(({ delta: C }) => {
      var B, L;
      (B = oe.value) != null && B.enabled && ((L = oe.value) == null || L.update(C));
    }), ct(() => {
      oe.value && oe.value.disconnect();
    }), e({
      value: oe
    }), (C, B) => (C.camera || H(G)) && (C.domElement || H(U)) ? (ce(), ue("TresCameraControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: oe,
      "min-polar-angle": H(r),
      "max-polar-angle": H(a),
      "min-azimuth-angle": H(l),
      "max-azimuth-angle": H(c),
      distance: H(u),
      "min-distance": H(h),
      "max-distance": H(f),
      "infinity-dolly": H(p),
      "min-zoom": H(y),
      "max-zoom": H(g),
      "smooth-time": H(v),
      "dragging-smooth-time": H(d),
      "max-speed": H(w),
      "azimuth-rotate-speed": H(x),
      "polar-rotate-speed": H(T),
      "dolly-speed": H(P),
      "dolly-drag-inverted": H(S),
      "truck-speed": H(M),
      "dolly-to-cursor": H(m),
      "drag-to-offset": H(b),
      "vertical-drag-to-forward": H(_),
      "boundary-friction": H(I),
      "rest-threshold": H(R),
      "collider-meshes": H(z),
      args: [C.camera || H(G), C.domElement || H(U).domElement],
      "mouse-buttons": te.value,
      touches: ee.value
    }, null, 8, kf)) : jt("", !0);
  }
});
class Bf extends Ss {
  constructor(t = {}) {
    super(t);
    ae(this, "_time");
    ae(this, "_factor");
    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };
  }
  onBeforeCompile(t) {
    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `, t.vertexShader = t.vertexShader.replace(
      "#include <begin_vertex>",
      `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`
    );
  }
  get time() {
    return this._time.value;
  }
  set time(t) {
    this._time.value = t;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(t) {
    this._factor.value = t;
  }
}
const Uf = ["factor"], Ag = /* @__PURE__ */ me({
  __name: "index",
  props: {
    speed: { default: 1 },
    factor: { default: 1 }
  },
  setup(o) {
    const e = o, t = pe(), { extend: n } = ke();
    n({ MeshWobbleMaterial: Bf });
    const { onLoop: s } = qe();
    return s(({ elapsed: i }) => {
      t.value && (t.value.time = i * (e == null ? void 0 : e.speed));
    }), (i, r) => (ce(), ue("TresMeshWobbleMaterial", We({
      ref_key: "materialRef",
      ref: t,
      factor: i.factor
    }, i.$attrs), null, 16, Uf));
  }
});
function vn(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function Nf(o, e) {
  return (o % e + e) % e;
}
function zf(o, e, t, n, s) {
  return n + (o - e) * (s - n) / (t - e);
}
function ji(o, e, t) {
  return (1 - t) * o + t * e;
}
class Lr {
  constructor(e = 0, t = 0) {
    Lr.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(vn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), s = Math.sin(t), i = this.x - e.x, r = this.y - e.y;
    return this.x = i * n - r * s + e.x, this.y = i * s + r * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
const Hf = "", dn = "srgb", Fr = "srgb-linear", jf = "display-p3", nl = "display-p3-linear", dr = "linear", Po = "srgb", Co = "rec709", Io = "p3";
class Cs {
  constructor(e, t, n, s, i, r, a, l, c) {
    Cs.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, i, r, a, l, c);
  }
  set(e, t, n, s, i, r, a, l, c) {
    const u = this.elements;
    return u[0] = e, u[1] = s, u[2] = a, u[3] = t, u[4] = i, u[5] = l, u[6] = n, u[7] = r, u[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, i = this.elements, r = n[0], a = n[3], l = n[6], c = n[1], u = n[4], h = n[7], f = n[2], p = n[5], y = n[8], g = s[0], v = s[3], d = s[6], w = s[1], x = s[4], T = s[7], P = s[2], S = s[5], M = s[8];
    return i[0] = r * g + a * w + l * P, i[3] = r * v + a * x + l * S, i[6] = r * d + a * T + l * M, i[1] = c * g + u * w + h * P, i[4] = c * v + u * x + h * S, i[7] = c * d + u * T + h * M, i[2] = f * g + p * w + y * P, i[5] = f * v + p * x + y * S, i[8] = f * d + p * T + y * M, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], u = e[8];
    return t * r * u - t * a * c - n * i * u + n * a * l + s * i * c - s * r * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], u = e[8], h = u * r - a * c, f = a * l - u * i, p = c * i - r * l, y = t * h + n * f + s * p;
    if (y === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / y;
    return e[0] = h * g, e[1] = (s * c - u * n) * g, e[2] = (a * n - s * r) * g, e[3] = f * g, e[4] = (u * t - s * l) * g, e[5] = (s * i - a * t) * g, e[6] = p * g, e[7] = (n * l - c * t) * g, e[8] = (r * t - n * i) * g, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, s, i, r, a) {
    const l = Math.cos(i), c = Math.sin(i);
    return this.set(
      n * l,
      n * c,
      -n * (l * r + c * a) + r + e,
      -s * c,
      s * l,
      -s * (-c * r + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Gi.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Gi.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Gi.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (t[s] !== n[s])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Gi = /* @__PURE__ */ new Cs(), Ro = /* @__PURE__ */ new Cs().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), Do = /* @__PURE__ */ new Cs().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), qs = {
  [Fr]: {
    transfer: dr,
    primaries: Co,
    toReference: (o) => o,
    fromReference: (o) => o
  },
  [dn]: {
    transfer: Po,
    primaries: Co,
    toReference: (o) => o.convertSRGBToLinear(),
    fromReference: (o) => o.convertLinearToSRGB()
  },
  [nl]: {
    transfer: dr,
    primaries: Io,
    toReference: (o) => o.applyMatrix3(Do),
    fromReference: (o) => o.applyMatrix3(Ro)
  },
  [jf]: {
    transfer: Po,
    primaries: Io,
    toReference: (o) => o.convertSRGBToLinear().applyMatrix3(Do),
    fromReference: (o) => o.applyMatrix3(Ro).convertLinearToSRGB()
  }
}, Gf = /* @__PURE__ */ new Set([Fr, nl]), Ct = {
  enabled: !0,
  _workingColorSpace: Fr,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(o) {
    if (!Gf.has(o))
      throw new Error(`Unsupported working color space, "${o}".`);
    this._workingColorSpace = o;
  },
  convert: function(o, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return o;
    const n = qs[e].toReference, s = qs[t].fromReference;
    return s(n(o));
  },
  fromWorkingColorSpace: function(o, e) {
    return this.convert(o, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(o, e) {
    return this.convert(o, e, this._workingColorSpace);
  },
  getPrimaries: function(o) {
    return qs[o].primaries;
  },
  getTransfer: function(o) {
    return o === Hf ? dr : qs[o].transfer;
  }
};
function Vi(o) {
  return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
}
function Yi(o) {
  return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
}
const sl = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, cn = { h: 0, s: 0, l: 0 }, Ks = { h: 0, s: 0, l: 0 };
function Wi(o, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
}
class ci {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = dn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ct.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, s = Ct.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Ct.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, t, n, s = Ct.workingColorSpace) {
    if (e = Nf(e, 1), t = vn(t, 0, 1), n = vn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i;
      this.r = Wi(r, i, e + 1 / 3), this.g = Wi(r, i, e), this.b = Wi(r, i, e - 1 / 3);
    }
    return Ct.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, t = dn) {
    function n(i) {
      i !== void 0 && parseFloat(i) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let i;
      const r = s[1], a = s[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setRGB(
              Math.min(255, parseInt(i[1], 10)) / 255,
              Math.min(255, parseInt(i[2], 10)) / 255,
              Math.min(255, parseInt(i[3], 10)) / 255,
              t
            );
          if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setRGB(
              Math.min(100, parseInt(i[1], 10)) / 100,
              Math.min(100, parseInt(i[2], 10)) / 100,
              Math.min(100, parseInt(i[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setHSL(
              parseFloat(i[1]) / 360,
              parseFloat(i[2]) / 100,
              parseFloat(i[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const i = s[1], r = i.length;
      if (r === 3)
        return this.setRGB(
          parseInt(i.charAt(0), 16) / 15,
          parseInt(i.charAt(1), 16) / 15,
          parseInt(i.charAt(2), 16) / 15,
          t
        );
      if (r === 6)
        return this.setHex(parseInt(i, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = dn) {
    const n = sl[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Vi(e.r), this.g = Vi(e.g), this.b = Vi(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Yi(e.r), this.g = Yi(e.g), this.b = Yi(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = dn) {
    return Ct.fromWorkingColorSpace(it.copy(this), e), Math.round(vn(it.r * 255, 0, 255)) * 65536 + Math.round(vn(it.g * 255, 0, 255)) * 256 + Math.round(vn(it.b * 255, 0, 255));
  }
  getHexString(e = dn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ct.workingColorSpace) {
    Ct.fromWorkingColorSpace(it.copy(this), t);
    const n = it.r, s = it.g, i = it.b, r = Math.max(n, s, i), a = Math.min(n, s, i);
    let l, c;
    const u = (a + r) / 2;
    if (a === r)
      l = 0, c = 0;
    else {
      const h = r - a;
      switch (c = u <= 0.5 ? h / (r + a) : h / (2 - r - a), r) {
        case n:
          l = (s - i) / h + (s < i ? 6 : 0);
          break;
        case s:
          l = (i - n) / h + 2;
          break;
        case i:
          l = (n - s) / h + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = u, e;
  }
  getRGB(e, t = Ct.workingColorSpace) {
    return Ct.fromWorkingColorSpace(it.copy(this), t), e.r = it.r, e.g = it.g, e.b = it.b, e;
  }
  getStyle(e = dn) {
    Ct.fromWorkingColorSpace(it.copy(this), e);
    const t = it.r, n = it.g, s = it.b;
    return e !== dn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(cn), this.setHSL(cn.h + e, cn.s + t, cn.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(cn), e.getHSL(Ks);
    const n = ji(cn.h, Ks.h, t), s = ji(cn.s, Ks.s, t), i = ji(cn.l, Ks.l, t);
    return this.setHSL(n, s, i), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, s = this.b, i = e.elements;
    return this.r = i[0] * t + i[3] * n + i[6] * s, this.g = i[1] * t + i[4] * n + i[7] * s, this.b = i[2] * t + i[5] * n + i[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const it = /* @__PURE__ */ new ci();
ci.NAMES = sl;
class Vf extends Ss {
  constructor(t = {}) {
    super();
    ae(this, "isMeshPhysicalMaterial");
    ae(this, "clearcoatMap");
    ae(this, "clearcoatRoughness");
    ae(this, "clearcoatRoughnessMap");
    ae(this, "clearcoatNormalScale");
    ae(this, "clearcoatNormalMap");
    ae(this, "ior");
    ae(this, "transmissionMap");
    ae(this, "thickness");
    ae(this, "thicknessMap");
    ae(this, "attenuationDistance");
    ae(this, "attenuationColor");
    ae(this, "specularIntensity");
    ae(this, "specularIntensityMap");
    ae(this, "specularColor");
    ae(this, "specularColorMap");
    ae(this, "_clearcoat");
    ae(this, "_transmission");
    this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Lr(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get() {
        return vn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set(n) {
        this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
      }
    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = Number.POSITIVE_INFINITY, this.attenuationColor = new ci(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ci(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
}
const Pg = /* @__PURE__ */ me({
  __name: "index",
  setup(o, { expose: e }) {
    const t = pe(), { extend: n } = ke();
    return n({ MeshGlassMaterial: Vf }), e({ MeshGlassMaterialClass: t }), (s, i) => (ce(), ue("TresMeshGlassMaterial", {
      ref_key: "MeshGlassMaterialClass",
      ref: t
    }, null, 512));
  }
});
var Yf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Is(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
function Qs(o) {
  throw new Error('Could not dynamically require "' + o + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var il = { exports: {} };
(function(o, e) {
  (function(t) {
    o.exports = t();
  })(function() {
    return function t(n, s, i) {
      function r(c, u) {
        if (!s[c]) {
          if (!n[c]) {
            var h = typeof Qs == "function" && Qs;
            if (!u && h)
              return h(c, !0);
            if (a)
              return a(c, !0);
            throw new Error("Cannot find module '" + c + "'");
          }
          u = s[c] = { exports: {} }, n[c][0].call(u.exports, function(f) {
            var p = n[c][1][f];
            return r(p || f);
          }, u, u.exports, t, n, s, i);
        }
        return s[c].exports;
      }
      for (var a = typeof Qs == "function" && Qs, l = 0; l < i.length; l++)
        r(i[l]);
      return r;
    }({ 1: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        var y = t("crypto");
        function g(S, M) {
          M = w(S, M);
          var m;
          return (m = M.algorithm !== "passthrough" ? y.createHash(M.algorithm) : new P()).write === void 0 && (m.write = m.update, m.end = m.update), T(M, m).dispatch(S), m.update || m.end(""), m.digest ? m.digest(M.encoding === "buffer" ? void 0 : M.encoding) : (S = m.read(), M.encoding !== "buffer" ? S.toString(M.encoding) : S);
        }
        (s = n.exports = g).sha1 = function(S) {
          return g(S);
        }, s.keys = function(S) {
          return g(S, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, s.MD5 = function(S) {
          return g(S, { algorithm: "md5", encoding: "hex" });
        }, s.keysMD5 = function(S) {
          return g(S, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var v = y.getHashes ? y.getHashes().slice() : ["sha1", "md5"], d = (v.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function w(S, M) {
          var m = {};
          if (m.algorithm = (M = M || {}).algorithm || "sha1", m.encoding = M.encoding || "hex", m.excludeValues = !!M.excludeValues, m.algorithm = m.algorithm.toLowerCase(), m.encoding = m.encoding.toLowerCase(), m.ignoreUnknown = M.ignoreUnknown === !0, m.respectType = M.respectType !== !1, m.respectFunctionNames = M.respectFunctionNames !== !1, m.respectFunctionProperties = M.respectFunctionProperties !== !1, m.unorderedArrays = M.unorderedArrays === !0, m.unorderedSets = M.unorderedSets !== !1, m.unorderedObjects = M.unorderedObjects !== !1, m.replacer = M.replacer || void 0, m.excludeKeys = M.excludeKeys || void 0, S === void 0)
            throw new Error("Object argument required.");
          for (var b = 0; b < v.length; ++b)
            v[b].toLowerCase() === m.algorithm.toLowerCase() && (m.algorithm = v[b]);
          if (v.indexOf(m.algorithm) === -1)
            throw new Error('Algorithm "' + m.algorithm + '"  not supported. supported values: ' + v.join(", "));
          if (d.indexOf(m.encoding) === -1 && m.algorithm !== "passthrough")
            throw new Error('Encoding "' + m.encoding + '"  not supported. supported values: ' + d.join(", "));
          return m;
        }
        function x(S) {
          if (typeof S == "function")
            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(S)) != null;
        }
        function T(S, M, m) {
          m = m || [];
          function b(_) {
            return M.update ? M.update(_, "utf8") : M.write(_, "utf8");
          }
          return { dispatch: function(_) {
            return this["_" + ((_ = S.replacer ? S.replacer(_) : _) === null ? "null" : typeof _)](_);
          }, _object: function(_) {
            var I, R = Object.prototype.toString.call(_), z = /\[object (.*)\]/i.exec(R);
            if (z = (z = z ? z[1] : "unknown:[" + R + "]").toLowerCase(), 0 <= (R = m.indexOf(_)))
              return this.dispatch("[CIRCULAR:" + R + "]");
            if (m.push(_), a !== void 0 && a.isBuffer && a.isBuffer(_))
              return b("buffer:"), b(_);
            if (z === "object" || z === "function" || z === "asyncfunction")
              return R = Object.keys(_), S.unorderedObjects && (R = R.sort()), S.respectType === !1 || x(_) || R.splice(0, 0, "prototype", "__proto__", "constructor"), S.excludeKeys && (R = R.filter(function(k) {
                return !S.excludeKeys(k);
              })), b("object:" + R.length + ":"), I = this, R.forEach(function(k) {
                I.dispatch(k), b(":"), S.excludeValues || I.dispatch(_[k]), b(",");
              });
            if (!this["_" + z]) {
              if (S.ignoreUnknown)
                return b("[" + z + "]");
              throw new Error('Unknown object type "' + z + '"');
            }
            this["_" + z](_);
          }, _array: function(_, k) {
            k = k !== void 0 ? k : S.unorderedArrays !== !1;
            var R = this;
            if (b("array:" + _.length + ":"), !k || _.length <= 1)
              return _.forEach(function(G) {
                return R.dispatch(G);
              });
            var z = [], k = _.map(function(G) {
              var U = new P(), q = m.slice();
              return T(S, U, q).dispatch(G), z = z.concat(q.slice(m.length)), U.read().toString();
            });
            return m = m.concat(z), k.sort(), this._array(k, !1);
          }, _date: function(_) {
            return b("date:" + _.toJSON());
          }, _symbol: function(_) {
            return b("symbol:" + _.toString());
          }, _error: function(_) {
            return b("error:" + _.toString());
          }, _boolean: function(_) {
            return b("bool:" + _.toString());
          }, _string: function(_) {
            b("string:" + _.length + ":"), b(_.toString());
          }, _function: function(_) {
            b("fn:"), x(_) ? this.dispatch("[native]") : this.dispatch(_.toString()), S.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(_.name)), S.respectFunctionProperties && this._object(_);
          }, _number: function(_) {
            return b("number:" + _.toString());
          }, _xml: function(_) {
            return b("xml:" + _.toString());
          }, _null: function() {
            return b("Null");
          }, _undefined: function() {
            return b("Undefined");
          }, _regexp: function(_) {
            return b("regex:" + _.toString());
          }, _uint8array: function(_) {
            return b("uint8array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _uint8clampedarray: function(_) {
            return b("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(_));
          }, _int8array: function(_) {
            return b("int8array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _uint16array: function(_) {
            return b("uint16array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _int16array: function(_) {
            return b("int16array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _uint32array: function(_) {
            return b("uint32array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _int32array: function(_) {
            return b("int32array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _float32array: function(_) {
            return b("float32array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _float64array: function(_) {
            return b("float64array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _arraybuffer: function(_) {
            return b("arraybuffer:"), this.dispatch(new Uint8Array(_));
          }, _url: function(_) {
            return b("url:" + _.toString());
          }, _map: function(_) {
            return b("map:"), _ = Array.from(_), this._array(_, S.unorderedSets !== !1);
          }, _set: function(_) {
            return b("set:"), _ = Array.from(_), this._array(_, S.unorderedSets !== !1);
          }, _file: function(_) {
            return b("file:"), this.dispatch([_.name, _.size, _.type, _.lastModfied]);
          }, _blob: function() {
            if (S.ignoreUnknown)
              return b("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return b("domwindow");
          }, _bigint: function(_) {
            return b("bigint:" + _.toString());
          }, _process: function() {
            return b("process");
          }, _timer: function() {
            return b("timer");
          }, _pipe: function() {
            return b("pipe");
          }, _tcp: function() {
            return b("tcp");
          }, _udp: function() {
            return b("udp");
          }, _tty: function() {
            return b("tty");
          }, _statwatcher: function() {
            return b("statwatcher");
          }, _securecontext: function() {
            return b("securecontext");
          }, _connection: function() {
            return b("connection");
          }, _zlib: function() {
            return b("zlib");
          }, _context: function() {
            return b("context");
          }, _nodescript: function() {
            return b("nodescript");
          }, _httpparser: function() {
            return b("httpparser");
          }, _dataview: function() {
            return b("dataview");
          }, _signal: function() {
            return b("signal");
          }, _fsevent: function() {
            return b("fsevent");
          }, _tlswrap: function() {
            return b("tlswrap");
          } };
        }
        function P() {
          return { buf: "", write: function(S) {
            this.buf += S;
          }, end: function(S) {
            this.buf += S;
          }, read: function() {
            return this.buf;
          } };
        }
        s.writeToStream = function(S, M, m) {
          return m === void 0 && (m = M, M = {}), T(M = w(S, M), m).dispatch(S);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        (function(y) {
          var g = typeof Uint8Array < "u" ? Uint8Array : Array, v = 43, d = 47, w = 48, x = 97, T = 65, P = 45, S = 95;
          function M(m) {
            return m = m.charCodeAt(0), m === v || m === P ? 62 : m === d || m === S ? 63 : m < w ? -1 : m < w + 10 ? m - w + 26 + 26 : m < T + 26 ? m - T : m < x + 26 ? m - x + 26 : void 0;
          }
          y.toByteArray = function(m) {
            var b, _;
            if (0 < m.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var I = m.length, I = m.charAt(I - 2) === "=" ? 2 : m.charAt(I - 1) === "=" ? 1 : 0, R = new g(3 * m.length / 4 - I), z = 0 < I ? m.length - 4 : m.length, k = 0;
            function G(U) {
              R[k++] = U;
            }
            for (b = 0; b < z; b += 4, 0)
              G((16711680 & (_ = M(m.charAt(b)) << 18 | M(m.charAt(b + 1)) << 12 | M(m.charAt(b + 2)) << 6 | M(m.charAt(b + 3)))) >> 16), G((65280 & _) >> 8), G(255 & _);
            return I == 2 ? G(255 & (_ = M(m.charAt(b)) << 2 | M(m.charAt(b + 1)) >> 4)) : I == 1 && (G((_ = M(m.charAt(b)) << 10 | M(m.charAt(b + 1)) << 4 | M(m.charAt(b + 2)) >> 2) >> 8 & 255), G(255 & _)), R;
          }, y.fromByteArray = function(m) {
            var b, _, I, R, z = m.length % 3, k = "";
            function G(U) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(U);
            }
            for (b = 0, I = m.length - z; b < I; b += 3)
              _ = (m[b] << 16) + (m[b + 1] << 8) + m[b + 2], k += G((R = _) >> 18 & 63) + G(R >> 12 & 63) + G(R >> 6 & 63) + G(63 & R);
            switch (z) {
              case 1:
                k = (k += G((_ = m[m.length - 1]) >> 2)) + G(_ << 4 & 63) + "==";
                break;
              case 2:
                k = (k = (k += G((_ = (m[m.length - 2] << 8) + m[m.length - 1]) >> 10)) + G(_ >> 4 & 63)) + G(_ << 2 & 63) + "=";
            }
            return k;
          };
        })(s === void 0 ? this.base64js = {} : s);
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(t, n, s) {
      (function(i, r, v, l, c, u, h, f, p) {
        var y = t("base64-js"), g = t("ieee754");
        function v(E, A, D) {
          if (!(this instanceof v))
            return new v(E, A, D);
          var W, Y, j, J, ne = typeof E;
          if (A === "base64" && ne == "string")
            for (E = (J = E).trim ? J.trim() : J.replace(/^\s+|\s+$/g, ""); E.length % 4 != 0; )
              E += "=";
          if (ne == "number")
            W = $(E);
          else if (ne == "string")
            W = v.byteLength(E, A);
          else {
            if (ne != "object")
              throw new Error("First argument needs to be a number, array or string.");
            W = $(E.length);
          }
          if (v._useTypedArrays ? Y = v._augment(new Uint8Array(W)) : ((Y = this).length = W, Y._isBuffer = !0), v._useTypedArrays && typeof E.byteLength == "number")
            Y._set(E);
          else if (te(J = E) || v.isBuffer(J) || J && typeof J == "object" && typeof J.length == "number")
            for (j = 0; j < W; j++)
              v.isBuffer(E) ? Y[j] = E.readUInt8(j) : Y[j] = E[j];
          else if (ne == "string")
            Y.write(E, 0, A);
          else if (ne == "number" && !v._useTypedArrays && !D)
            for (j = 0; j < W; j++)
              Y[j] = 0;
          return Y;
        }
        function d(E, A, D, W) {
          return v._charsWritten = xe(function(Y) {
            for (var j = [], J = 0; J < Y.length; J++)
              j.push(255 & Y.charCodeAt(J));
            return j;
          }(A), E, D, W);
        }
        function w(E, A, D, W) {
          return v._charsWritten = xe(function(Y) {
            for (var j, J, ne = [], se = 0; se < Y.length; se++)
              J = Y.charCodeAt(se), j = J >> 8, J = J % 256, ne.push(J), ne.push(j);
            return ne;
          }(A), E, D, W);
        }
        function x(E, A, D) {
          var W = "";
          D = Math.min(E.length, D);
          for (var Y = A; Y < D; Y++)
            W += String.fromCharCode(E[Y]);
          return W;
        }
        function T(E, A, D, j) {
          j || (N(typeof D == "boolean", "missing or invalid endian"), N(A != null, "missing offset"), N(A + 1 < E.length, "Trying to read beyond buffer length"));
          var Y, j = E.length;
          if (!(j <= A))
            return D ? (Y = E[A], A + 1 < j && (Y |= E[A + 1] << 8)) : (Y = E[A] << 8, A + 1 < j && (Y |= E[A + 1])), Y;
        }
        function P(E, A, D, j) {
          j || (N(typeof D == "boolean", "missing or invalid endian"), N(A != null, "missing offset"), N(A + 3 < E.length, "Trying to read beyond buffer length"));
          var Y, j = E.length;
          if (!(j <= A))
            return D ? (A + 2 < j && (Y = E[A + 2] << 16), A + 1 < j && (Y |= E[A + 1] << 8), Y |= E[A], A + 3 < j && (Y += E[A + 3] << 24 >>> 0)) : (A + 1 < j && (Y = E[A + 1] << 16), A + 2 < j && (Y |= E[A + 2] << 8), A + 3 < j && (Y |= E[A + 3]), Y += E[A] << 24 >>> 0), Y;
        }
        function S(E, A, D, W) {
          if (W || (N(typeof D == "boolean", "missing or invalid endian"), N(A != null, "missing offset"), N(A + 1 < E.length, "Trying to read beyond buffer length")), !(E.length <= A))
            return W = T(E, A, D, !0), 32768 & W ? -1 * (65535 - W + 1) : W;
        }
        function M(E, A, D, W) {
          if (W || (N(typeof D == "boolean", "missing or invalid endian"), N(A != null, "missing offset"), N(A + 3 < E.length, "Trying to read beyond buffer length")), !(E.length <= A))
            return W = P(E, A, D, !0), 2147483648 & W ? -1 * (4294967295 - W + 1) : W;
        }
        function m(E, A, D, W) {
          return W || (N(typeof D == "boolean", "missing or invalid endian"), N(A + 3 < E.length, "Trying to read beyond buffer length")), g.read(E, A, D, 23, 4);
        }
        function b(E, A, D, W) {
          return W || (N(typeof D == "boolean", "missing or invalid endian"), N(A + 7 < E.length, "Trying to read beyond buffer length")), g.read(E, A, D, 52, 8);
        }
        function _(E, A, D, W, Y) {
          if (Y || (N(A != null, "missing value"), N(typeof W == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 1 < E.length, "trying to write beyond buffer length"), B(A, 65535)), Y = E.length, !(Y <= D))
            for (var j = 0, J = Math.min(Y - D, 2); j < J; j++)
              E[D + j] = (A & 255 << 8 * (W ? j : 1 - j)) >>> 8 * (W ? j : 1 - j);
        }
        function I(E, A, D, W, Y) {
          if (Y || (N(A != null, "missing value"), N(typeof W == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 3 < E.length, "trying to write beyond buffer length"), B(A, 4294967295)), Y = E.length, !(Y <= D))
            for (var j = 0, J = Math.min(Y - D, 4); j < J; j++)
              E[D + j] = A >>> 8 * (W ? j : 3 - j) & 255;
        }
        function R(E, A, D, W, Y) {
          Y || (N(A != null, "missing value"), N(typeof W == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 1 < E.length, "Trying to write beyond buffer length"), L(A, 32767, -32768)), E.length <= D || _(E, 0 <= A ? A : 65535 + A + 1, D, W, Y);
        }
        function z(E, A, D, W, Y) {
          Y || (N(A != null, "missing value"), N(typeof W == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 3 < E.length, "Trying to write beyond buffer length"), L(A, 2147483647, -2147483648)), E.length <= D || I(E, 0 <= A ? A : 4294967295 + A + 1, D, W, Y);
        }
        function k(E, A, D, W, Y) {
          Y || (N(A != null, "missing value"), N(typeof W == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 3 < E.length, "Trying to write beyond buffer length"), O(A, 34028234663852886e22, -34028234663852886e22)), E.length <= D || g.write(E, A, D, W, 23, 4);
        }
        function G(E, A, D, W, Y) {
          Y || (N(A != null, "missing value"), N(typeof W == "boolean", "missing or invalid endian"), N(D != null, "missing offset"), N(D + 7 < E.length, "Trying to write beyond buffer length"), O(A, 17976931348623157e292, -17976931348623157e292)), E.length <= D || g.write(E, A, D, W, 52, 8);
        }
        s.Buffer = v, s.SlowBuffer = v, s.INSPECT_MAX_BYTES = 50, v.poolSize = 8192, v._useTypedArrays = function() {
          try {
            var E = new ArrayBuffer(0), A = new Uint8Array(E);
            return A.foo = function() {
              return 42;
            }, A.foo() === 42 && typeof A.subarray == "function";
          } catch {
            return !1;
          }
        }(), v.isEncoding = function(E) {
          switch (String(E).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, v.isBuffer = function(E) {
          return !(E == null || !E._isBuffer);
        }, v.byteLength = function(E, A) {
          var D;
          switch (E += "", A || "utf8") {
            case "hex":
              D = E.length / 2;
              break;
            case "utf8":
            case "utf-8":
              D = oe(E).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              D = E.length;
              break;
            case "base64":
              D = de(E).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              D = 2 * E.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return D;
        }, v.concat = function(E, A) {
          if (N(te(E), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), E.length === 0)
            return new v(0);
          if (E.length === 1)
            return E[0];
          if (typeof A != "number")
            for (Y = A = 0; Y < E.length; Y++)
              A += E[Y].length;
          for (var D = new v(A), W = 0, Y = 0; Y < E.length; Y++) {
            var j = E[Y];
            j.copy(D, W), W += j.length;
          }
          return D;
        }, v.prototype.write = function(E, A, D, W) {
          isFinite(A) ? isFinite(D) || (W = D, D = void 0) : (se = W, W = A, A = D, D = se), A = Number(A) || 0;
          var Y, j, J, ne, se = this.length - A;
          switch ((!D || se < (D = Number(D))) && (D = se), W = String(W || "utf8").toLowerCase()) {
            case "hex":
              Y = function(V, F, re, fe) {
                re = Number(re) || 0;
                var Me = V.length - re;
                (!fe || Me < (fe = Number(fe))) && (fe = Me), N((Me = F.length) % 2 == 0, "Invalid hex string"), Me / 2 < fe && (fe = Me / 2);
                for (var Xe = 0; Xe < fe; Xe++) {
                  var je = parseInt(F.substr(2 * Xe, 2), 16);
                  N(!isNaN(je), "Invalid hex string"), V[re + Xe] = je;
                }
                return v._charsWritten = 2 * Xe, Xe;
              }(this, E, A, D);
              break;
            case "utf8":
            case "utf-8":
              j = this, J = A, ne = D, Y = v._charsWritten = xe(oe(E), j, J, ne);
              break;
            case "ascii":
            case "binary":
              Y = d(this, E, A, D);
              break;
            case "base64":
              j = this, J = A, ne = D, Y = v._charsWritten = xe(de(E), j, J, ne);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              Y = w(this, E, A, D);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return Y;
        }, v.prototype.toString = function(E, A, D) {
          var W, Y, j, J, ne = this;
          if (E = String(E || "utf8").toLowerCase(), A = Number(A) || 0, (D = D !== void 0 ? Number(D) : ne.length) === A)
            return "";
          switch (E) {
            case "hex":
              W = function(se, V, F) {
                var re = se.length;
                (!V || V < 0) && (V = 0), (!F || F < 0 || re < F) && (F = re);
                for (var fe = "", Me = V; Me < F; Me++)
                  fe += ee(se[Me]);
                return fe;
              }(ne, A, D);
              break;
            case "utf8":
            case "utf-8":
              W = function(se, V, F) {
                var re = "", fe = "";
                F = Math.min(se.length, F);
                for (var Me = V; Me < F; Me++)
                  se[Me] <= 127 ? (re += C(fe) + String.fromCharCode(se[Me]), fe = "") : fe += "%" + se[Me].toString(16);
                return re + C(fe);
              }(ne, A, D);
              break;
            case "ascii":
            case "binary":
              W = x(ne, A, D);
              break;
            case "base64":
              Y = ne, J = D, W = (j = A) === 0 && J === Y.length ? y.fromByteArray(Y) : y.fromByteArray(Y.slice(j, J));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              W = function(se, V, F) {
                for (var re = se.slice(V, F), fe = "", Me = 0; Me < re.length; Me += 2)
                  fe += String.fromCharCode(re[Me] + 256 * re[Me + 1]);
                return fe;
              }(ne, A, D);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return W;
        }, v.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, v.prototype.copy = function(E, A, D, W) {
          if (A = A || 0, (W = W || W === 0 ? W : this.length) !== (D = D || 0) && E.length !== 0 && this.length !== 0) {
            N(D <= W, "sourceEnd < sourceStart"), N(0 <= A && A < E.length, "targetStart out of bounds"), N(0 <= D && D < this.length, "sourceStart out of bounds"), N(0 <= W && W <= this.length, "sourceEnd out of bounds"), W > this.length && (W = this.length);
            var Y = (W = E.length - A < W - D ? E.length - A + D : W) - D;
            if (Y < 100 || !v._useTypedArrays)
              for (var j = 0; j < Y; j++)
                E[j + A] = this[j + D];
            else
              E._set(this.subarray(D, D + Y), A);
          }
        }, v.prototype.slice = function(E, A) {
          var D = this.length;
          if (E = q(E, D, 0), A = q(A, D, D), v._useTypedArrays)
            return v._augment(this.subarray(E, A));
          for (var W = A - E, Y = new v(W, void 0, !0), j = 0; j < W; j++)
            Y[j] = this[j + E];
          return Y;
        }, v.prototype.get = function(E) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(E);
        }, v.prototype.set = function(E, A) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(E, A);
        }, v.prototype.readUInt8 = function(E, A) {
          if (A || (N(E != null, "missing offset"), N(E < this.length, "Trying to read beyond buffer length")), !(E >= this.length))
            return this[E];
        }, v.prototype.readUInt16LE = function(E, A) {
          return T(this, E, !0, A);
        }, v.prototype.readUInt16BE = function(E, A) {
          return T(this, E, !1, A);
        }, v.prototype.readUInt32LE = function(E, A) {
          return P(this, E, !0, A);
        }, v.prototype.readUInt32BE = function(E, A) {
          return P(this, E, !1, A);
        }, v.prototype.readInt8 = function(E, A) {
          if (A || (N(E != null, "missing offset"), N(E < this.length, "Trying to read beyond buffer length")), !(E >= this.length))
            return 128 & this[E] ? -1 * (255 - this[E] + 1) : this[E];
        }, v.prototype.readInt16LE = function(E, A) {
          return S(this, E, !0, A);
        }, v.prototype.readInt16BE = function(E, A) {
          return S(this, E, !1, A);
        }, v.prototype.readInt32LE = function(E, A) {
          return M(this, E, !0, A);
        }, v.prototype.readInt32BE = function(E, A) {
          return M(this, E, !1, A);
        }, v.prototype.readFloatLE = function(E, A) {
          return m(this, E, !0, A);
        }, v.prototype.readFloatBE = function(E, A) {
          return m(this, E, !1, A);
        }, v.prototype.readDoubleLE = function(E, A) {
          return b(this, E, !0, A);
        }, v.prototype.readDoubleBE = function(E, A) {
          return b(this, E, !1, A);
        }, v.prototype.writeUInt8 = function(E, A, D) {
          D || (N(E != null, "missing value"), N(A != null, "missing offset"), N(A < this.length, "trying to write beyond buffer length"), B(E, 255)), A >= this.length || (this[A] = E);
        }, v.prototype.writeUInt16LE = function(E, A, D) {
          _(this, E, A, !0, D);
        }, v.prototype.writeUInt16BE = function(E, A, D) {
          _(this, E, A, !1, D);
        }, v.prototype.writeUInt32LE = function(E, A, D) {
          I(this, E, A, !0, D);
        }, v.prototype.writeUInt32BE = function(E, A, D) {
          I(this, E, A, !1, D);
        }, v.prototype.writeInt8 = function(E, A, D) {
          D || (N(E != null, "missing value"), N(A != null, "missing offset"), N(A < this.length, "Trying to write beyond buffer length"), L(E, 127, -128)), A >= this.length || (0 <= E ? this.writeUInt8(E, A, D) : this.writeUInt8(255 + E + 1, A, D));
        }, v.prototype.writeInt16LE = function(E, A, D) {
          R(this, E, A, !0, D);
        }, v.prototype.writeInt16BE = function(E, A, D) {
          R(this, E, A, !1, D);
        }, v.prototype.writeInt32LE = function(E, A, D) {
          z(this, E, A, !0, D);
        }, v.prototype.writeInt32BE = function(E, A, D) {
          z(this, E, A, !1, D);
        }, v.prototype.writeFloatLE = function(E, A, D) {
          k(this, E, A, !0, D);
        }, v.prototype.writeFloatBE = function(E, A, D) {
          k(this, E, A, !1, D);
        }, v.prototype.writeDoubleLE = function(E, A, D) {
          G(this, E, A, !0, D);
        }, v.prototype.writeDoubleBE = function(E, A, D) {
          G(this, E, A, !1, D);
        }, v.prototype.fill = function(E, A, D) {
          if (A = A || 0, D = D || this.length, N(typeof (E = typeof (E = E || 0) == "string" ? E.charCodeAt(0) : E) == "number" && !isNaN(E), "value is not a number"), N(A <= D, "end < start"), D !== A && this.length !== 0) {
            N(0 <= A && A < this.length, "start out of bounds"), N(0 <= D && D <= this.length, "end out of bounds");
            for (var W = A; W < D; W++)
              this[W] = E;
          }
        }, v.prototype.inspect = function() {
          for (var E = [], A = this.length, D = 0; D < A; D++)
            if (E[D] = ee(this[D]), D === s.INSPECT_MAX_BYTES) {
              E[D + 1] = "...";
              break;
            }
          return "<Buffer " + E.join(" ") + ">";
        }, v.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u")
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (v._useTypedArrays)
            return new v(this).buffer;
          for (var E = new Uint8Array(this.length), A = 0, D = E.length; A < D; A += 1)
            E[A] = this[A];
          return E.buffer;
        };
        var U = v.prototype;
        function q(E, A, D) {
          return typeof E != "number" ? D : A <= (E = ~~E) ? A : 0 <= E || 0 <= (E += A) ? E : 0;
        }
        function $(E) {
          return (E = ~~Math.ceil(+E)) < 0 ? 0 : E;
        }
        function te(E) {
          return (Array.isArray || function(A) {
            return Object.prototype.toString.call(A) === "[object Array]";
          })(E);
        }
        function ee(E) {
          return E < 16 ? "0" + E.toString(16) : E.toString(16);
        }
        function oe(E) {
          for (var A = [], D = 0; D < E.length; D++) {
            var W = E.charCodeAt(D);
            if (W <= 127)
              A.push(E.charCodeAt(D));
            else
              for (var Y = D, j = (55296 <= W && W <= 57343 && D++, encodeURIComponent(E.slice(Y, D + 1)).substr(1).split("%")), J = 0; J < j.length; J++)
                A.push(parseInt(j[J], 16));
          }
          return A;
        }
        function de(E) {
          return y.toByteArray(E);
        }
        function xe(E, A, D, W) {
          for (var Y = 0; Y < W && !(Y + D >= A.length || Y >= E.length); Y++)
            A[Y + D] = E[Y];
          return Y;
        }
        function C(E) {
          try {
            return decodeURIComponent(E);
          } catch {
            return "";
          }
        }
        function B(E, A) {
          N(typeof E == "number", "cannot write a non-number as a number"), N(0 <= E, "specified a negative value for writing an unsigned value"), N(E <= A, "value is larger than maximum value for type"), N(Math.floor(E) === E, "value has a fractional component");
        }
        function L(E, A, D) {
          N(typeof E == "number", "cannot write a non-number as a number"), N(E <= A, "value larger than maximum allowed value"), N(D <= E, "value smaller than minimum allowed value"), N(Math.floor(E) === E, "value has a fractional component");
        }
        function O(E, A, D) {
          N(typeof E == "number", "cannot write a non-number as a number"), N(E <= A, "value larger than maximum allowed value"), N(D <= E, "value smaller than minimum allowed value");
        }
        function N(E, A) {
          if (!E)
            throw new Error(A || "Failed assertion");
        }
        v._augment = function(E) {
          return E._isBuffer = !0, E._get = E.get, E._set = E.set, E.get = U.get, E.set = U.set, E.write = U.write, E.toString = U.toString, E.toLocaleString = U.toString, E.toJSON = U.toJSON, E.copy = U.copy, E.slice = U.slice, E.readUInt8 = U.readUInt8, E.readUInt16LE = U.readUInt16LE, E.readUInt16BE = U.readUInt16BE, E.readUInt32LE = U.readUInt32LE, E.readUInt32BE = U.readUInt32BE, E.readInt8 = U.readInt8, E.readInt16LE = U.readInt16LE, E.readInt16BE = U.readInt16BE, E.readInt32LE = U.readInt32LE, E.readInt32BE = U.readInt32BE, E.readFloatLE = U.readFloatLE, E.readFloatBE = U.readFloatBE, E.readDoubleLE = U.readDoubleLE, E.readDoubleBE = U.readDoubleBE, E.writeUInt8 = U.writeUInt8, E.writeUInt16LE = U.writeUInt16LE, E.writeUInt16BE = U.writeUInt16BE, E.writeUInt32LE = U.writeUInt32LE, E.writeUInt32BE = U.writeUInt32BE, E.writeInt8 = U.writeInt8, E.writeInt16LE = U.writeInt16LE, E.writeInt16BE = U.writeInt16BE, E.writeInt32LE = U.writeInt32LE, E.writeInt32BE = U.writeInt32BE, E.writeFloatLE = U.writeFloatLE, E.writeFloatBE = U.writeFloatBE, E.writeDoubleLE = U.writeDoubleLE, E.writeDoubleBE = U.writeDoubleBE, E.fill = U.fill, E.inspect = U.inspect, E.toArrayBuffer = U.toArrayBuffer, E;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(t, n, s) {
      (function(i, r, y, l, c, u, h, f, p) {
        var y = t("buffer").Buffer, g = 4, v = new y(g);
        v.fill(0), n.exports = { hash: function(d, w, x, T) {
          for (var P = w(function(_, I) {
            _.length % g != 0 && (R = _.length + (g - _.length % g), _ = y.concat([_, v], R));
            for (var R, z = [], k = I ? _.readInt32BE : _.readInt32LE, G = 0; G < _.length; G += g)
              z.push(k.call(_, G));
            return z;
          }(d = y.isBuffer(d) ? d : new y(d), T), 8 * d.length), w = T, S = new y(x), M = w ? S.writeInt32BE : S.writeInt32LE, m = 0; m < P.length; m++)
            M.call(S, P[m], 4 * m, !0);
          return S;
        } };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(t, n, s) {
      (function(i, r, y, l, c, u, h, f, p) {
        var y = t("buffer").Buffer, g = t("./sha"), v = t("./sha256"), d = t("./rng"), w = { sha1: g, sha256: v, md5: t("./md5") }, x = 64, T = new y(x);
        function P(_, I) {
          var R = w[_ = _ || "sha1"], z = [];
          return R || S("algorithm:", _, "is not yet supported"), { update: function(k) {
            return y.isBuffer(k) || (k = new y(k)), z.push(k), k.length, this;
          }, digest: function(k) {
            var G = y.concat(z), G = I ? function(U, q, $) {
              y.isBuffer(q) || (q = new y(q)), y.isBuffer($) || ($ = new y($)), q.length > x ? q = U(q) : q.length < x && (q = y.concat([q, T], x));
              for (var te = new y(x), ee = new y(x), oe = 0; oe < x; oe++)
                te[oe] = 54 ^ q[oe], ee[oe] = 92 ^ q[oe];
              return $ = U(y.concat([te, $])), U(y.concat([ee, $]));
            }(R, I, G) : R(G);
            return z = null, k ? G.toString(k) : G;
          } };
        }
        function S() {
          var _ = [].slice.call(arguments).join(" ");
          throw new Error([_, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        T.fill(0), s.createHash = function(_) {
          return P(_);
        }, s.createHmac = P, s.randomBytes = function(_, I) {
          if (!I || !I.call)
            return new y(d(_));
          try {
            I.call(this, void 0, new y(d(_)));
          } catch (R) {
            I(R);
          }
        };
        var M, m = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], b = function(_) {
          s[_] = function() {
            S("sorry,", _, "is not implemented yet");
          };
        };
        for (M in m)
          b(m[M]);
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        var y = t("./helpers");
        function g(S, M) {
          S[M >> 5] |= 128 << M % 32, S[14 + (M + 64 >>> 9 << 4)] = M;
          for (var m = 1732584193, b = -271733879, _ = -1732584194, I = 271733878, R = 0; R < S.length; R += 16) {
            var z = m, k = b, G = _, U = I, m = d(m, b, _, I, S[R + 0], 7, -680876936), I = d(I, m, b, _, S[R + 1], 12, -389564586), _ = d(_, I, m, b, S[R + 2], 17, 606105819), b = d(b, _, I, m, S[R + 3], 22, -1044525330);
            m = d(m, b, _, I, S[R + 4], 7, -176418897), I = d(I, m, b, _, S[R + 5], 12, 1200080426), _ = d(_, I, m, b, S[R + 6], 17, -1473231341), b = d(b, _, I, m, S[R + 7], 22, -45705983), m = d(m, b, _, I, S[R + 8], 7, 1770035416), I = d(I, m, b, _, S[R + 9], 12, -1958414417), _ = d(_, I, m, b, S[R + 10], 17, -42063), b = d(b, _, I, m, S[R + 11], 22, -1990404162), m = d(m, b, _, I, S[R + 12], 7, 1804603682), I = d(I, m, b, _, S[R + 13], 12, -40341101), _ = d(_, I, m, b, S[R + 14], 17, -1502002290), m = w(m, b = d(b, _, I, m, S[R + 15], 22, 1236535329), _, I, S[R + 1], 5, -165796510), I = w(I, m, b, _, S[R + 6], 9, -1069501632), _ = w(_, I, m, b, S[R + 11], 14, 643717713), b = w(b, _, I, m, S[R + 0], 20, -373897302), m = w(m, b, _, I, S[R + 5], 5, -701558691), I = w(I, m, b, _, S[R + 10], 9, 38016083), _ = w(_, I, m, b, S[R + 15], 14, -660478335), b = w(b, _, I, m, S[R + 4], 20, -405537848), m = w(m, b, _, I, S[R + 9], 5, 568446438), I = w(I, m, b, _, S[R + 14], 9, -1019803690), _ = w(_, I, m, b, S[R + 3], 14, -187363961), b = w(b, _, I, m, S[R + 8], 20, 1163531501), m = w(m, b, _, I, S[R + 13], 5, -1444681467), I = w(I, m, b, _, S[R + 2], 9, -51403784), _ = w(_, I, m, b, S[R + 7], 14, 1735328473), m = x(m, b = w(b, _, I, m, S[R + 12], 20, -1926607734), _, I, S[R + 5], 4, -378558), I = x(I, m, b, _, S[R + 8], 11, -2022574463), _ = x(_, I, m, b, S[R + 11], 16, 1839030562), b = x(b, _, I, m, S[R + 14], 23, -35309556), m = x(m, b, _, I, S[R + 1], 4, -1530992060), I = x(I, m, b, _, S[R + 4], 11, 1272893353), _ = x(_, I, m, b, S[R + 7], 16, -155497632), b = x(b, _, I, m, S[R + 10], 23, -1094730640), m = x(m, b, _, I, S[R + 13], 4, 681279174), I = x(I, m, b, _, S[R + 0], 11, -358537222), _ = x(_, I, m, b, S[R + 3], 16, -722521979), b = x(b, _, I, m, S[R + 6], 23, 76029189), m = x(m, b, _, I, S[R + 9], 4, -640364487), I = x(I, m, b, _, S[R + 12], 11, -421815835), _ = x(_, I, m, b, S[R + 15], 16, 530742520), m = T(m, b = x(b, _, I, m, S[R + 2], 23, -995338651), _, I, S[R + 0], 6, -198630844), I = T(I, m, b, _, S[R + 7], 10, 1126891415), _ = T(_, I, m, b, S[R + 14], 15, -1416354905), b = T(b, _, I, m, S[R + 5], 21, -57434055), m = T(m, b, _, I, S[R + 12], 6, 1700485571), I = T(I, m, b, _, S[R + 3], 10, -1894986606), _ = T(_, I, m, b, S[R + 10], 15, -1051523), b = T(b, _, I, m, S[R + 1], 21, -2054922799), m = T(m, b, _, I, S[R + 8], 6, 1873313359), I = T(I, m, b, _, S[R + 15], 10, -30611744), _ = T(_, I, m, b, S[R + 6], 15, -1560198380), b = T(b, _, I, m, S[R + 13], 21, 1309151649), m = T(m, b, _, I, S[R + 4], 6, -145523070), I = T(I, m, b, _, S[R + 11], 10, -1120210379), _ = T(_, I, m, b, S[R + 2], 15, 718787259), b = T(b, _, I, m, S[R + 9], 21, -343485551), m = P(m, z), b = P(b, k), _ = P(_, G), I = P(I, U);
          }
          return Array(m, b, _, I);
        }
        function v(S, M, m, b, _, I) {
          return P((M = P(P(M, S), P(b, I))) << _ | M >>> 32 - _, m);
        }
        function d(S, M, m, b, _, I, R) {
          return v(M & m | ~M & b, S, M, _, I, R);
        }
        function w(S, M, m, b, _, I, R) {
          return v(M & b | m & ~b, S, M, _, I, R);
        }
        function x(S, M, m, b, _, I, R) {
          return v(M ^ m ^ b, S, M, _, I, R);
        }
        function T(S, M, m, b, _, I, R) {
          return v(m ^ (M | ~b), S, M, _, I, R);
        }
        function P(S, M) {
          var m = (65535 & S) + (65535 & M);
          return (S >> 16) + (M >> 16) + (m >> 16) << 16 | 65535 & m;
        }
        n.exports = function(S) {
          return y.hash(S, g, 16);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        n.exports = function(y) {
          for (var g, v = new Array(y), d = 0; d < y; d++)
            !(3 & d) && (g = 4294967296 * Math.random()), v[d] = g >>> ((3 & d) << 3) & 255;
          return v;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        var y = t("./helpers");
        function g(w, x) {
          w[x >> 5] |= 128 << 24 - x % 32, w[15 + (x + 64 >> 9 << 4)] = x;
          for (var T, P, S, M = Array(80), m = 1732584193, b = -271733879, _ = -1732584194, I = 271733878, R = -1009589776, z = 0; z < w.length; z += 16) {
            for (var k = m, G = b, U = _, q = I, $ = R, te = 0; te < 80; te++) {
              M[te] = te < 16 ? w[z + te] : d(M[te - 3] ^ M[te - 8] ^ M[te - 14] ^ M[te - 16], 1);
              var ee = v(v(d(m, 5), (ee = b, P = _, S = I, (T = te) < 20 ? ee & P | ~ee & S : !(T < 40) && T < 60 ? ee & P | ee & S | P & S : ee ^ P ^ S)), v(v(R, M[te]), (T = te) < 20 ? 1518500249 : T < 40 ? 1859775393 : T < 60 ? -1894007588 : -899497514)), R = I, I = _, _ = d(b, 30), b = m, m = ee;
            }
            m = v(m, k), b = v(b, G), _ = v(_, U), I = v(I, q), R = v(R, $);
          }
          return Array(m, b, _, I, R);
        }
        function v(w, x) {
          var T = (65535 & w) + (65535 & x);
          return (w >> 16) + (x >> 16) + (T >> 16) << 16 | 65535 & T;
        }
        function d(w, x) {
          return w << x | w >>> 32 - x;
        }
        n.exports = function(w) {
          return y.hash(w, g, 20, !0);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        function y(x, T) {
          var P = (65535 & x) + (65535 & T);
          return (x >> 16) + (T >> 16) + (P >> 16) << 16 | 65535 & P;
        }
        function g(x, T) {
          var P, S = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), M = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), m = new Array(64);
          x[T >> 5] |= 128 << 24 - T % 32, x[15 + (T + 64 >> 9 << 4)] = T;
          for (var b, _, I = 0; I < x.length; I += 16) {
            for (var R = M[0], z = M[1], k = M[2], G = M[3], U = M[4], q = M[5], $ = M[6], te = M[7], ee = 0; ee < 64; ee++)
              m[ee] = ee < 16 ? x[ee + I] : y(y(y((_ = m[ee - 2], d(_, 17) ^ d(_, 19) ^ w(_, 10)), m[ee - 7]), (_ = m[ee - 15], d(_, 7) ^ d(_, 18) ^ w(_, 3))), m[ee - 16]), P = y(y(y(y(te, d(_ = U, 6) ^ d(_, 11) ^ d(_, 25)), U & q ^ ~U & $), S[ee]), m[ee]), b = y(d(b = R, 2) ^ d(b, 13) ^ d(b, 22), R & z ^ R & k ^ z & k), te = $, $ = q, q = U, U = y(G, P), G = k, k = z, z = R, R = y(P, b);
            M[0] = y(R, M[0]), M[1] = y(z, M[1]), M[2] = y(k, M[2]), M[3] = y(G, M[3]), M[4] = y(U, M[4]), M[5] = y(q, M[5]), M[6] = y($, M[6]), M[7] = y(te, M[7]);
          }
          return M;
        }
        var v = t("./helpers"), d = function(x, T) {
          return x >>> T | x << 32 - T;
        }, w = function(x, T) {
          return x >>> T;
        };
        n.exports = function(x) {
          return v.hash(x, g, 32, !0);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        s.read = function(y, g, v, d, I) {
          var x, T, P = 8 * I - d - 1, S = (1 << P) - 1, M = S >> 1, m = -7, b = v ? I - 1 : 0, _ = v ? -1 : 1, I = y[g + b];
          for (b += _, x = I & (1 << -m) - 1, I >>= -m, m += P; 0 < m; x = 256 * x + y[g + b], b += _, m -= 8)
            ;
          for (T = x & (1 << -m) - 1, x >>= -m, m += d; 0 < m; T = 256 * T + y[g + b], b += _, m -= 8)
            ;
          if (x === 0)
            x = 1 - M;
          else {
            if (x === S)
              return T ? NaN : 1 / 0 * (I ? -1 : 1);
            T += Math.pow(2, d), x -= M;
          }
          return (I ? -1 : 1) * T * Math.pow(2, x - d);
        }, s.write = function(y, g, v, d, w, R) {
          var T, P, S = 8 * R - w - 1, M = (1 << S) - 1, m = M >> 1, b = w === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, _ = d ? 0 : R - 1, I = d ? 1 : -1, R = g < 0 || g === 0 && 1 / g < 0 ? 1 : 0;
          for (g = Math.abs(g), isNaN(g) || g === 1 / 0 ? (P = isNaN(g) ? 1 : 0, T = M) : (T = Math.floor(Math.log(g) / Math.LN2), g * (d = Math.pow(2, -T)) < 1 && (T--, d *= 2), 2 <= (g += 1 <= T + m ? b / d : b * Math.pow(2, 1 - m)) * d && (T++, d /= 2), M <= T + m ? (P = 0, T = M) : 1 <= T + m ? (P = (g * d - 1) * Math.pow(2, w), T += m) : (P = g * Math.pow(2, m - 1) * Math.pow(2, w), T = 0)); 8 <= w; y[v + _] = 255 & P, _ += I, P /= 256, w -= 8)
            ;
          for (T = T << w | P, S += w; 0 < S; y[v + _] = 255 & T, _ += I, T /= 256, S -= 8)
            ;
          y[v + _ - I] |= 128 * R;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(t, n, s) {
      (function(i, r, a, l, c, u, h, f, p) {
        var y, g, v;
        function d() {
        }
        (i = n.exports = {}).nextTick = (g = typeof window < "u" && window.setImmediate, v = typeof window < "u" && window.postMessage && window.addEventListener, g ? function(w) {
          return window.setImmediate(w);
        } : v ? (y = [], window.addEventListener("message", function(w) {
          var x = w.source;
          x !== window && x !== null || w.data !== "process-tick" || (w.stopPropagation(), 0 < y.length && y.shift()());
        }, !0), function(w) {
          y.push(w), window.postMessage("process-tick", "*");
        }) : function(w) {
          setTimeout(w, 0);
        }), i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.on = d, i.addListener = d, i.once = d, i.off = d, i.removeListener = d, i.removeAllListeners = d, i.emit = d, i.binding = function(w) {
          throw new Error("process.binding is not supported");
        }, i.cwd = function() {
          return "/";
        }, i.chdir = function(w) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(il);
var Wf = il.exports;
const Xf = /* @__PURE__ */ Is(Wf);
var rl = [
  // current
  "precision",
  "highp",
  "mediump",
  "lowp",
  "attribute",
  "const",
  "uniform",
  "varying",
  "break",
  "continue",
  "do",
  "for",
  "while",
  "if",
  "else",
  "in",
  "out",
  "inout",
  "float",
  "int",
  "uint",
  "void",
  "bool",
  "true",
  "false",
  "discard",
  "return",
  "mat2",
  "mat3",
  "mat4",
  "vec2",
  "vec3",
  "vec4",
  "ivec2",
  "ivec3",
  "ivec4",
  "bvec2",
  "bvec3",
  "bvec4",
  "sampler1D",
  "sampler2D",
  "sampler3D",
  "samplerCube",
  "sampler1DShadow",
  "sampler2DShadow",
  "struct",
  "asm",
  "class",
  "union",
  "enum",
  "typedef",
  "template",
  "this",
  "packed",
  "goto",
  "switch",
  "default",
  "inline",
  "noinline",
  "volatile",
  "public",
  "static",
  "extern",
  "external",
  "interface",
  "long",
  "short",
  "double",
  "half",
  "fixed",
  "unsigned",
  "input",
  "output",
  "hvec2",
  "hvec3",
  "hvec4",
  "dvec2",
  "dvec3",
  "dvec4",
  "fvec2",
  "fvec3",
  "fvec4",
  "sampler2DRect",
  "sampler3DRect",
  "sampler2DRectShadow",
  "sizeof",
  "cast",
  "namespace",
  "using"
], $f = [
  "<<=",
  ">>=",
  "++",
  "--",
  "<<",
  ">>",
  "<=",
  ">=",
  "==",
  "!=",
  "&&",
  "||",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "&=",
  "^^",
  "^=",
  "|=",
  "(",
  ")",
  "[",
  "]",
  ".",
  "!",
  "~",
  "*",
  "/",
  "%",
  "+",
  "-",
  "<",
  ">",
  "&",
  "^",
  "|",
  "?",
  ":",
  "=",
  ",",
  ";",
  "{",
  "}"
], ol = [
  // Keep this list sorted
  "abs",
  "acos",
  "all",
  "any",
  "asin",
  "atan",
  "ceil",
  "clamp",
  "cos",
  "cross",
  "dFdx",
  "dFdy",
  "degrees",
  "distance",
  "dot",
  "equal",
  "exp",
  "exp2",
  "faceforward",
  "floor",
  "fract",
  "gl_BackColor",
  "gl_BackLightModelProduct",
  "gl_BackLightProduct",
  "gl_BackMaterial",
  "gl_BackSecondaryColor",
  "gl_ClipPlane",
  "gl_ClipVertex",
  "gl_Color",
  "gl_DepthRange",
  "gl_DepthRangeParameters",
  "gl_EyePlaneQ",
  "gl_EyePlaneR",
  "gl_EyePlaneS",
  "gl_EyePlaneT",
  "gl_Fog",
  "gl_FogCoord",
  "gl_FogFragCoord",
  "gl_FogParameters",
  "gl_FragColor",
  "gl_FragCoord",
  "gl_FragData",
  "gl_FragDepth",
  "gl_FragDepthEXT",
  "gl_FrontColor",
  "gl_FrontFacing",
  "gl_FrontLightModelProduct",
  "gl_FrontLightProduct",
  "gl_FrontMaterial",
  "gl_FrontSecondaryColor",
  "gl_LightModel",
  "gl_LightModelParameters",
  "gl_LightModelProducts",
  "gl_LightProducts",
  "gl_LightSource",
  "gl_LightSourceParameters",
  "gl_MaterialParameters",
  "gl_MaxClipPlanes",
  "gl_MaxCombinedTextureImageUnits",
  "gl_MaxDrawBuffers",
  "gl_MaxFragmentUniformComponents",
  "gl_MaxLights",
  "gl_MaxTextureCoords",
  "gl_MaxTextureImageUnits",
  "gl_MaxTextureUnits",
  "gl_MaxVaryingFloats",
  "gl_MaxVertexAttribs",
  "gl_MaxVertexTextureImageUnits",
  "gl_MaxVertexUniformComponents",
  "gl_ModelViewMatrix",
  "gl_ModelViewMatrixInverse",
  "gl_ModelViewMatrixInverseTranspose",
  "gl_ModelViewMatrixTranspose",
  "gl_ModelViewProjectionMatrix",
  "gl_ModelViewProjectionMatrixInverse",
  "gl_ModelViewProjectionMatrixInverseTranspose",
  "gl_ModelViewProjectionMatrixTranspose",
  "gl_MultiTexCoord0",
  "gl_MultiTexCoord1",
  "gl_MultiTexCoord2",
  "gl_MultiTexCoord3",
  "gl_MultiTexCoord4",
  "gl_MultiTexCoord5",
  "gl_MultiTexCoord6",
  "gl_MultiTexCoord7",
  "gl_Normal",
  "gl_NormalMatrix",
  "gl_NormalScale",
  "gl_ObjectPlaneQ",
  "gl_ObjectPlaneR",
  "gl_ObjectPlaneS",
  "gl_ObjectPlaneT",
  "gl_Point",
  "gl_PointCoord",
  "gl_PointParameters",
  "gl_PointSize",
  "gl_Position",
  "gl_ProjectionMatrix",
  "gl_ProjectionMatrixInverse",
  "gl_ProjectionMatrixInverseTranspose",
  "gl_ProjectionMatrixTranspose",
  "gl_SecondaryColor",
  "gl_TexCoord",
  "gl_TextureEnvColor",
  "gl_TextureMatrix",
  "gl_TextureMatrixInverse",
  "gl_TextureMatrixInverseTranspose",
  "gl_TextureMatrixTranspose",
  "gl_Vertex",
  "greaterThan",
  "greaterThanEqual",
  "inversesqrt",
  "length",
  "lessThan",
  "lessThanEqual",
  "log",
  "log2",
  "matrixCompMult",
  "max",
  "min",
  "mix",
  "mod",
  "normalize",
  "not",
  "notEqual",
  "pow",
  "radians",
  "reflect",
  "refract",
  "sign",
  "sin",
  "smoothstep",
  "sqrt",
  "step",
  "tan",
  "texture2D",
  "texture2DLod",
  "texture2DProj",
  "texture2DProjLod",
  "textureCube",
  "textureCubeLod",
  "texture2DLodEXT",
  "texture2DProjLodEXT",
  "textureCubeLodEXT",
  "texture2DGradEXT",
  "texture2DProjGradEXT",
  "textureCubeGradEXT"
], Zf = rl, qf = Zf.slice().concat([
  "layout",
  "centroid",
  "smooth",
  "case",
  "mat2x2",
  "mat2x3",
  "mat2x4",
  "mat3x2",
  "mat3x3",
  "mat3x4",
  "mat4x2",
  "mat4x3",
  "mat4x4",
  "uvec2",
  "uvec3",
  "uvec4",
  "samplerCubeShadow",
  "sampler2DArray",
  "sampler2DArrayShadow",
  "isampler2D",
  "isampler3D",
  "isamplerCube",
  "isampler2DArray",
  "usampler2D",
  "usampler3D",
  "usamplerCube",
  "usampler2DArray",
  "coherent",
  "restrict",
  "readonly",
  "writeonly",
  "resource",
  "atomic_uint",
  "noperspective",
  "patch",
  "sample",
  "subroutine",
  "common",
  "partition",
  "active",
  "filter",
  "image1D",
  "image2D",
  "image3D",
  "imageCube",
  "iimage1D",
  "iimage2D",
  "iimage3D",
  "iimageCube",
  "uimage1D",
  "uimage2D",
  "uimage3D",
  "uimageCube",
  "image1DArray",
  "image2DArray",
  "iimage1DArray",
  "iimage2DArray",
  "uimage1DArray",
  "uimage2DArray",
  "image1DShadow",
  "image2DShadow",
  "image1DArrayShadow",
  "image2DArrayShadow",
  "imageBuffer",
  "iimageBuffer",
  "uimageBuffer",
  "sampler1DArray",
  "sampler1DArrayShadow",
  "isampler1D",
  "isampler1DArray",
  "usampler1D",
  "usampler1DArray",
  "isampler2DRect",
  "usampler2DRect",
  "samplerBuffer",
  "isamplerBuffer",
  "usamplerBuffer",
  "sampler2DMS",
  "isampler2DMS",
  "usampler2DMS",
  "sampler2DMSArray",
  "isampler2DMSArray",
  "usampler2DMSArray"
]), pr = ol;
pr = pr.slice().filter(function(o) {
  return !/^(gl\_|texture)/.test(o);
});
var Kf = pr.concat([
  // the updated gl_ constants
  "gl_VertexID",
  "gl_InstanceID",
  "gl_Position",
  "gl_PointSize",
  "gl_FragCoord",
  "gl_FrontFacing",
  "gl_FragDepth",
  "gl_PointCoord",
  "gl_MaxVertexAttribs",
  "gl_MaxVertexUniformVectors",
  "gl_MaxVertexOutputVectors",
  "gl_MaxFragmentInputVectors",
  "gl_MaxVertexTextureImageUnits",
  "gl_MaxCombinedTextureImageUnits",
  "gl_MaxTextureImageUnits",
  "gl_MaxFragmentUniformVectors",
  "gl_MaxDrawBuffers",
  "gl_MinProgramTexelOffset",
  "gl_MaxProgramTexelOffset",
  "gl_DepthRangeParameters",
  "gl_DepthRange",
  "trunc",
  "round",
  "roundEven",
  "isnan",
  "isinf",
  "floatBitsToInt",
  "floatBitsToUint",
  "intBitsToFloat",
  "uintBitsToFloat",
  "packSnorm2x16",
  "unpackSnorm2x16",
  "packUnorm2x16",
  "unpackUnorm2x16",
  "packHalf2x16",
  "unpackHalf2x16",
  "outerProduct",
  "transpose",
  "determinant",
  "inverse",
  "texture",
  "textureSize",
  "textureProj",
  "textureLod",
  "textureOffset",
  "texelFetch",
  "texelFetchOffset",
  "textureProjOffset",
  "textureLodOffset",
  "textureProjLod",
  "textureProjLodOffset",
  "textureGrad",
  "textureGradOffset",
  "textureProjGrad",
  "textureProjGradOffset"
]), Qf = ld, Jf = rl, Oo = $f, ed = ol, td = qf, nd = Kf, It = 999, Lo = 9999, Xi = 0, $i = 1, Fo = 2, ko = 3, Bo = 4, gs = 5, sd = 6, id = 7, rd = 8, Uo = 9, od = 10, No = 11, ad = [
  "block-comment",
  "line-comment",
  "preprocessor",
  "operator",
  "integer",
  "float",
  "ident",
  "builtin",
  "keyword",
  "whitespace",
  "eof",
  "integer"
];
function ld(o) {
  var e = 0, t = 0, n = It, s, i, r = [], a = [], l = 1, c = 0, u = 0, h = !1, f = !1, p = "", y;
  o = o || {};
  var g = ed, v = Jf;
  o.version === "300 es" && (g = nd, v = td);
  for (var d = {}, w = {}, e = 0; e < g.length; e++)
    d[g[e]] = !0;
  for (var e = 0; e < v.length; e++)
    w[v[e]] = !0;
  return function(q) {
    return a = [], q !== null ? T(q) : P();
  };
  function x(q) {
    q.length && a.push({
      type: ad[n],
      data: q,
      position: u,
      line: l,
      column: c
    });
  }
  function T(q) {
    e = 0, q.toString && (q = q.toString()), p += q.replace(/\r\n/g, `
`), y = p.length;
    for (var $; s = p[e], e < y; ) {
      switch ($ = e, n) {
        case Xi:
          e = _();
          break;
        case $i:
          e = b();
          break;
        case Fo:
          e = m();
          break;
        case ko:
          e = I();
          break;
        case Bo:
          e = k();
          break;
        case No:
          e = z();
          break;
        case gs:
          e = G();
          break;
        case Lo:
          e = U();
          break;
        case Uo:
          e = M();
          break;
        case It:
          e = S();
          break;
      }
      if ($ !== e)
        switch (p[$]) {
          case `
`:
            c = 0, ++l;
            break;
          default:
            ++c;
            break;
        }
    }
    return t += e, p = p.slice(e), a;
  }
  function P(q) {
    return r.length && x(r.join("")), n = od, x("(eof)"), a;
  }
  function S() {
    return r = r.length ? [] : r, i === "/" && s === "*" ? (u = t + e - 1, n = Xi, i = s, e + 1) : i === "/" && s === "/" ? (u = t + e - 1, n = $i, i = s, e + 1) : s === "#" ? (n = Fo, u = t + e, e) : /\s/.test(s) ? (n = Uo, u = t + e, e) : (h = /\d/.test(s), f = /[^\w_]/.test(s), u = t + e, n = h ? Bo : f ? ko : Lo, e);
  }
  function M() {
    return /[^\s]/g.test(s) ? (x(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function m() {
    return (s === "\r" || s === `
`) && i !== "\\" ? (x(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function b() {
    return m();
  }
  function _() {
    return s === "/" && i === "*" ? (r.push(s), x(r.join("")), n = It, e + 1) : (r.push(s), i = s, e + 1);
  }
  function I() {
    if (i === "." && /\d/.test(s))
      return n = gs, e;
    if (i === "/" && s === "*")
      return n = Xi, e;
    if (i === "/" && s === "/")
      return n = $i, e;
    if (s === "." && r.length) {
      for (; R(r); )
        ;
      return n = gs, e;
    }
    if (s === ";" || s === ")" || s === "(") {
      if (r.length)
        for (; R(r); )
          ;
      return x(s), n = It, e + 1;
    }
    var q = r.length === 2 && s !== "=";
    if (/[\w_\d\s]/.test(s) || q) {
      for (; R(r); )
        ;
      return n = It, e;
    }
    return r.push(s), i = s, e + 1;
  }
  function R(q) {
    var $ = 0, te, ee;
    do {
      if (te = Oo.indexOf(q.slice(0, q.length + $).join("")), ee = Oo[te], te === -1) {
        if ($-- + q.length > 0)
          continue;
        ee = q.slice(0, 1).join("");
      }
      return x(ee), u += ee.length, r = r.slice(ee.length), r.length;
    } while (!0);
  }
  function z() {
    return /[^a-fA-F0-9]/.test(s) ? (x(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function k() {
    return s === "." || /[eE]/.test(s) ? (r.push(s), n = gs, i = s, e + 1) : s === "x" && r.length === 1 && r[0] === "0" ? (n = No, r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (x(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function G() {
    return s === "f" && (r.push(s), i = s, e += 1), /[eE]/.test(s) || (s === "-" || s === "+") && /[eE]/.test(i) ? (r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (x(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function U() {
    if (/[^\d\w_]/.test(s)) {
      var q = r.join("");
      return w[q] ? n = rd : d[q] ? n = id : n = sd, x(r.join("")), n = It, e;
    }
    return r.push(s), i = s, e + 1;
  }
}
var cd = Qf, ud = hd;
function hd(o, e) {
  var t = cd(e), n = [];
  return n = n.concat(t(o)), n = n.concat(t(null)), n;
}
const fd = /* @__PURE__ */ Is(ud);
var dd = pd;
function pd(o) {
  for (var e = [], t = 0; t < o.length; t++)
    o[t].type !== "eof" && e.push(o[t].data);
  return e.join("");
}
const zo = /* @__PURE__ */ Is(dd);
var md = gd;
function gd(o) {
  var e = null, t = null, n = 0, s = 0, i = 0, r = 0, a = 0, l = [], c, u, h;
  for (c = 0, u; c < o.length; c++)
    if (h = o[c], h.data === "{") {
      if (n && n++ || (u = p(c, un(")"), un()), u < 0) || (r = u, u = p(u, un("("), un(")")), u < 0) || (a = u, u = p(u, vs), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = p(u, vs), u < 0))
        continue;
      n = 1, s = c, e = o[u].data, i = u;
      var f = p(u, vs);
      switch (o[f] && o[f].data) {
        case "lowp":
        case "highp":
        case "mediump":
          i = f;
      }
    } else if (n && h.data === "}") {
      if (--n)
        continue;
      l.push({
        name: t,
        type: e,
        body: [s + 1, c],
        args: [a, r + 1],
        outer: [i, c + 1]
      });
    }
  for (c = 0; c < o.length; c++)
    if (h = o[c], h.data === ";") {
      if (u = p(c, un(")"), un()), u < 0 || (r = u, u = p(u, un("("), un(")")), u < 0) || (a = u, u = p(u, vs), u < 0) || o[u].type !== "ident" || (t = o[u].data, u = p(u, vs), u < 0) || o[u].type === "operator" || o[u].data === "return")
        continue;
      e = o[u].data, l.push({
        name: t,
        type: e,
        body: !1,
        args: [a, r + 1],
        outer: [u, c + 1]
      });
    }
  return l.sort(function(y, g) {
    return y.outer[0] - g.outer[0];
  });
  function p(y, g, v) {
    for (var d = y - 1; d >= 0; d--) {
      if (g(o[d]))
        return d;
      if (v && v(o[d]))
        return -1;
    }
    return -1;
  }
}
function un(o) {
  return function(e) {
    return e.type === "operator" && (!o || e.data === o);
  };
}
function vs(o) {
  return o.type !== "whitespace";
}
const vd = /* @__PURE__ */ Is(md);
function yd(o, e) {
  if (typeof o != "object" || o === null)
    return o;
  var t = o[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(o, e || "default");
    if (typeof n != "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(o);
}
function al(o) {
  var e = yd(o, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ne(o, e, t) {
  return e = al(e), e in o ? Object.defineProperty(o, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[e] = t, o;
}
function Ho(o, e) {
  var t = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(o);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(o, s).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Xn(o) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ho(Object(t), !0).forEach(function(n) {
      Ne(o, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Ho(Object(t)).forEach(function(n) {
      Object.defineProperty(o, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return o;
}
function _d(o, e) {
  if (o == null)
    return {};
  var t = {}, n = Object.keys(o), s, i;
  for (i = 0; i < n.length; i++)
    s = n[i], !(e.indexOf(s) >= 0) && (t[s] = o[s]);
  return t;
}
function xd(o, e) {
  if (o == null)
    return {};
  var t = _d(o, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(o);
    for (s = 0; s < i.length; s++)
      n = i[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(o, n) && (t[n] = o[n]);
  }
  return t;
}
function wd(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Td(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, al(n.key), n);
  }
}
function bd(o, e, t) {
  return e && Td(o.prototype, e), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function ll(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function mr(o, e) {
  return mr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {
    return n.__proto__ = s, n;
  }, mr(o, e);
}
function Ed(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && mr(o, e);
}
function ui(o) {
  return ui = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, ui(o);
}
function Sd() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Md(o, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return ll(o);
}
function Ad(o) {
  var e = Sd();
  return function() {
    var n = ui(o), s;
    if (e) {
      var i = ui(this).constructor;
      s = Reflect.construct(n, arguments, i);
    } else
      s = n.apply(this, arguments);
    return Md(this, s);
  };
}
var be = {
  position: "csm_Position",
  positionRaw: "csm_PositionRaw",
  pointSize: "csm_PointSize",
  fragColor: "csm_FragColor",
  // PBR
  diffuseColor: "csm_DiffuseColor",
  // Color + alpha
  normal: "csm_Normal",
  // Normal
  roughness: "csm_Roughness",
  // Roughness
  metalness: "csm_Metalness",
  // Metalness
  emissive: "csm_Emissive",
  // Emissive
  ao: "csm_AO",
  // AO
  bump: "csm_Bump",
  // Bump
  depthAlpha: "csm_DepthAlpha"
  // Depth
}, ft, $n, Pd = (ft = {}, Ne(ft, "".concat(be.normal), {
  "#include <beginnormal_vertex>": `
    vec3 objectNormal = `.concat(be.normal, `;
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `)
}), Ne(ft, "".concat(be.position), {
  "#include <begin_vertex>": `
    vec3 transformed = `.concat(be.position, `;
  `)
}), Ne(ft, "".concat(be.positionRaw), {
  "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = `.concat(be.positionRaw, `;
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `)
}), Ne(ft, "".concat(be.pointSize), {
  "gl_PointSize = size;": `
    gl_PointSize = `.concat(be.pointSize, `;
    `)
}), Ne(ft, "".concat(be.diffuseColor), {
  "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = `.concat(be.diffuseColor, `;
  `)
}), Ne(ft, "".concat(be.fragColor), {
  "#include <dithering_fragment>": `
    #include <dithering_fragment>
    gl_FragColor  = `.concat(be.fragColor, `;
  `)
}), Ne(ft, "".concat(be.emissive), {
  "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = `.concat(be.emissive, `;
    `)
}), Ne(ft, "".concat(be.roughness), {
  "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = `.concat(be.roughness, `;
    `)
}), Ne(ft, "".concat(be.metalness), {
  "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = `.concat(be.metalness, `;
    `)
}), Ne(ft, "".concat(be.ao), {
  "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - `.concat(be.ao, `;
    `)
}), Ne(ft, "".concat(be.bump), {
  "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = `.concat(be.bump, " - (dot(").concat(be.bump, `, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `)
}), Ne(ft, "".concat(be.depthAlpha), {
  "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(be.depthAlpha, ` );
    `),
  "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      gl_FragColor = packDepthToRGBA( fragCoordZ );
      gl_FragColor.a *= `.concat(be.depthAlpha, `;
    `)
}), ft), Cd = ($n = {}, Ne($n, "".concat(be.position), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(be.position, `, 1.0 );
  `)
}), Ne($n, "".concat(be.positionRaw), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = `.concat(be.position, `;
  `)
}), Ne($n, "".concat(be.diffuseColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(be.diffuseColor, `;
  `)
}), Ne($n, "".concat(be.fragColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(be.fragColor, `;
  `)
}), $n), Id = (
  /* glsl */
  `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        vec3 csm_Position = vec3(0.0);
        vec4 csm_PositionRaw = vec4(0.0);
        vec3 csm_Normal = vec3(0.0);
    #else
        vec3 csm_Position = position;
        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        vec3 csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize = size;
    #endif
#else
    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive = emissive;
        float csm_Roughness = roughness;
        float csm_Metalness = metalness;
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump = vec3(0.0);
    #endif

    float csm_DepthAlpha = 1.0;
#endif
`
), Rd = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), Dd = (
  /* glsl */
  `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`
), Od = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), Ld = (
  /* glsl */
  `
    
`
), dt, Fd = (dt = {}, Ne(dt, "".concat(be.position), "*"), Ne(dt, "".concat(be.positionRaw), "*"), Ne(dt, "".concat(be.normal), "*"), Ne(dt, "".concat(be.pointSize), ["PointsMaterial"]), Ne(dt, "".concat(be.diffuseColor), "*"), Ne(dt, "".concat(be.fragColor), "*"), Ne(dt, "".concat(be.emissive), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ne(dt, "".concat(be.roughness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ne(dt, "".concat(be.metalness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ne(dt, "".concat(be.ao), ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"]), Ne(dt, "".concat(be.bump), ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"]), Ne(dt, "".concat(be.depthAlpha), "*"), dt), kd = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "patchMap", "cacheKey", "silent"], Bd = function(e, t, n) {
  return e.split(t).join(n);
}, Ud = function(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}, Nd = function(e, t) {
  return new RegExp("\\b".concat(Ud(t), "\\b")).test(e);
};
function zd(o) {
  try {
    new o();
  } catch (e) {
    if (e.message.indexOf("is not a constructor") >= 0)
      return !1;
  }
  return !0;
}
function Hd(o, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  Object.assign(o, e);
  var n = Object.getPrototypeOf(e);
  Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(s) {
    var i = typeof s[1].get == "function", r = typeof s[1].set == "function", a = typeof s[1].value == "function", l = s[0] === "constructor";
    return (i || r || a) && !l;
  }).forEach(function(s) {
    if (typeof o[s[0]] == "function") {
      t || console.warn("Function ".concat(s[0], " already exists on CSM, renaming to base_").concat(s[0]));
      var i = "base_".concat(s[0]);
      o[i] = s[1].value.bind(o);
      return;
    }
    Object.defineProperty(o, s[0], s[1]);
  });
}
function jd(o) {
  var e = o.toString().trim(), t = e.substring(e.indexOf("{") + 1, e.lastIndexOf("}"));
  return t.trim().length === 0;
}
function jo(o) {
  return o.replace(/\s/g, "");
}
function Gd(o, e, t) {
  var n = o.lastIndexOf(e);
  return n === -1 ? o : o.substring(0, n) + t + o.substring(n + e.length);
}
var Vd = /* @__PURE__ */ function(o) {
  Ed(t, o);
  var e = Ad(t);
  function t(n) {
    var s, i = n.baseMaterial, r = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, u = n.cacheKey, h = n.silent, f = xd(n, kd);
    wd(this, t);
    var p;
    if (zd(i) ? p = new i(f) : (p = i, Object.assign(p, f)), p.type === "RawShaderMaterial")
      throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
    s = e.call(this), Hd(ll(s), p, h), s.__csm = {
      patchMap: c || {},
      fragmentShader: r || "",
      vertexShader: a || "",
      cacheKey: u,
      baseMaterial: i,
      instanceID: Hr.MathUtils.generateUUID(),
      type: p.type,
      isAlreadyExtended: !jd(p.onBeforeCompile),
      cacheHash: "",
      silent: h
    }, s.uniforms = Xn(Xn({}, s.uniforms || {}), l || {});
    {
      var y = s.__csm, g = y.fragmentShader, v = y.vertexShader, d = s.uniforms;
      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(g, v, d);
    }
    return s;
  }
  return bd(t, [{
    key: "update",
    value: function() {
      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.uniforms = s.uniforms || this.uniforms, Object.assign(this.__csm, s);
      var i = this.__csm, r = i.fragmentShader, a = i.vertexShader, l = this.uniforms, c = this.getCacheHash();
      this.__csm.cacheHash = c, this.generateMaterial(r, a, l);
    }
    /**
     * Returns a new instance of this material with the same options.
     *
     * @returns A clone of this material.
     */
  }, {
    key: "clone",
    value: function() {
      var s = {
        baseMaterial: this.__csm.baseMaterial,
        fragmentShader: this.__csm.fragmentShader,
        vertexShader: this.__csm.vertexShader,
        uniforms: this.uniforms,
        silent: this.__csm.silent,
        patchMap: this.__csm.patchMap,
        cacheKey: this.__csm.cacheKey
      }, i = new this.constructor(s);
      return Object.assign(this, i), i;
    }
    /**
     * Internally calculates the cache key for this instance of CSM.
     * If no specific CSM inputs are provided, the cache key is the same as the default
     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.
     *
     * This method is quite expensive owing to the hashing function and string manip.
     *
     * TODO:
     * - Optimize string manip.
     * - Find faster hash function
     *
     * @returns {string} A cache key for this instance of CSM.
     */
  }, {
    key: "getCacheHash",
    value: function() {
      var s = this.__csm, i = s.fragmentShader, r = s.vertexShader, a = this.uniforms, l = Object.values(a).reduce(function(u, h) {
        var f = h.value;
        return u + JSON.stringify(f);
      }, ""), c = jo(i) + jo(r) + l;
      return c.trim().length > 0 ? Xf(c) : this.customProgramCacheKey();
    }
    /**
     * Does the internal shader generation. Not meant to be called directly.
     *
     * @param fragmentShader
     * @param vertexShader
     * @param uniforms
     */
  }, {
    key: "generateMaterial",
    value: function(s, i, r) {
      var a = this, l = this.parseShader(s), c = this.parseShader(i);
      this.uniforms = r || {}, this.customProgramCacheKey = function() {
        return a.__csm.cacheHash;
      };
      var u = function(p) {
        try {
          if (l) {
            var y = a.patchShader(l, p.fragmentShader, !0);
            p.fragmentShader = a.getMaterialDefine() + y;
          }
          if (c) {
            var g = a.patchShader(c, p.vertexShader);
            p.vertexShader = `#define IS_VERTEX;
` + g, p.vertexShader = a.getMaterialDefine() + p.vertexShader;
          }
          p.uniforms = Xn(Xn({}, p.uniforms), a.uniforms), a.uniforms = p.uniforms;
        } catch (v) {
          console.error(v);
        }
      };
      if (this.__csm.isAlreadyExtended) {
        var h = this.onBeforeCompile;
        this.onBeforeCompile = function(f, p) {
          h(f, p), u(f);
        };
      } else
        this.onBeforeCompile = u;
      this.needsUpdate = !0;
    }
    /**
     * Patches input shader with custom shader. Not meant to be called directly.
     * @param customShader
     * @param shader
     * @param isFrag
     * @returns
     */
  }, {
    key: "patchShader",
    value: function(s, i, r) {
      var a = this, l = i, c = Xn(Xn({}, this.getPatchMapForMaterial()), this.__csm.patchMap);
      Object.keys(c).forEach(function(f) {
        Object.keys(c[f]).forEach(function(p) {
          var y = Fd[f], g = a.__csm.type;
          if (f === "*" || Nd(s.main, f))
            if (!y || Array.isArray(y) && y.includes(g) || y === "*")
              l = Bd(l, p, c[f][p]);
            else
              throw new Error("CSM: ".concat(f, " is not available in ").concat(g, ". Shader cannot compile."));
        });
      }), l = l.replace("void main() {", `
        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
          `.concat(r ? Od : Rd, `
          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
        #endif

        `).concat(s.header, `
        
        void main() {
          #ifndef CSM_IS_DEFAULTS_DEFINED
            `).concat(Id, `
            #define CSM_IS_DEFAULTS_DEFINED 1
          #endif
          
          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
            `).concat(r ? Ld : Dd, `
            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
          #endif

          // CSM_START
      `));
      var u = this.__csm.isAlreadyExtended, h = l.includes("// CSM_END");
      return u && h ? l = Gd(l, "// CSM_END", `
          // CSM_END
          `.concat(s.main, `
          // CSM_END
        `)) : l = l.replace("// CSM_START", `
        // CSM_START
        `.concat(s.main, `
        // CSM_END
          `)), l = s.defines + l, l;
    }
    /**
     * This method is expensive owing to the tokenization and parsing of the shader.
     *
     * TODO:
     * - Replace tokenization with regex
     *
     * @param shader
     * @returns
     */
  }, {
    key: "parseShader",
    value: function(s) {
      if (s) {
        var i = s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, ""), r = fd(i), a = vd(r), l = a.map(function(h) {
          return h.name;
        }).indexOf("main"), c = zo(r.slice(0, l >= 0 ? a[l].outer[0] : void 0)), u = l >= 0 ? this.getShaderFromIndex(r, a[l].body) : "";
        return {
          defines: "",
          header: c,
          main: u
        };
      }
    }
    /**
     * Gets the material type as a string. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getMaterialDefine",
    value: function() {
      var s = this.__csm.type;
      return s ? "#define IS_".concat(s.toUpperCase(), `;
`) : `#define IS_UNKNOWN;
`;
    }
    /**
     * Gets the right patch map for the material. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getPatchMapForMaterial",
    value: function() {
      switch (this.__csm.type) {
        case "ShaderMaterial":
          return Cd;
        default:
          return Pd;
      }
    }
    /**
     * Gets the shader from the tokens. Not meant to be called directly.
     * @param tokens
     * @param index
     * @returns
     */
  }, {
    key: "getShaderFromIndex",
    value: function(s, i) {
      return zo(s.slice(i[0], i[1]));
    }
  }]), t;
}(Hr.Material);
const Yd = ["args"], Cg = /* @__PURE__ */ me({
  __name: "index",
  props: {
    baseMaterial: { type: Function },
    vertexShader: {},
    fragmentShader: {},
    silent: { type: Boolean },
    uniforms: {}
  },
  setup(o, { expose: e }) {
    const t = o, n = pe(null), { extend: s } = ke();
    return s({ CustomShaderMaterial: Vd }), e({ value: n }), (i, r) => (ce(), ue("TresCustomShaderMaterial", {
      ref_key: "customShaderMaterialClass",
      ref: n,
      args: [t]
    }, null, 8, Yd));
  }
}), Wd = () => Number.parseInt(vr.replace(/\D+/g, "")), Xd = /* @__PURE__ */ Wd();
class $d extends Dt {
  constructor(t = new ge()) {
    super({
      uniforms: {
        inputBuffer: new Ee(null),
        depthBuffer: new Ee(null),
        resolution: new Ee(new ge()),
        texelSize: new Ee(new ge()),
        halfTexelSize: new Ee(new ge()),
        kernel: new Ee(0),
        scale: new Ee(1),
        cameraNear: new Ee(0),
        cameraFar: new Ee(1),
        minDepthThreshold: new Ee(0),
        maxDepthThreshold: new Ee(1),
        depthScale: new Ee(0),
        depthToBlurRatioBias: new Ee(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${Xd >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: Vl,
      depthWrite: !1,
      depthTest: !1
    });
    ae(this, "kernel");
    this.toneMapped = !1, this.setTexelSize(t.x, t.y), this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(t, n) {
    this.uniforms.texelSize.value.set(t, n), this.uniforms.halfTexelSize.value.set(t, n).multiplyScalar(0.5);
  }
  setResolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
}
class Zd {
  constructor({
    resolution: e,
    width: t = 500,
    height: n = 500,
    minDepthThreshold: s = 0,
    maxDepthThreshold: i = 1,
    depthScale: r = 0,
    depthToBlurRatioBias: a = 0.25
  }) {
    ae(this, "renderTargetA");
    ae(this, "renderTargetB");
    ae(this, "convolutionMaterial");
    ae(this, "scene");
    ae(this, "camera");
    ae(this, "screen");
    ae(this, "renderToScreen", !1);
    this.renderTargetA = new Tn(e, e, {
      minFilter: Ot,
      magFilter: Ot,
      stencilBuffer: !1,
      depthBuffer: !1,
      type: Qt
    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new $d(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new ge(t, n)), this.scene = new ws(), this.camera = new Yl(), this.convolutionMaterial.uniforms.minDepthThreshold.value = s, this.convolutionMaterial.uniforms.maxDepthThreshold.value = i, this.convolutionMaterial.uniforms.depthScale.value = r, this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = r > 0;
    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), u = new at();
    u.setAttribute("position", new mt(l, 3)), u.setAttribute("uv", new mt(c, 2)), this.screen = new le(u, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);
  }
  render(e, t, n) {
    const s = this.scene, i = this.camera, r = this.renderTargetA, a = this.renderTargetB, l = this.convolutionMaterial, c = l.uniforms;
    c.depthBuffer.value = t.depthTexture;
    const u = l.kernel;
    let h = t, f, p, y;
    for (p = 0, y = u.length - 1; p < y; ++p)
      f = p & 1 ? a : r, c.kernel.value = u[p], c.inputBuffer.value = h.texture, e.setRenderTarget(f), e.render(s, i), h = f;
    c.kernel.value = u[p], c.inputBuffer.value = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);
  }
}
class qd extends Ss {
  constructor(t = {}) {
    super(t);
    ae(this, "_tDepth", { value: null });
    ae(this, "_distortionMap", { value: null });
    ae(this, "_tDiffuse", { value: null });
    ae(this, "_tDiffuseBlur", { value: null });
    ae(this, "_textureMatrix", { value: null });
    ae(this, "_hasBlur", { value: !1 });
    ae(this, "_mirror", { value: 0 });
    ae(this, "_mixBlur", { value: 0 });
    ae(this, "_blurStrength", { value: 0.5 });
    ae(this, "_minDepthThreshold", { value: 0.9 });
    ae(this, "_maxDepthThreshold", { value: 1 });
    ae(this, "_depthScale", { value: 0 });
    ae(this, "_depthToBlurRatioBias", { value: 0.25 });
    ae(this, "_distortion", { value: 1 });
    ae(this, "_mixContrast", { value: 1 });
    this.setValues(t);
  }
  onBeforeCompile(t) {
    var n;
    (n = t.defines) != null && n.USE_UV || (t.defines.USE_UV = ""), t.uniforms.hasBlur = this._hasBlur, t.uniforms.tDiffuse = this._tDiffuse, t.uniforms.tDepth = this._tDepth, t.uniforms.distortionMap = this._distortionMap, t.uniforms.tDiffuseBlur = this._tDiffuseBlur, t.uniforms.textureMatrix = this._textureMatrix, t.uniforms.mirror = this._mirror, t.uniforms.mixBlur = this._mixBlur, t.uniforms.mixStrength = this._blurStrength, t.uniforms.minDepthThreshold = this._minDepthThreshold, t.uniforms.maxDepthThreshold = this._maxDepthThreshold, t.uniforms.depthScale = this._depthScale, t.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias, t.uniforms.distortion = this._distortion, t.uniforms.mixContrast = this._mixContrast, t.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${t.vertexShader}`, t.vertexShader = t.vertexShader.replace(
      "#include <project_vertex>",
      `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`
    ), t.fragmentShader = `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${t.fragmentShader}`, t.fragmentShader = t.fragmentShader.replace(
      "#include <emissivemap_fragment>",
      `#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `
    );
  }
  get tDiffuse() {
    return this._tDiffuse.value;
  }
  set tDiffuse(t) {
    this._tDiffuse.value = t;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(t) {
    this._tDepth.value = t;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(t) {
    this._distortionMap.value = t;
  }
  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }
  set tDiffuseBlur(t) {
    this._tDiffuseBlur.value = t;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(t) {
    this._textureMatrix.value = t;
  }
  get hasBlur() {
    return this._hasBlur.value;
  }
  set hasBlur(t) {
    this._hasBlur.value = t;
  }
  get mirror() {
    return this._mirror.value;
  }
  set mirror(t) {
    this._mirror.value = t;
  }
  get mixBlur() {
    return this._mixBlur.value;
  }
  set mixBlur(t) {
    this._mixBlur.value = t;
  }
  get mixStrength() {
    return this._blurStrength.value;
  }
  set mixStrength(t) {
    this._blurStrength.value = t;
  }
  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }
  set minDepthThreshold(t) {
    this._minDepthThreshold.value = t;
  }
  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }
  set maxDepthThreshold(t) {
    this._maxDepthThreshold.value = t;
  }
  get depthScale() {
    return this._depthScale.value;
  }
  set depthScale(t) {
    this._depthScale.value = t;
  }
  get depthToBlurRatioBias() {
    return this._depthToBlurRatioBias.value;
  }
  set depthToBlurRatioBias(t) {
    this._depthToBlurRatioBias.value = t;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(t) {
    this._distortion.value = t;
  }
  get mixContrast() {
    return this._mixContrast.value;
  }
  set mixContrast(t) {
    this._mixContrast.value = t;
  }
}
const Kd = ["texture-matrix", "mirror", "t-diffuse", "t-depth", "t-diffuse-blur", "has-blur", "mix-strength", "min-depth-threshold", "max-depth-threshold", "depth-scale", "depth-to-blur-ratio-bias", "distortion", "distortion-map", "mix-contrast", "defines-USE_BLUR", "defines-USE_DEPTH", "defines-USE_DISTORTION"], Ig = /* @__PURE__ */ me({
  __name: "index",
  props: {
    resolution: { default: 256 },
    mixBlur: { default: 0 },
    mixStrength: { default: 1 },
    blur: { default: () => [0, 0] },
    mirror: { default: 0 },
    minDepthThreshold: { default: 0.9 },
    maxDepthThreshold: { default: 1 },
    depthScale: { default: 0 },
    depthToBlurRatioBias: { default: 0.25 },
    distortionMap: {},
    distortion: { default: 1 },
    mixContrast: { default: 1 },
    reflectorOffset: { default: 0 }
  },
  setup(o) {
    const e = o;
    function t(G, U) {
      let q;
      return G.traverse(($) => {
        $.isMesh && $.material && $.material.uuid === U && (q = $);
      }), q;
    }
    const n = {
      reflectorPlane: new hi(),
      normal: new Z(),
      reflectorWorldPosition: new Z(),
      cameraWorldPosition: new Z(),
      rotationMatrix: new Pe(),
      lookAtPosition: new Z(0, 0, -1),
      clipPlane: new lt(),
      view: new Z(),
      target: new Z(),
      q: new lt(),
      virtualCamera: new St(),
      textureMatrix: new Pe()
    }, {
      resolution: s,
      minDepthThreshold: i,
      maxDepthThreshold: r,
      depthScale: a,
      depthToBlurRatioBias: l,
      blur: c,
      mirror: u,
      mixBlur: h,
      mixStrength: f,
      distortion: p,
      distortionMap: y,
      mixContrast: g
    } = Oe(e), { camera: v, scene: d, renderer: w, extend: x } = ke();
    x({ MeshReflectorMaterial: qd });
    const T = pe(), P = pe(), S = pe(), M = pe(), m = Fe(() => typeof c.value == "number" ? [c.value, c.value] : c.value), b = Fe(() => m.value[0] > 0 || m.value[1] > 0);
    function _(G) {
      var q, $;
      if (n.reflectorWorldPosition.setFromMatrixPosition(G.matrixWorld), n.cameraWorldPosition.setFromMatrixPosition((q = v.value) == null ? void 0 : q.matrixWorld), n.rotationMatrix.extractRotation(G.matrixWorld), n.normal.set(0, 0, 1), n.normal.applyMatrix4(n.rotationMatrix), n.reflectorWorldPosition.addScaledVector(n.normal, e.reflectorOffset), n.view.subVectors(n.reflectorWorldPosition, n.cameraWorldPosition), n.view.dot(n.normal) > 0)
        return;
      n.view.reflect(n.normal).negate(), n.view.add(n.reflectorWorldPosition), n.rotationMatrix.extractRotation(($ = v.value) == null ? void 0 : $.matrixWorld), n.lookAtPosition.set(0, 0, -1), n.lookAtPosition.applyMatrix4(n.rotationMatrix), n.lookAtPosition.add(n.cameraWorldPosition), n.target.subVectors(n.reflectorWorldPosition, n.lookAtPosition), n.target.reflect(n.normal).negate(), n.target.add(n.reflectorWorldPosition), n.virtualCamera.position.copy(n.view), n.virtualCamera.up.set(0, 1, 0), n.virtualCamera.up.applyMatrix4(n.rotationMatrix), n.virtualCamera.up.reflect(n.normal), n.virtualCamera.lookAt(n.target), n.virtualCamera.far = (v == null ? void 0 : v.value).far, n.virtualCamera.updateMatrixWorld(), n.virtualCamera.projectionMatrix.copy((v == null ? void 0 : v.value).projectionMatrix), n.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.textureMatrix.multiply(n.virtualCamera.projectionMatrix), n.textureMatrix.multiply(n.virtualCamera.matrixWorldInverse), n.textureMatrix.multiply(G.matrixWorld), n.reflectorPlane.setFromNormalAndCoplanarPoint(n.normal, n.reflectorWorldPosition), n.reflectorPlane.applyMatrix4(n.virtualCamera.matrixWorldInverse), n.clipPlane.set(
        n.reflectorPlane.normal.x,
        n.reflectorPlane.normal.y,
        n.reflectorPlane.normal.z,
        n.reflectorPlane.constant
      );
      const U = n.virtualCamera.projectionMatrix;
      n.q.x = (Math.sign(n.clipPlane.x) + U.elements[8]) / U.elements[0], n.q.y = (Math.sign(n.clipPlane.y) + U.elements[9]) / U.elements[5], n.q.z = -1, n.q.w = (1 + U.elements[10]) / U.elements[14], n.clipPlane.multiplyScalar(2 / n.clipPlane.dot(n.q)), U.elements[2] = n.clipPlane.x, U.elements[6] = n.clipPlane.y, U.elements[10] = n.clipPlane.z + 1, U.elements[14] = n.clipPlane.w;
    }
    ut(() => {
      var U;
      (U = T.value) == null || U.texture.dispose();
      const G = {
        minFilter: Ot,
        magFilter: Ot,
        type: Qt
      };
      T.value = new Tn(
        s.value,
        s.value,
        {
          ...G,
          depthBuffer: !0,
          depthTexture: new xa(
            s.value,
            s.value,
            Wl,
            Xl
          )
        }
      ), P.value = new Tn(
        s.value,
        s.value,
        G
      ), S.value = new Zd({
        resolution: s.value,
        width: m.value[0],
        height: m.value[1],
        minDepthThreshold: i.value,
        maxDepthThreshold: r.value,
        depthScale: a.value,
        depthToBlurRatioBias: l.value
      }), M.value = {
        mirror: u,
        textureMatrix: n.textureMatrix,
        mixBlur: h,
        tDiffuse: T.value.texture,
        tDepth: T.value.depthTexture,
        tDiffuseBlur: T.value.texture,
        hasBlur: b,
        mixStrength: f,
        minDepthThreshold: i,
        maxDepthThreshold: r,
        depthScale: a,
        depthToBlurRatioBias: l,
        distortion: p,
        distortionMap: y.value,
        mixContrast: g,
        "defines-USE_BLUR": b.value ? "" : void 0,
        "defines-USE_DEPTH": a.value > 0 ? "" : void 0,
        "defines-USE_DISTORTION": y.value ? "" : void 0
      };
    });
    const I = pe(), { onLoop: R } = qe();
    R(() => {
      var $;
      if (!I.value || !w.value || !T.value || !v.value)
        return;
      const G = t(d.value, I.value.uuid);
      if (!G)
        return;
      G.visible = !1;
      const U = w.value.xr.enabled, q = w.value.shadowMap.autoUpdate;
      _(G), w.value.shadowMap.autoUpdate = !1, w.value.setRenderTarget(T.value), w.value.autoClear || w.value.clear(), w.value.render(d.value, n.virtualCamera), ($ = S == null ? void 0 : S.value) == null || $.render(w.value, T.value, P.value), w.value.xr.enabled = U, w.value.shadowMap.autoUpdate = q, G.visible = !0, w.value.setRenderTarget(null);
    });
    const z = Ma(), k = Fe(() => {
      const G = {};
      return Object.assign(G, e), Object.assign(G, z.value), G;
    });
    return Sr(() => {
      var G, U;
      (G = T == null ? void 0 : T.value) == null || G.dispose(), (U = P == null ? void 0 : P.value) == null || U.dispose();
    }), (G, U) => {
      var q, $, te;
      return ce(), ue("TresMeshReflectorMaterial", We({
        key: `key${M.value["defines-USE_BLUR"]}${M.value["defines-USE_DEPTH"]}${M.value["defines-USE_DISTORTION"]}`,
        ref_key: "materialRef",
        ref: I
      }, k.value, {
        "texture-matrix": n.textureMatrix,
        mirror: H(u),
        "t-diffuse": (q = T.value) == null ? void 0 : q.texture,
        "t-depth": ($ = T.value) == null ? void 0 : $.depthTexture,
        "t-diffuse-blur": (te = P.value) == null ? void 0 : te.texture,
        "has-blur": b.value,
        "mix-strength": H(f),
        "min-depth-threshold": H(i),
        "max-depth-threshold": H(r),
        "depth-scale": H(a),
        "depth-to-blur-ratio-bias": H(l),
        distortion: H(p),
        "distortion-map": H(y),
        "mix-contrast": H(g),
        "defines-USE_BLUR": b.value ? "" : void 0,
        "defines-USE_DEPTH": H(a) > 0 ? "" : void 0,
        "defines-USE_DISTORTION": H(y) ? "" : void 0
      }), null, 16, Kd);
    };
  }
});
class Go extends Dt {
  /**
   * Create a HolographicMaterial.
   *
   * @param {object} parameters - The parameters to configure the material.
   * @param {number} [parameters.time] - The time uniform representing animation time.
   * @param {number} [parameters.fresnelOpacity] - The opacity for the fresnel effect.
   * @param {number} [parameters.fresnelAmount] - The strength of the fresnel effect.
   * @param {number} [parameters.scanlineSize] - The size of the scanline effect.
   * @param {number} [parameters.hologramBrightness] - The brightness of the hologram.
   * @param {number} [parameters.signalSpeed] - The speed of the signal effect.
   * @param {Color} [parameters.hologramColor] - The color of the hologram.
   * @param {boolean} [parameters.enableBlinking] - Enable/disable blinking effect.
   * @param {boolean} [parameters.blinkFresnelOnly] - Enable blinking only on the fresnel effect.
   * @param {number} [parameters.hologramOpacity] - The opacity of the hologram.
   * @param {number} [parameters.blendMode] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
   * @param {number} [parameters.side] - The rendering side. Use `THREE.FrontSide`,
   *  `THREE.BackSide`, or `THREE.DoubleSide`.
   * @param {boolean} [parameters.depthTest] - Enable or disable depthTest.
   */
  constructor(e = {}) {
    super(), this.vertexShader = `
      #define STANDARD
      varying vec3 vViewPosition;
      #ifdef USE_TRANSMISSION
      varying vec3 vWorldPosition;
      #endif
    
      varying vec2 vUv;
      varying vec4 vPos;
      varying vec3 vNormalW;
      varying vec3 vPositionW;

      #include <common>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>

      void main() {
        
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
      
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
      
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
      
        #endif
      
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
      
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;

        vUv = uv;
        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
        
        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );

      }`, this.fragmentShader = ` 
      varying vec2 vUv;
      varying vec3 vPositionW;
      varying vec4 vPos;
      varying vec3 vNormalW;
      
      uniform float time;
      uniform float fresnelOpacity;
      uniform float scanlineSize;
      uniform float fresnelAmount;
      uniform float signalSpeed;
      uniform float hologramBrightness;
      uniform float hologramOpacity;
      uniform bool blinkFresnelOnly;
      uniform bool enableBlinking;
      uniform vec3 hologramColor;

      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }

      void main() {
        vec2 vCoords = vPos.xy;
        vCoords /= vPos.w;
        vCoords = vCoords * 0.5 + 0.5;
        vec2 myUV = fract( vCoords );

        // Defines hologram main color
        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));

        // Add scanlines
        float scanlines = 10.;
        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);

        // Scanlines offsets
        float r = random(vUv.x, vUv.y);
        float g = random(vUv.y * 20.2, vUv.y * .2);
        float b = random(vUv.y * .9, vUv.y * .2);

        // Scanline composition
        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);

        // Calculates fresnel
        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);

        // Blinkin effect
        //Suggested by Octano - https://x.com/OtanoDesign?s=20
        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
        float blink = flicker(blinkValue, time * signalSpeed * .02);

        // Final shader composition
        vec3 finalColor;

        if(blinkFresnelOnly){
          finalColor = scanlineMix.rgb + fresnelEffect * blink;
        }else{
          finalColor = scanlineMix.rgb * blink + fresnelEffect;
        }

        gl_FragColor = vec4( finalColor, hologramOpacity);

      }`, this.uniforms = {
      /**
       * The time uniform representing animation time.
       * @type {Uniform<number>}
       * @default 0.0
       */
      time: new Ee(0),
      /**
       * The opacity for the fresnel effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      fresnelOpacity: new Ee(e.fresnelOpacity !== void 0 ? e.fresnelOpacity : 1),
      /**
       * The strength of the fresnel effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      fresnelAmount: new Ee(e.fresnelAmount !== void 0 ? e.fresnelAmount : 0.45),
      /**
       * The size of the scanline effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      scanlineSize: new Ee(e.scanlineSize !== void 0 ? e.scanlineSize : 8),
      /**
       * The brightness of the hologram.
       * @type {Uniform<number>}
       * @default 1.0
       */
      hologramBrightness: new Ee(e.hologramBrightness !== void 0 ? e.hologramBrightness : 1),
      /**
       * The speed of the signal effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      signalSpeed: new Ee(e.signalSpeed !== void 0 ? e.signalSpeed : 1),
      /**
       * The color of the hologram.
       * @type {Uniform<Color>}
       * @default new Color(0xFFFFFF)
       */
      hologramColor: new Ee(e.hologramColor !== void 0 ? new Re(e.hologramColor) : new Re("#00d5ff")),
      /**
       * Enable/disable blinking effect.
       * @type {Uniform<boolean>}
       * @default true
       */
      enableBlinking: new Ee(e.enableBlinking !== void 0 ? e.enableBlinking : !0),
      /**
       * Enable blinking only on the fresnel effect.
       * @type {Uniform<boolean>}
       * @default false
       */
      blinkFresnelOnly: new Ee(e.blinkFresnelOnly !== void 0 ? e.blinkFresnelOnly : !0),
      /**
       * The opacity of the hologram.
       * @type {Uniform<number>}
       * @default 1.0
       */
      hologramOpacity: new Ee(e.hologramOpacity !== void 0 ? e.hologramOpacity : 1)
    }, this.clock = new $l(), this.setValues(e), this.depthTest = e.depthTest !== void 0 ? e.depthTest : !1, this.blending = e.blendMode !== void 0 ? e.blendMode : Tr, this.transparent = !0, this.side = e.side !== void 0 ? e.side : Ms;
  }
  update() {
    this.uniforms.time.value = this.clock.getElapsedTime();
  }
}
const Qd = ["uniforms-fresnel-amount-value", "uniforms-enable-blinking-value", "uniforms-fresnel-opacity-value", "uniforms-hologram-brightness-value", "uniforms-scanline-size-value", "uniforms-signal-speed-value", "uniforms-hologram-color-value", "uniforms-hologram-opacity-value", "uniforms-blink-fresnel-only-value", "enable-additive", "side"], Rg = /* @__PURE__ */ me({
  __name: "index",
  props: {
    fresnelAmount: { default: 0.45 },
    fresnelOpacity: { default: 1 },
    blinkFresnelOnly: { type: Boolean, default: !0 },
    enableBlinking: { type: Boolean, default: !0 },
    enableAdditive: { type: Boolean, default: !0 },
    hologramBrightness: { default: 0.7 },
    scanlineSize: { default: 8 },
    signalSpeed: { default: 0.45 },
    hologramOpacity: { default: 1 },
    hologramColor: { default: "#00d5ff" },
    side: { default: Ms }
  },
  setup(o, { expose: e }) {
    const t = o, n = pe(), { extend: s } = ke();
    s({ HolographicMaterial: Go }), e({ root: n, constructor: Go });
    const { onLoop: i } = qe();
    return i(() => {
      var r;
      (r = n.value) == null || r.update();
    }), (r, a) => (ce(), ue("TresHolographicMaterial", {
      ref_key: "MeshHolographicMaterialClass",
      ref: n,
      "uniforms-fresnel-amount-value": t.fresnelAmount,
      "uniforms-enable-blinking-value": t.enableBlinking,
      "uniforms-fresnel-opacity-value": t.fresnelOpacity,
      "uniforms-hologram-brightness-value": t.hologramBrightness,
      "uniforms-scanline-size-value": t.scanlineSize,
      "uniforms-signal-speed-value": t.signalSpeed,
      "uniforms-hologram-color-value": t.hologramColor,
      "uniforms-hologram-opacity-value": t.hologramOpacity,
      "uniforms-blink-fresnel-only-value": t.blinkFresnelOnly,
      "enable-additive": t.enableAdditive,
      side: t.side
    }, null, 8, Qd));
  }
}), Jd = ["args"], ep = ["color"], Dg = /* @__PURE__ */ me({
  __name: "Box",
  props: {
    args: { default: () => [1, 1, 1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "boxRef",
      ref: i
    }, r.$attrs), [
      _e("TresBoxGeometry", { args: H(n) }, null, 8, Jd),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, ep)
      ])
    ], 16));
  }
}), Vo = new bt(), Js = new Z();
class cl extends Zl {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new rt(e, 3)), this.setAttribute("uv", new rt(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new rr(t, 6, 1);
    return this.setAttribute("instanceStart", new Kt(n, 3, 0)), this.setAttribute("instanceEnd", new Kt(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new rr(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Kt(n, 3, 0)), this.setAttribute("instanceColorEnd", new Kt(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new ql(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new bt());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Vo.setFromBufferAttribute(t), this.boundingBox.union(Vo));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let i = 0, r = e.count; i < r; i++)
        Js.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(Js)), Js.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(Js));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
Kn.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new ge(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ii.line = {
  uniforms: ns.merge([
    Kn.common,
    Kn.fog,
    Kn.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class kr extends Dt {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: ns.clone(ii.line.uniforms),
      vertexShader: ii.line.vertexShader,
      fragmentShader: ii.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const Yo = new Z(), Wo = new Z(), tt = new lt(), nt = new lt(), kt = new lt(), Zi = new Z(), qi = new Pe(), st = new Kl(), Xo = new Z(), ei = new bt(), ti = new fi(), Bt = new lt();
let zt, On;
function $o(o, e, t) {
  return Bt.set(0, 0, -e, 1).applyMatrix4(o.projectionMatrix), Bt.multiplyScalar(1 / Bt.w), Bt.x = On / t.width, Bt.y = On / t.height, Bt.applyMatrix4(o.projectionMatrixInverse), Bt.multiplyScalar(1 / Bt.w), Math.abs(Math.max(Bt.x, Bt.y));
}
function tp(o, e) {
  const t = o.matrixWorld, n = o.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, r = Math.min(n.instanceCount, s.count);
  for (let a = 0, l = r; a < l; a++) {
    st.start.fromBufferAttribute(s, a), st.end.fromBufferAttribute(i, a), st.applyMatrix4(t);
    const c = new Z(), u = new Z();
    zt.distanceSqToSegment(st.start, st.end, u, c), u.distanceTo(c) < On * 0.5 && e.push({
      point: u,
      pointOnLine: c,
      distance: zt.origin.distanceTo(u),
      object: o,
      face: null,
      faceIndex: a,
      uv: null,
      uv1: null
    });
  }
}
function np(o, e, t) {
  const n = e.projectionMatrix, i = o.material.resolution, r = o.matrixWorld, a = o.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, u = Math.min(a.instanceCount, l.count), h = -e.near;
  zt.at(1, kt), kt.w = 1, kt.applyMatrix4(e.matrixWorldInverse), kt.applyMatrix4(n), kt.multiplyScalar(1 / kt.w), kt.x *= i.x / 2, kt.y *= i.y / 2, kt.z = 0, Zi.copy(kt), qi.multiplyMatrices(e.matrixWorldInverse, r);
  for (let f = 0, p = u; f < p; f++) {
    if (tt.fromBufferAttribute(l, f), nt.fromBufferAttribute(c, f), tt.w = 1, nt.w = 1, tt.applyMatrix4(qi), nt.applyMatrix4(qi), tt.z > h && nt.z > h)
      continue;
    if (tt.z > h) {
      const x = tt.z - nt.z, T = (tt.z - h) / x;
      tt.lerp(nt, T);
    } else if (nt.z > h) {
      const x = nt.z - tt.z, T = (nt.z - h) / x;
      nt.lerp(tt, T);
    }
    tt.applyMatrix4(n), nt.applyMatrix4(n), tt.multiplyScalar(1 / tt.w), nt.multiplyScalar(1 / nt.w), tt.x *= i.x / 2, tt.y *= i.y / 2, nt.x *= i.x / 2, nt.y *= i.y / 2, st.start.copy(tt), st.start.z = 0, st.end.copy(nt), st.end.z = 0;
    const g = st.closestPointToPointParameter(Zi, !0);
    st.at(g, Xo);
    const v = Ze.lerp(tt.z, nt.z, g), d = v >= -1 && v <= 1, w = Zi.distanceTo(Xo) < On * 0.5;
    if (d && w) {
      st.start.fromBufferAttribute(l, f), st.end.fromBufferAttribute(c, f), st.start.applyMatrix4(r), st.end.applyMatrix4(r);
      const x = new Z(), T = new Z();
      zt.distanceSqToSegment(st.start, st.end, T, x), t.push({
        point: T,
        pointOnLine: x,
        distance: zt.origin.distanceTo(T),
        object: o,
        face: null,
        faceIndex: f,
        uv: null,
        uv1: null
      });
    }
  }
}
class sp extends le {
  constructor(e = new cl(), t = new kr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);
    for (let r = 0, a = 0, l = t.count; r < l; r++, a += 2)
      Yo.fromBufferAttribute(t, r), Wo.fromBufferAttribute(n, r), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + Yo.distanceTo(Wo);
    const i = new rr(s, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Kt(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new Kt(i, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, s = e.camera;
    s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    zt = e.ray;
    const r = this.matrixWorld, a = this.geometry, l = this.material;
    On = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), ti.copy(a.boundingSphere).applyMatrix4(r);
    let c;
    if (n)
      c = On * 0.5;
    else {
      const h = Math.max(s.near, ti.distanceToPoint(zt.origin));
      c = $o(s, h, l.resolution);
    }
    if (ti.radius += c, zt.intersectsSphere(ti) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), ei.copy(a.boundingBox).applyMatrix4(r);
    let u;
    if (n)
      u = On * 0.5;
    else {
      const h = Math.max(s.near, ei.distanceToPoint(zt.origin));
      u = $o(s, h, l.resolution);
    }
    ei.expandByScalar(u), zt.intersectsBox(ei) !== !1 && (n ? tp(this, t) : np(this, s, t));
  }
}
class ul extends cl {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setColors(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class ip extends sp {
  constructor(e = new ul(), t = new kr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
const rp = ["object"], op = /* @__PURE__ */ me({
  __name: "Line2",
  props: {
    points: {},
    vertexColors: { default: null },
    color: { default: "white" },
    lineWidth: { default: 1 },
    worldUnits: { type: Boolean, default: !1 },
    alphaToCoverage: { type: Boolean, default: !1 },
    dashed: { type: Boolean, default: !1 },
    dashSize: { default: 1 },
    gapSize: { default: 1 },
    dashScale: { default: 1 },
    dashOffset: { default: 0 }
  },
  setup(o) {
    const e = o;
    function t(u, h) {
      if (!u || u.length === 0)
        return Array.from({ length: h }).fill(gn(e.color));
      if (u.length === 1)
        return Array.from({ length: h }).fill(gn(u[0]));
      if (u.length === h)
        return u.map(gn);
      const f = h - 1, p = u.map(gn);
      closed && p.push(p[0].clone());
      const y = [p[0]], g = f / (p.length - 1);
      for (let v = 1; v < f; v++) {
        const d = v % g / g, w = Math.floor(v / g);
        y.push(p[w].clone().lerp(p[w + 1], d));
      }
      return y.push(p[p.length - 1]), y;
    }
    const n = new kr(), s = new ul(), i = new ip(s, n), r = ke().sizes, a = Fe(() => Array.isArray(e.vertexColors));
    function l(u, h) {
      u.color = gn(h.color), u.linewidth = h.lineWidth, u.alphaToCoverage = h.alphaToCoverage, u.worldUnits = h.worldUnits, u.vertexColors = Array.isArray(h.vertexColors), u.dashed = h.dashed, u.dashScale = h.dashScale, u.dashSize = h.dashSize, u.dashOffset = h.dashOffset, u.gapSize = h.gapSize, u.needsUpdate = !0;
    }
    function c(u, h, f) {
      const p = h.map((g) => g instanceof Z ? [g.x, g.y, g.z] : g instanceof ge ? [g.x, g.y, 0] : Array.isArray(g) && g.length === 2 ? [g[0], g[1], 0] : g).flat();
      u.setPositions(p.flat());
      const y = t(f, h.length).map((g) => g.toArray()).flat();
      u.setColors(y), i.computeLineDistances();
    }
    return l(n, e), c(s, e.points, e.vertexColors), i.computeLineDistances(), ve(() => [
      e.color,
      e.lineWidth,
      e.alphaToCoverage,
      e.worldUnits,
      a,
      e.dashed,
      e.dashScale,
      e.dashSize,
      e.dashOffset
    ], () => l(n, e)), ve([e.points, e.vertexColors], () => c(s, e.points, e.vertexColors)), ve(() => e.vertexColors, () => c(s, e.points, e.vertexColors)), ve(() => e.points, () => c(s, e.points, e.vertexColors)), ve([r.height, r.width], () => n.resolution = new ge(r.width.value, r.height.value)), ct(() => {
      s.dispose(), n.dispose();
    }), (u, h) => (ce(), ue("primitive", { object: H(i) }, null, 8, rp));
  }
}), Og = /* @__PURE__ */ me({
  __name: "CatmullRomCurve3",
  props: {
    segments: { default: 20 },
    closed: { type: Boolean, default: !1 },
    curveType: { default: "centripetal" },
    tension: { default: 0.5 },
    points: {},
    vertexColors: {},
    color: {},
    lineWidth: {},
    alphaToCoverage: { type: Boolean },
    dashed: { type: Boolean },
    dashSize: {},
    dashScale: {},
    dashOffset: {},
    gapSize: {},
    worldUnits: { type: Boolean }
  },
  setup(o) {
    const e = o;
    function t(r, a, l, c) {
      const u = r.map(
        (h) => h instanceof Z ? h : new Z(...h)
      );
      return new Ql(u, a, l, c);
    }
    function n(r, a) {
      return r.getPoints(a);
    }
    const s = Fe(() => t(e.points, e.closed, e.curveType, e.tension)), i = Fe(() => n(s.value, e.segments));
    return (r, a) => (ce(), Aa(op, {
      points: i.value,
      "vertex-colors": e.vertexColors,
      color: e.color,
      "line-width": e.lineWidth,
      "alpha-to-coverage": e.alphaToCoverage,
      dashed: e.dashed,
      "dash-size": e.dashSize,
      "dash-scale": e.dashScale,
      "dash-offset": e.dashOffset,
      "gap-size": e.gapSize,
      "world-units": e.worldUnits
    }, null, 8, ["points", "vertex-colors", "color", "line-width", "alpha-to-coverage", "dashed", "dash-size", "dash-scale", "dash-offset", "gap-size", "world-units"]));
  }
}), ap = ["args"], lp = ["color"], Lg = /* @__PURE__ */ me({
  __name: "Circle",
  props: {
    args: { default: () => [1, 32, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "circleRef",
      ref: i
    }, r.$attrs), [
      _e("TresCircleGeometry", { args: H(n) }, null, 8, ap),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, lp)
      ])
    ], 16));
  }
}), cp = ["args"], up = ["color"], Fg = /* @__PURE__ */ me({
  __name: "Cone",
  props: {
    args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "coneRef",
      ref: i
    }, r.$attrs), [
      _e("TresConeGeometry", { args: H(n) }, null, 8, cp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, up)
      ])
    ], 16));
  }
}), hp = ["args"], fp = ["color"], kg = /* @__PURE__ */ me({
  __name: "Dodecahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "dodecahedronRef",
      ref: i
    }, r.$attrs), [
      _e("TresDodecahedronGeometry", { args: H(n) }, null, 8, hp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, fp)
      ])
    ], 16));
  }
}), dp = ["args"], pp = ["color"], Bg = /* @__PURE__ */ me({
  __name: "Icosahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "icosahedronRef",
      ref: i
    }, r.$attrs), [
      _e("TresIcosahedronGeometry", { args: H(n) }, null, 8, dp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, pp)
      ])
    ], 16));
  }
}), mp = ["args"], gp = ["color"], Ug = /* @__PURE__ */ me({
  __name: "Octahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "octahedronRef",
      ref: i
    }, r.$attrs), [
      _e("TresOctahedronGeometry", { args: H(n) }, null, 8, mp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, gp)
      ])
    ], 16));
  }
}), vp = ["rotation"], yp = ["args"], _p = ["color"], Ng = /* @__PURE__ */ me({
  __name: "Plane",
  props: {
    args: { default: () => [1, 1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "planeRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, r.$attrs), [
      _e("TresPlaneGeometry", { args: H(n) }, null, 8, yp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, _p)
      ])
    ], 16, vp));
  }
}), xp = ["args"], wp = ["color"], zg = /* @__PURE__ */ me({
  __name: "Ring",
  props: {
    args: { default: () => [0.5, 1, 32] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "ringRef",
      ref: i
    }, r.$attrs), [
      _e("TresRingGeometry", { args: H(n) }, null, 8, xp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, wp)
      ])
    ], 16));
  }
}), Tp = ["args"], bp = ["color"], Hg = /* @__PURE__ */ me({
  __name: "RoundedBox",
  props: {
    args: { default: () => [1, 1, 1, 2, 0.1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), { extend: i } = ke();
    i({ RoundedBoxGeometry: Ku });
    const r = pe();
    return e({ value: r }), (a, l) => (ce(), ue("TresMesh", {
      ref_key: "roundedBoxRef",
      ref: r
    }, [
      _e("TresRoundedBoxGeometry", { args: H(n) }, null, 8, Tp),
      Ve(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, bp)
      ])
    ], 512));
  }
}), Ep = ["args"], Sp = ["color"], jg = /* @__PURE__ */ me({
  __name: "Sphere",
  props: {
    args: { default: () => [2, 32, 16] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "sphereRef",
      ref: i
    }, r.$attrs), [
      _e("TresSphereGeometry", { args: H(n) }, null, 8, Ep),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, Sp)
      ])
    ], 16));
  }
}), Mp = ["geometry"], Ap = ["color"], Gg = /* @__PURE__ */ me({
  __name: "Superformula",
  props: {
    widthSegments: { default: 32 },
    heightSegments: { default: 32 },
    numArmsA: { default: 4 },
    expA: { default: () => [40, 1.3, 0.9] },
    numArmsB: { default: 4 },
    expB: { default: () => [40, 1.3, 0.9] },
    color: { default: "white" }
  },
  setup(o, { expose: e }) {
    const t = o, { cos: n, sin: s, abs: i } = Math, r = pe(), a = pe(t.color);
    function l(f, p) {
      const y = new at(), g = f * p, v = new Float32Array(Array.from({ length: 3 * g }).fill(0)), d = new Float32Array(Array.from({ length: 3 * g }).fill(0)), w = [];
      for (let x = 0; x < p - 1; x++) {
        for (let m = 0; m < f - 1; m++) {
          const b = x * f + m, _ = b + 1, I = b + f, R = _ + f;
          w.push(b, I, _), w.push(I, R, _);
        }
        const T = x * f + f - 1, P = x * f, S = T + f, M = P + f;
        w.push(T, S, P), w.push(S, M, P);
      }
      return y.setIndex(w), y.setAttribute("position", new mt(v, 3)), y.setAttribute("normal", new mt(d, 3)), y;
    }
    function c(f, p, y, g, v) {
      return (i(n(p * f * 0.25)) ** g + i(s(p * f * 0.25)) ** v) ** (-1 / y);
    }
    function u(f, p, y, g, v, d, w, x, T, P, S) {
      const M = 2 * Math.PI / P, m = -Math.PI, b = Math.PI / (S - 1), _ = -0.5 * Math.PI, I = f.getAttribute("position");
      let R = 0, z = 0, k = _;
      for (let G = 0; G < S; G++) {
        z = m;
        for (let U = 0; U < P; U++) {
          const q = c(z, p, y, g, v), $ = c(k, d, w, x, T);
          I.setXYZ(
            R,
            q * n(z) * $ * n(k),
            $ * s(k),
            q * s(z) * $ * n(k)
          ), R++, z += M;
        }
        k += b;
      }
      I.needsUpdate = !0, f.computeVertexNormals();
    }
    ve(() => t.color, () => a.value = t.color), ve(() => [t.widthSegments, t.heightSegments], () => {
      r.value && r.value.dispose(), r.value = l(t.widthSegments, t.heightSegments);
    }, { immediate: !0 }), ve(() => [
      t.numArmsA,
      t.expA[0],
      t.expA[1],
      t.expA[2],
      t.numArmsB,
      t.expB[0],
      t.expB[1],
      t.expB[2]
    ], () => u(r.value, t.numArmsA, t.expA[0], t.expA[1], t.expA[2], t.numArmsB, t.expB[0], t.expB[1], t.expB[2], t.widthSegments, t.heightSegments), { immediate: !0 }), ct(() => {
      r.value && r.value.dispose();
    });
    const h = pe();
    return e({
      value: h
    }), (f, p) => (ce(), ue("TresMesh", We({
      ref_key: "superformulaRef",
      ref: h
    }, f.$attrs, { geometry: r.value }), [
      Ve(f.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: a.value }, null, 8, Ap)
      ])
    ], 16, Mp));
  }
}), Pp = ["rotation"], Cp = ["args"], Ip = ["color"], Vg = /* @__PURE__ */ me({
  __name: "Tetrahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "tetrahedronRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, r.$attrs), [
      _e("TresTetrahedronGeometry", { args: H(n) }, null, 8, Cp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, Ip)
      ])
    ], 16, Pp));
  }
}), Rp = ["args"], Dp = ["color"], Yg = /* @__PURE__ */ me({
  __name: "Torus",
  props: {
    args: { default: () => [1, 1, 16, 80] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "torusRef",
      ref: i
    }, r.$attrs), [
      _e("TresTorusGeometry", { args: H(n) }, null, 8, Rp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, Dp)
      ])
    ], 16));
  }
}), Op = ["args"], Lp = ["color"], Wg = /* @__PURE__ */ me({
  __name: "TorusKnot",
  props: {
    args: { default: () => [1, 0.4, 64, 8] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "torusKnotRef",
      ref: i
    }, r.$attrs), [
      _e("TresTorusKnotGeometry", { args: H(n) }, null, 8, Op),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, Lp)
      ])
    ], 16));
  }
}), Fp = ["args"], kp = ["color"], Xg = /* @__PURE__ */ me({
  __name: "Tube",
  props: {
    args: { default: () => [
      new Jl(new Z(-1, 0, 0), new Z(0, 1, 0), new Z(1, 0, 0)),
      20,
      0.2,
      8,
      !1
    ] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = Oe(t), i = pe();
    return e({
      value: i
    }), (r, a) => (ce(), ue("TresMesh", We({
      ref_key: "tubeRef",
      ref: i
    }, r.$attrs), [
      _e("TresTubeGeometry", { args: H(n) }, null, 8, Fp),
      Ve(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: H(s) }, null, 8, kp)
      ])
    ], 16));
  }
});
class Bp extends Mt {
  constructor() {
    super();
    ae(this, "virtualScene", null);
    this.virtualScene = new ws();
  }
  add(...t) {
    return this.virtualScene.add(...t), this;
  }
  destructor() {
    this.virtualScene.traverse((t) => {
      t instanceof le && (t.geometry.dispose(), t.material.dispose(), t.material.map && t.material.map.dispose(), this.virtualScene.remove(t));
    }), this.virtualScene = null;
  }
}
const $g = /* @__PURE__ */ me({
  __name: "component",
  props: {
    background: { type: [Boolean, String], default: !1 },
    blur: { default: 0 },
    files: { default: [] },
    path: { default: "" },
    preset: { default: void 0 },
    resolution: { default: 256 },
    near: { default: 1 },
    far: { default: 1e3 },
    frames: { default: Number.POSITIVE_INFINITY }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = he(null);
    e({ texture: i });
    const { extend: r, renderer: a, scene: l } = ke();
    let c = null;
    const u = he(null);
    let h = null;
    const f = he(null);
    ct(() => {
      var d, w;
      (d = f.value) == null || d.destructor(), (w = u.value) == null || w.dispose();
    });
    const { onBeforeLoop: p } = qe();
    let y = 1;
    p(() => {
      h && f.value && u.value && (s.frames === Number.POSITIVE_INFINITY || y < s.frames) && (h.update(a.value, dc(f.value.virtualScene)), y++);
    });
    const g = ([t, n] = Bn(() => _f(s, u)), t = await t, n(), t).texture, v = (d) => {
      d ? (l.value.environment = d.texture, s.background && (l.value.background = d.texture)) : (l.value.environment = g.value, s.background && (l.value.background = g.value));
    };
    return ve(g, () => {
      u.value && v(u.value);
    }, { immediate: !0, deep: !0 }), ve(br().default, (d) => {
      var w, x;
      if (d && (c = d, Array.isArray(c) && c.length > 0 && typeof ((w = c[0]) == null ? void 0 : w.type) != "symbol")) {
        r({ EnvSence: Bp }), u.value = new ec(s.resolution), u.value.texture.type = Qt, h = new tc(s.near, s.far, u.value), v(u.value);
        return;
      }
      (x = u.value) == null || x.dispose(), u.value = null, v();
    }, { immediate: !0, deep: !0 }), i.value = g, (d, w) => u.value ? (ce(), ue("TresEnvSence", {
      key: 0,
      ref_key: "envSence",
      ref: f
    }, [
      Ve(d.$slots, "default")
    ], 512)) : jt("", !0);
  }
}), Up = {
  key: 0,
  args: [0, 1, 64]
}, Np = {
  key: 1,
  args: [0.5, 1, 64]
}, zp = { key: 2 }, Hp = ["tone-mapped", "map", "side", "color"], Zg = /* @__PURE__ */ me({
  __name: "index",
  props: {
    args: { default: null },
    from: { default: "rect" },
    toneMapped: { type: Boolean, default: !1 },
    map: { default: null },
    intensity: { default: 1 },
    color: { default: new Re(16777215) }
  },
  setup(o) {
    const e = o, t = he();
    return ut(() => {
      t.value && (t.value.color.multiplyScalar(e.intensity), t.value.needsUpdate = !0);
    }), (n, s) => (ce(), ue("TresMesh", null, [
      n.from === "circle" ? (ce(), ue("TresRingGeometry", Up)) : n.from === "ring" ? (ce(), ue("TresRingGeometry", Np)) : n.from === "rect" ? (ce(), ue("TresPlaneGeometry", zp)) : (ce(), Aa(e.from, {
        key: 3,
        args: e
      })),
      _e("TresMeshBasicMaterial", {
        ref_key: "material",
        ref: t,
        "tone-mapped": n.toneMapped,
        map: n.map,
        side: H(wn),
        color: n.color
      }, null, 8, Hp)
    ]));
  }
}), jp = ["receive-shadow", "rotation"], Gp = ["args"], Vp = /* @__PURE__ */ _e("TresMeshStandardMaterial", {
  color: 8421504,
  side: 2
}, null, -1), qg = /* @__PURE__ */ me({
  __name: "Backdrop",
  props: {
    floor: { default: 0.25 },
    segments: { default: 20 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  setup(o) {
    const e = o, t = (a) => a === 0 ? 0 : 2 ** (10 * a - 10), { floor: n, segments: s, receiveShadow: i } = Oe(e), r = he(null);
    return ve(
      () => [s.value, n.value, r.value],
      ([a, l, c]) => {
        if (!c || a === null)
          return;
        let u = 0;
        const h = a / a / 2, f = c.attributes.position;
        for (let p = 0; p < a + 1; p++)
          for (let y = 0; y < a + 1; y++)
            f.setXYZ(
              u++,
              p / a - h + (p === 0 ? -l : 0),
              y / a - h,
              t(p / a)
            );
        f.needsUpdate = !0, c.computeVertexNormals();
      }
    ), (a, l) => (ce(), ue("TresGroup", pc(mc(a.$attrs)), [
      _e("TresMesh", {
        "receive-shadow": H(i),
        rotation: [-Math.PI / 2, 0, Math.PI / 2]
      }, [
        _e("TresPlaneGeometry", {
          ref_key: "planeRef",
          ref: r,
          args: [1, 1, H(s), H(s)]
        }, null, 8, Gp),
        Ve(a.$slots, "default", {}, () => [
          Vp
        ])
      ], 8, jp)
    ], 16));
  }
}), Yp = ["geometry"], Wp = ["map", "opacity", "depth-write"], Xp = ["object"], $p = ["args"], Zp = ["rotation", "args"], Kg = /* @__PURE__ */ me({
  __name: "ContactShadows",
  props: {
    opacity: { default: 1 },
    width: { default: 1 },
    height: { default: 1 },
    blur: { default: 1 },
    far: { default: 10 },
    smooth: { type: Boolean, default: !0 },
    resolution: { default: 512 },
    frames: { default: Number.POSITIVE_INFINITY },
    scale: { default: 10 },
    color: { default: "#000000" },
    depthWrite: { type: Boolean, default: !1 },
    helper: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o, n = pe(), s = pe();
    e(n);
    let i, r, a, l, c;
    const { renderer: u, scene: h } = ke(), f = Fe(() => t.width * (Array.isArray(t.scale) ? t.scale[0] : t.scale || 1)), p = Fe(() => t.height * (Array.isArray(t.scale) ? t.scale[1] : t.scale || 1));
    ut(() => {
      i && i.dispose(), r && r.dispose(), a && a.dispose(), l && l.geometry.dispose(), i = new Tn(t.resolution, t.resolution), r = new Tn(t.resolution, t.resolution), r.texture.generateMipmaps = i.texture.generateMipmaps = !1, s.value = new qt(
        -f.value / 2,
        f.value / 2,
        p.value / 2,
        -p.value / 2,
        0,
        t.far
      ), a = new Ut(f.value, p.value).rotateX(Math.PI / 2), l = new le(a), l.visible = !1;
    }), ut(() => {
      t.color && (c && c.dispose(), c = new nc(), c.depthTest = c.depthWrite = !1, c.onBeforeCompile = (P) => {
        P.uniforms = {
          ...P.uniforms,
          ucolor: { value: t.color ? new Re(t.color) : new Re() }
        }, P.fragmentShader = P.fragmentShader.replace(
          "void main() {",
          //
          `uniform vec3 ucolor;
             void main() {
            `
        ), P.fragmentShader = P.fragmentShader.replace(
          "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
          // Colorize the shadow, multiply by the falloff so that the center can remain darker
          "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
        );
      });
    });
    const y = new Dt(Qu), g = new Dt(Ju);
    g.depthTest = y.depthTest = !1;
    function v(P) {
      !u.value || !s.value || (l.visible = !0, l.material = y, y.uniforms.tDiffuse.value = i.texture, y.uniforms.h.value = P / 256, u.value.setRenderTarget(r), u.value.render(l, s.value), l.material = g, g.uniforms.tDiffuse.value = r.texture, g.uniforms.v.value = P / 256, u.value.setRenderTarget(i), u.value.render(l, s.value), l.visible = !1);
    }
    const { onLoop: d } = qe();
    let w = 0, x, T;
    return d(() => {
      !s.value || h.value === void 0 || u.value === void 0 || (t.frames === Number.POSITIVE_INFINITY || w < t.frames) && (w++, x = h.value.background, T = h.value.overrideMaterial, n.value.visible = !1, h.value.background = null, h.value.overrideMaterial = c, u.value.setRenderTarget(i), u.value.render(h.value, s.value), v(t.blur), t.smooth && v(t.blur * 0.4), u.value.setRenderTarget(null), n.value.visible = !0, h.value.background = x, h.value.overrideMaterial = T);
    }), (P, S) => (ce(), ue("TresGroup", We({
      ref_key: "groupRef",
      ref: n
    }, P.$attrs), [
      _e("TresMesh", {
        scale: [1, -1, 1],
        geometry: H(a)
      }, [
        _e("TresMeshBasicMaterial", {
          map: H(i).texture,
          opacity: P.opacity,
          "depth-write": P.depthWrite,
          transparent: !0
        }, null, 8, Wp)
      ], 8, Yp),
      _e("primitive", { object: H(l) }, null, 8, Xp),
      s.value && P.helper ? (ce(), ue("TresCameraHelper", {
        key: 0,
        args: [s.value]
      }, null, 8, $p)) : jt("", !0),
      _e("TresOrthographicCamera", {
        ref_key: "shadowCamera",
        ref: s,
        position: [0, 0, 0],
        rotation: [Math.PI / 2, 0, 0],
        args: [-f.value / 2, f.value / 2, p.value / 2, -p.value / 2, 0, P.far]
      }, null, 8, Zp)
    ], 16));
  }
}), Qg = /* @__PURE__ */ me({
  __name: "Fit",
  props: {
    into: { default: () => new bt(new Z(-0.5, -0.5, -0.5), new Z(0.5, 0.5, 0.5)) },
    precise: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o, n = pe(new Dn()), s = pe(new Dn());
    function i(l, c) {
      if (n.value.position.set(0, 0, 0), n.value.updateMatrixWorld(), s.value.scale.set(1, 1, 1), s.value.updateMatrixWorld(), !s.value.children.length || l === null)
        return;
      const { box3: u, use: h } = r(l, c), f = new bt();
      s.value.children.forEach((d) => f.expandByObject(d, c));
      const p = f.getSize(new Z()), y = u.getSize(new Z()), g = Math.min(
        y.x / p.x,
        y.y / p.y,
        y.z / p.z
      );
      s.value.scale.setScalar(g === Number.POSITIVE_INFINITY ? 1 : g), s.value.updateMatrixWorld();
      const v = n.value.worldToLocal(f.getCenter(new Z()));
      if (h.position) {
        const d = n.value.worldToLocal(u.getCenter(new Z()));
        n.value.position.copy(d.sub(v.multiplyScalar(g)));
      } else
        n.value.position.copy(v.sub(v.multiplyScalar(g)));
    }
    function r(l, c) {
      return typeof l == "number" ? l = new Z(l, l, l) : Array.isArray(l) && (l = new Z(...l)), l && "isVector3" in l && l.isVector3 ? { box3: new bt(new Z(0, 0, 0), l), use: { position: !1 } } : l && "isBox3" in l && l.isBox3 ? { box3: l, use: { position: !0 } } : l && "isObject3D" in l && l.isObject3D ? { box3: new bt().setFromObject(l, c ?? !1), use: { position: !0 } } : {
        box3: new bt(new Z(-0.5, -0.5, -0.5), new Z(0.5, 0.5, 0.5)),
        use: { position: !0 }
      };
    }
    ve(() => [t.into, t.precise], () => i(t.into, t.precise)), En(() => {
      i(t.into, t.precise), Er().then(() => {
        i(t.into, t.precise);
      });
    });
    const a = pe();
    return e({
      instance: a,
      fit: (l = new bt(new Z(-0.5, -0.5, -0.5), new Z(0.5, 0.5, 0.5)), c = !1) => {
        i(l, c);
      },
      update: () => i(t.into, t.precise)
    }), (l, c) => (ce(), ue("TresGroup", {
      ref_key: "outer",
      ref: a
    }, [
      _e("TresGroup", {
        ref_key: "middle",
        ref: n
      }, [
        _e("TresGroup", {
          ref_key: "inner",
          ref: s
        }, [
          Ve(l.$slots, "default")
        ], 512)
      ], 512)
    ], 512));
  }
}), qp = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], Kp = ["position", "velocity"], Jg = /* @__PURE__ */ me({
  __name: "Precipitation",
  props: {
    size: { default: 0.1 },
    area: { default: () => [10, 10, 20] },
    color: { default: 16777215 },
    map: {},
    alphaMap: {},
    alphaTest: { default: 0.01 },
    opacity: { default: 0.8 },
    count: { default: 5e3 },
    speed: { default: 0.1 },
    randomness: { default: 0.5 },
    depthWrite: { type: Boolean, default: !1 },
    transparent: { type: Boolean, default: !0 },
    sizeAttenuation: { type: Boolean, default: !0 }
  },
  setup(o) {
    const e = o, {
      size: t,
      area: n,
      color: s,
      alphaMap: i,
      map: r,
      opacity: a,
      alphaTest: l,
      depthWrite: c,
      transparent: u,
      sizeAttenuation: h,
      count: f,
      speed: p,
      randomness: y
    } = Oe(e), g = pe();
    let v = [], d = [];
    const w = () => {
      v = new Float32Array(f.value * 3);
      for (let P = 0; P < f.value; P++) {
        const S = P * 3;
        v[S] = (Math.random() - 0.5) * n.value[0], v[S + 1] = (Math.random() - 0.5) * n.value[1], v[S + 2] = (Math.random() - 0.5) * n.value[2];
      }
    }, x = () => {
      d = new Float32Array(f.value * 2);
      for (let P = 0; P < f.value * 2; P += 2)
        d[P] = (Math.random() - 0.5) / 5 * p.value * y.value, d[P + 1] = Math.random() / 5 * p.value + 0.01;
    };
    x(), w(), ut(() => {
      x(), w();
    });
    const { onLoop: T } = qe();
    return T(() => {
      var P, S;
      if ((P = g.value) != null && P.attributes.position.array && ((S = g.value) != null && S.attributes.position.count)) {
        const M = g.value.attributes.position.array;
        for (let m = 0; m < g.value.attributes.position.count; m++) {
          const b = d[m * 2], _ = d[m * 2 + 1];
          M[m * 3] += b, M[m * 3 + 1] -= _, (M[m * 3] <= -n.value[0] / 2 || M[m * 3] >= n.value[0] / 2) && (M[m * 3] = M[m * 3] * -1), (M[m * 3 + 1] <= -n.value[1] / 2 || M[m * 3 + 1] >= n.value[1] / 2) && (M[m * 3 + 1] = M[m * 3 + 1] * -1);
        }
        g.value.attributes.position.needsUpdate = !0;
      }
    }), (P, S) => (ce(), ue("TresPoints", null, [
      _e("TresPointsMaterial", {
        size: H(t),
        color: H(s),
        "alpha-map": H(i),
        map: H(r),
        opacity: H(a),
        "alpha-test": H(l),
        "depth-write": H(c),
        transparent: H(u),
        "size-attenuation": H(h)
      }, null, 8, qp),
      _e("TresBufferGeometry", {
        ref_key: "geometryRef",
        ref: g,
        position: [H(v), 3],
        velocity: [H(d)]
      }, null, 8, Kp)
    ]));
  }
});
class mi extends le {
  constructor() {
    const e = mi.SkyShader, t = new Dt({
      name: e.name,
      uniforms: ns.clone(e.uniforms),
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      side: va,
      depthWrite: !1
    });
    super(new $t(1, 1, 1), t), this.isSky = !0;
  }
}
mi.SkyShader = {
  name: "SkyShader",
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new Z() },
    up: { value: new Z(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
  )
};
const Qp = ["object", "material-uniforms-turbidity-value", "material-uniforms-rayleigh-value", "material-uniforms-mie-coefficient-value", "material-uniforms-mie-directional-g-value", "material-uniforms-sun-position-value", "scale"], e0 = /* @__PURE__ */ me({
  __name: "Sky",
  props: {
    turbidity: { default: 3.4 },
    rayleigh: { default: 3 },
    mieCoefficient: { default: 5e-3 },
    mieDirectionalG: { default: 0.7 },
    elevation: { default: 0.6 },
    azimuth: { default: 180 },
    distance: { default: 45e4 }
  },
  setup(o, { expose: e }) {
    const t = o, n = pe(), s = new mi(), i = Fe(
      () => r(t.azimuth, t.elevation)
    );
    function r(a, l) {
      const c = Ze.degToRad(90 - l), u = Ze.degToRad(a);
      return new Z().setFromSphericalCoords(1, c, u);
    }
    return e({
      root: n,
      sunPosition: i.value
    }), (a, l) => (ce(), ue("primitive", {
      ref_key: "skyRef",
      ref: n,
      object: H(s),
      "material-uniforms-turbidity-value": t.turbidity,
      "material-uniforms-rayleigh-value": t.rayleigh,
      "material-uniforms-mie-coefficient-value": t.mieCoefficient,
      "material-uniforms-mie-directional-g-value": t.mieDirectionalG,
      "material-uniforms-sun-position-value": i.value,
      scale: t.distance
    }, null, 8, Qp));
  }
}), Jp = ["position"], em = ["position"], tm = ["scale"], nm = ["map", "depth-test", "color-space", "color", "opacity"], t0 = /* @__PURE__ */ me({
  __name: "Smoke",
  props: {
    color: { default: "#ffffff" },
    opacity: { default: 0.5 },
    speed: { default: 0.4 },
    width: { default: 10 },
    depth: { default: 1.5 },
    segments: { default: 20 },
    texture: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png" },
    depthTest: { type: Boolean, default: !0 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, { width: i, depth: r, segments: a, texture: l, color: c, depthTest: u, opacity: h, speed: f } = Oe(s), p = pe(), y = pe();
    e({
      value: p
    });
    const g = [a].map((S, M) => ({
      x: i.value / 2 - Math.random() * i.value,
      y: i.value / 2 - Math.random() * i.value,
      scale: 0.4 + Math.sin((M + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
      density: Math.max(0.2, Math.random()),
      rotation: Math.max(2e-3, 5e-3 * Math.random()) * f.value
    })), v = (S, M) => S / 6 * M * h.value, { map: d } = ([t, n] = Bn(() => ai({ map: l.value })), t = await t, n(), t), { renderer: w, camera: x } = ke(), T = Fe(() => {
      var S;
      return (S = w.value) == null ? void 0 : S.outputColorSpace;
    }), { onLoop: P } = qe();
    return P(() => {
      var S, M;
      p.value && x.value && y.value && ((S = y.value) == null || S.children.forEach((m, b) => {
        m.rotation.z += g[b].rotation;
      }), p.value.lookAt((M = x.value) == null ? void 0 : M.position));
    }), (S, M) => (ce(), ue("TresGroup", We({
      ref_key: "smokeRef",
      ref: p
    }, S.$attrs), [
      _e("TresGroup", {
        ref_key: "groupRef",
        ref: y,
        position: [0, 0, H(a) / 2 * H(r)]
      }, [
        (ce(!0), ue(Ea, null, Sa(H(g), ({ scale: m, x: b, y: _, density: I }, R) => (ce(), ue("TresMesh", {
          key: `${R}`,
          position: [b, _, -R * H(r)]
        }, [
          _e("TresPlaneGeometry", {
            scale: [m, m, m],
            rotation: [0, 0, 0]
          }, null, 8, tm),
          _e("TresMeshStandardMaterial", {
            map: H(d),
            "depth-test": H(u),
            "color-space": T.value,
            color: H(c),
            "depth-write": !1,
            transparent: "",
            opacity: v(m, I)
          }, null, 8, nm)
        ], 8, em))), 128))
      ], 8, Jp)
    ], 16));
  }
});
function sm(o) {
  return Br(o, {
    normalizeValue: (e) => gn(e),
    getDefaultValue: () => new Re(0, 0, 0),
    isSingleValue: (e) => !Array.isArray(e),
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function Ki(o) {
  return "isVector3" in o || Array.isArray(o) && o.length > 0 && o.every((e) => typeof e == "number");
}
function im(o) {
  return Br(o, {
    normalizeValue: (e) => yc(e),
    getDefaultValue: () => [0, 0, 0],
    isSingleValue: (e) => Ki(e),
    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && Ki(e[0]),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && Ki(e[0][1]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function rm(o) {
  return Br(o, {
    normalizeValue: (e) => e,
    getDefaultValue: () => 1,
    isSingleValue: (e) => !Array.isArray(e) && typeof e < "u",
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function Br(o, e) {
  const { normalizeValue: t, getDefaultValue: n, isEmpty: s } = e, i = (l) => e.isSingleValue(l), r = (l) => e.isMultipleValues(l), a = (l) => e.isMultipleValuesWithStops(l);
  if (s(o))
    return [[0, n()]];
  if (i(o))
    return [[0, t(o)]];
  if (r(o)) {
    const l = o.length > 1 ? 1 / (o.length - 1) : 1;
    return o.map((c, u) => [l * u, t(c)]);
  } else if (a(o))
    return o.map(([l, c], u) => [l, t(c)]);
  return [[0, n()]];
}
class om {
  constructor(e, t) {
    ae(this, "entries");
    ae(this, "resolution");
    this.entries = e, this.resolution = t;
  }
  useTexture() {
    return new cm(this.entries, this.resolution).use();
  }
}
class Ur {
  constructor(e, t, n, s, i, r) {
    ae(this, "data");
    ae(this, "ref");
    ae(this, "name");
    ae(this, "valueMin");
    ae(this, "valueMax");
    ae(this, "suffix");
    ae(this, "renderToCanvasGradient");
    this.data = oi(e) ? e.value : e, this.ref = oi(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = r;
  }
}
class am extends Ur {
  constructor(e, t = "color", n = 0, s = 1, i = "rgba", r = um) {
    super(e, t, n, s, i, r);
  }
}
class Zo extends Ur {
  constructor(e, t = "scalar", n = 0, s = 1, i = "x", r = hm) {
    super(e, t, n, s, i, r);
  }
}
class lm extends Ur {
  constructor(e, t = "scalar3", n = 0, s = 1, i = "xyz", r = fm) {
    super(e, t, n, s, i, r);
  }
}
class cm {
  constructor(e, t) {
    ae(this, "entries");
    ae(this, "size");
    ae(this, "dirty", pe(0));
    ae(this, "context");
    this.entries = e, this.size = Math.max(t, e.length);
    const n = document.createElement("canvas");
    n.height = this.size, n.width = this.size, this.context = n.getContext("2d");
  }
  use() {
    const e = this.build(), t = pe(e);
    for (const n of this.entries)
      n.ref && ve(n.ref, () => {
        var s;
        n.data = (s = n.ref) == null ? void 0 : s.value, gc(this.dirty);
      });
    return Nh(
      this.dirty,
      () => {
        this.build(e), t.value = e;
      },
      { throttle: 1e3 / 60 }
    ), {
      texture: t,
      dispose: () => e.dispose(),
      yFor: this.entries.reduce((n, s, i) => (n[s.name] = (i + 0.5) / this.size, n), {})
    };
  }
  build(e) {
    this.entries.forEach((n, s) => {
      const i = this.context.createLinearGradient(0, s, this.size, s);
      n.renderToCanvasGradient(i, n), this.context.fillStyle = i, this.context.fillRect(0, s, this.size, 1);
    }), e && (e.source.data = this.context.getImageData(
      0,
      0,
      this.size,
      this.size
    ));
    const t = e ?? new wa(
      this.context.getImageData(0, 0, this.size, this.size).data,
      this.size,
      this.size,
      Jo,
      ir,
      sc,
      es,
      es
    );
    return t.needsUpdate = !0, t;
  }
}
function hl(o, e, t, n, s) {
  return zf(vn(o, e, t), e, t, n, s);
}
function um(o, e) {
  return sm(e.data).forEach(
    ([t, n]) => o.addColorStop(
      t,
      `rgb(${n.r * 255}, ${n.g * 255}, ${n.b * 255})`
    )
  );
}
function hm(o, e) {
  return rm(e.data).forEach(([t, n]) => {
    o.addColorStop(
      t,
      `rgb(${hl(
        n,
        e.valueMin,
        e.valueMax,
        0,
        255
      )}, 0, 0)`
    );
  });
}
function fm(o, e) {
  return im(e.data).forEach(
    ([t, n]) => o.addColorStop(
      t,
      `rgb(${n.map(
        (s) => hl(s, e.valueMin, e.valueMax, 0, 255)
      )})`
    )
  );
}
class dm {
  constructor(e = 256) {
    ae(this, "entries");
    ae(this, "resolution");
    this.resolution = e, this.entries = [];
  }
  withResolution(e) {
    return this.resolution = e, this;
  }
  get add() {
    return new mm(
      (e) => this.onAdd(e)
    );
  }
  build() {
    return new om(this.entries, this.resolution);
  }
  onAdd(e) {
    return this.entries.push(e), new pm(e, this);
  }
}
class pm {
  constructor(e, t) {
    ae(this, "entry");
    ae(this, "parent");
    this.entry = e, this.parent = t;
  }
  id(e) {
    return this.entry.name = e, this;
  }
  range(e, t) {
    return this.entry.valueMin = e, this.entry.valueMax = t, this;
  }
  suffix(e) {
    return this.entry.suffix = e, this;
  }
  canvasGradientRenderer(e) {
    return this.entry.renderToCanvasGradient = e, this;
  }
  /**
   * Add another entry to the ShaderDataBuilder
   */
  get add() {
    return this.parent.add;
  }
  /**
   * Finalize the ShaderDataBuilder
   * @returns ShaderData
   */
  build() {
    return this.parent.build();
  }
}
class mm {
  constructor(e) {
    ae(this, "onAdd");
    this.onAdd = e;
  }
  GradientTresColor(e) {
    return this.onAdd(new am(e));
  }
  Gradient01(e) {
    return this.onAdd(new Zo(e, "zeroOne", 0, 1));
  }
  GradientScalar(e, t, n) {
    return this.onAdd(
      new Zo(e, "scalar", t, n)
    );
  }
  GradientXyz(e, t, n) {
    return this.onAdd(
      new lm(e, "position", t, n)
    );
  }
}
let Qi = null;
function gm() {
  return Qi === null && (Qi = new wa(new Uint8Array([0, 0, 0, 0]), 1, 1)), Qi;
}
const vm = ["object"], n0 = /* @__PURE__ */ me({
  __name: "component",
  props: {
    map: { default: "https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png" },
    geometry: { default: void 0 },
    directionalLight: { default: void 0 },
    lifetimeSec: { default: 0.4 },
    cooldownSec: { default: 2 },
    normalThreshold: { default: 0.7 },
    noiseScale: { default: 3 },
    scaleNoise: { default: 1 },
    offsetNoise: { default: 0.1 },
    lifetimeNoise: { default: 0 },
    size: { default: 1 },
    alpha: { default: 1 },
    offset: { default: 1 },
    surfaceDistance: { default: 1 },
    sequenceColor: { default: () => [[0.7, "#82dbc5"], [0.8, "#fbb03b"]] },
    sequenceAlpha: { default: () => [[0, 0], [0.1, 1], [0.5, 1], [0.9, 0]] },
    sequenceOffset: { default: () => [0, 0, 0] },
    sequenceNoise: { default: () => [0.1, 0.1, 0.1] },
    sequenceSize: { default: () => [0, 1] },
    sequenceSurfaceDistance: { default: () => [0.05, 0.08, 0.1] },
    mixColor: { default: 0.5 },
    mixAlpha: { default: 1 },
    mixOffset: { default: 1 },
    mixSize: { default: 0 },
    mixSurfaceDistance: { default: 1 },
    mixNoise: { default: 1 },
    blending: { default: Tr },
    transparent: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(o) {
    const e = o, t = Number.parseInt(vr.replace(/\D+/g, "")), n = Oe(e), s = typeof e.map == "string" ? gm() : e.map, { texture: i, yFor: r } = new dm(256).add.GradientTresColor(n.sequenceColor).id("sequenceColor").add.Gradient01(n.sequenceAlpha).id("sequenceAlpha").add.Gradient01(n.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(n.sequenceSize).id("sequenceSize").add.GradientXyz(n.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(n.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture(), a = {
      blending: e.blending,
      transparent: e.transparent,
      depthWrite: e.depthWrite,
      uniforms: {
        uMap: new Ee(s),
        uPixelRatio: new Ee(1),
        uNormal: new Ee(Mt.DEFAULT_UP),
        uNormalThreshold: new Ee(e.normalThreshold),
        uTime: new Ee(0),
        uCooldownRatio: new Ee(1),
        uSize: new Ee(e.size),
        uAlpha: new Ee(e.alpha),
        uOffset: new Ee(e.offset),
        uSurfaceDistance: new Ee(e.surfaceDistance),
        uNoiseScale: new Ee(e.noiseScale),
        uScaleNoise: new Ee(e.scaleNoise),
        uOffsetNoise: new Ee(e.offsetNoise),
        uLifetimeNoise: new Ee(e.lifetimeNoise),
        uMixColor: new Ee(e.mixColor),
        uMixAlpha: new Ee(e.mixAlpha),
        uMixOffset: new Ee(e.mixOffset),
        uMixSize: new Ee(e.mixSize),
        uMixSurfaceDistance: new Ee(e.mixSurfaceDistance),
        uMixNoise: new Ee(e.mixNoise),
        uInfoTexture: new Ee(i.value)
      },
      vertexShader: `
    uniform float uPixelRatio;
    uniform vec3 uNormal;
    uniform float uNormalThreshold;
    uniform float uTime;
    uniform float uCooldownRatio;
    uniform float uSize;
    uniform float uAlpha;
    uniform float uOffset;
    uniform float uSurfaceDistance;
    uniform float uNoiseScale;
    uniform float uScaleNoise;
    uniform float uOffsetNoise;
    uniform float uLifetimeNoise;
    uniform float uMixColor;
    uniform float uMixAlpha;
    uniform float uMixOffset;
    uniform float uMixSize;
    uniform float uMixSurfaceDistance;
    uniform float uMixNoise;
    uniform sampler2D uInfoTexture;

    varying vec4 vColor;

    void main() {
      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;
      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);
      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);

      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + 
      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;

      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
      float surfaceDistance = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixSurfaceDistance),
        ${r.sequenceSurfaceDistance})).x * uSurfaceDistance;

      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
      vec3 noise = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixNoise),
        ${r.sequenceNoise})).xyz;
      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixOffset),
        ${r.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;

      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;

      gl_PointSize = 2.
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${r.sequenceSize})).x
      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;

      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }

      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${r.sequenceColor}))
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${r.sequenceAlpha})).x * uAlpha;
    }`,
      fragmentShader: `
    varying vec4 vColor;

    uniform sampler2D uMap;
    uniform sampler2D uInfoTexture;

    void main() {
      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
      #include <tonemapping_fragment>
      #include <${t >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }`
    }, l = new Dt(a), c = new ha(void 0, l), u = l.uniforms, h = { immediate: !0 };
    [
      [u.uPixelRatio, ke().sizes.aspectRatio],
      [u.uSize, n.size],
      [u.uNormalThreshold, n.normalThreshold],
      [u.uAlpha, n.alpha],
      [u.uOffset, n.offset],
      [u.uOffsetNoise, n.offsetNoise],
      [u.uMixColor, n.mixColor],
      [u.uMixAlpha, n.mixAlpha],
      [u.uMixOffset, n.mixOffset],
      [u.uMixSize, n.mixSize],
      [u.uMixSurfaceDistance, n.mixSurfaceDistance],
      [u.uMixNoise, n.mixNoise],
      [u.uInfoTexture, i]
    ].forEach(
      ([w, x]) => ve(
        x,
        () => {
          w.value = x.value;
        },
        h
      )
    ), ve([n.noiseScale, n.lifetimeSec], () => {
      u.uNoiseScale.value = n.noiseScale.value * n.lifetimeSec.value;
    }, h), ve([n.lifetimeSec, n.cooldownSec], () => {
      u.uCooldownRatio.value = n.cooldownSec.value / n.lifetimeSec.value;
    }, h), ve(n.map, () => {
      typeof n.map.value == "string" ? ai([n.map.value]).then((w) => l.uniforms.uMap.value = w) : l.uniforms.uMap.value = n.map.value;
    });
    const p = new He(), y = new Z();
    qe().onLoop(({ elapsed: w }) => {
      c.getWorldQuaternion(p), y.copy(e.directionalLight ? e.directionalLight.position : Mt.DEFAULT_UP).normalize(), y.applyQuaternion(p.invert()), l.uniforms.uNormal.value = y, l.uniforms.uTime.value = w / (e.cooldownSec + e.lifetimeSec);
    });
    function g(w) {
      return w && "isObject3D" in w;
    }
    function v(w) {
      return w && "isBufferGeometry" in w;
    }
    En(() => {
      e.geometry ? v(e.geometry) ? c.geometry.copy(e.geometry) : g(e.geometry) && "geometry" in e.geometry && v(e.geometry.geometry) && c.geometry.copy(e.geometry.geometry) : g(c.parent) && "geometry" in c.parent && v(c.parent.geometry) ? c.geometry.copy(c.parent.geometry) : c.geometry = new ic(1, 16), typeof e.map == "string" && ai([e.map]).then((w) => l.uniforms.uMap.value = w);
    }), ct(() => {
      var w;
      (w = l.uniforms.uMap.value) == null || w.dispose(), i.value.dispose(), l.dispose();
    });
    const d = pe();
    return (w, x) => (ce(), ue("primitive", {
      ref_key: "sparkleRef",
      ref: d,
      object: H(c)
    }, null, 8, vm));
  }
}), ym = ["position", "a-scale"], _m = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], s0 = /* @__PURE__ */ me({
  __name: "Stars",
  props: {
    size: { default: 0.1 },
    sizeAttenuation: { type: Boolean, default: !0 },
    transparent: { type: Boolean, default: !0 },
    alphaTest: { default: 0.01 },
    count: { default: 5e3 },
    depth: { default: 50 },
    radius: { default: 100 },
    alphaMap: { default: null }
  },
  setup(o, { expose: e }) {
    const t = o, n = he(), s = he(), { radius: i, depth: r, count: a, size: l, sizeAttenuation: c, transparent: u, alphaMap: h, alphaTest: f } = Oe(t), p = () => {
      let g = i.value + r.value;
      const v = Fe(() => r.value / a.value), d = [], w = Array.from(
        { length: a.value },
        () => (0.5 + 0.5 * Math.random()) * 4
      ), x = (T) => new Z().setFromSpherical(new ri(T, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
      for (let T = 0; T < a.value; T++)
        g -= v.value * Math.random(), d.push(...x(g));
      n.value = new Float32Array(d), s.value = new Float32Array(w);
    };
    ut(() => {
      p();
    });
    const y = pe();
    return e({
      value: y
    }), (g, v) => (ce(), ue("TresPoints", {
      ref_key: "starsRef",
      ref: y
    }, [
      _e("TresBufferGeometry", {
        position: [n.value, 3],
        "a-scale": [s.value, 1]
      }, null, 8, ym),
      _e("TresPointsMaterial", {
        size: H(l),
        "size-attenuation": H(c),
        transparent: H(u),
        "alpha-test": H(f),
        "alpha-map": H(h)
      }, null, 8, _m)
    ], 512));
  }
});
class xm extends le {
  constructor(e, t = {}) {
    super(e), this.isWater = !0;
    const n = this, s = t.textureWidth !== void 0 ? t.textureWidth : 512, i = t.textureHeight !== void 0 ? t.textureHeight : 512, r = t.clipBias !== void 0 ? t.clipBias : 0, a = t.alpha !== void 0 ? t.alpha : 1, l = t.time !== void 0 ? t.time : 0, c = t.waterNormals !== void 0 ? t.waterNormals : null, u = t.sunDirection !== void 0 ? t.sunDirection : new Z(0.70707, 0.70707, 0), h = new Re(t.sunColor !== void 0 ? t.sunColor : 16777215), f = new Re(t.waterColor !== void 0 ? t.waterColor : 8355711), p = t.eye !== void 0 ? t.eye : new Z(0, 0, 0), y = t.distortionScale !== void 0 ? t.distortionScale : 20, g = t.side !== void 0 ? t.side : Ms, v = t.fog !== void 0 ? t.fog : !1, d = new hi(), w = new Z(), x = new Z(), T = new Z(), P = new Pe(), S = new Z(0, 0, -1), M = new lt(), m = new Z(), b = new Z(), _ = new lt(), I = new Pe(), R = new St(), z = new Tn(s, i), k = {
      name: "MirrorShader",
      uniforms: ns.merge([
        Kn.fog,
        Kn.lights,
        {
          normalSampler: { value: null },
          mirrorSampler: { value: null },
          alpha: { value: 1 },
          time: { value: 0 },
          size: { value: 1 },
          distortionScale: { value: 20 },
          textureMatrix: { value: new Pe() },
          sunColor: { value: new Re(8355711) },
          sunDirection: { value: new Z(0.70707, 0.70707, 0) },
          eye: { value: new Z() },
          waterColor: { value: new Re(5592405) }
        }
      ]),
      vertexShader: (
        /* glsl */
        `
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`
      ),
      fragmentShader: (
        /* glsl */
        `
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <colorspace_fragment>
					#include <fog_fragment>	
				}`
      )
    }, G = new Dt({
      name: k.name,
      uniforms: ns.clone(k.uniforms),
      vertexShader: k.vertexShader,
      fragmentShader: k.fragmentShader,
      lights: !0,
      side: g,
      fog: v
    });
    G.uniforms.mirrorSampler.value = z.texture, G.uniforms.textureMatrix.value = I, G.uniforms.alpha.value = a, G.uniforms.time.value = l, G.uniforms.normalSampler.value = c, G.uniforms.sunColor.value = h, G.uniforms.waterColor.value = f, G.uniforms.sunDirection.value = u, G.uniforms.distortionScale.value = y, G.uniforms.eye.value = p, n.material = G, n.onBeforeRender = function(U, q, $) {
      if (x.setFromMatrixPosition(n.matrixWorld), T.setFromMatrixPosition($.matrixWorld), P.extractRotation(n.matrixWorld), w.set(0, 0, 1), w.applyMatrix4(P), m.subVectors(x, T), m.dot(w) > 0)
        return;
      m.reflect(w).negate(), m.add(x), P.extractRotation($.matrixWorld), S.set(0, 0, -1), S.applyMatrix4(P), S.add(T), b.subVectors(x, S), b.reflect(w).negate(), b.add(x), R.position.copy(m), R.up.set(0, 1, 0), R.up.applyMatrix4(P), R.up.reflect(w), R.lookAt(b), R.far = $.far, R.updateMatrixWorld(), R.projectionMatrix.copy($.projectionMatrix), I.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      ), I.multiply(R.projectionMatrix), I.multiply(R.matrixWorldInverse), d.setFromNormalAndCoplanarPoint(w, x), d.applyMatrix4(R.matrixWorldInverse), M.set(d.normal.x, d.normal.y, d.normal.z, d.constant);
      const te = R.projectionMatrix;
      _.x = (Math.sign(M.x) + te.elements[8]) / te.elements[0], _.y = (Math.sign(M.y) + te.elements[9]) / te.elements[5], _.z = -1, _.w = (1 + te.elements[10]) / te.elements[14], M.multiplyScalar(2 / M.dot(_)), te.elements[2] = M.x, te.elements[6] = M.y, te.elements[10] = M.z + 1 - r, te.elements[14] = M.w, p.setFromMatrixPosition($.matrixWorld);
      const ee = U.getRenderTarget(), oe = U.xr.enabled, de = U.shadowMap.autoUpdate;
      n.visible = !1, U.xr.enabled = !1, U.shadowMap.autoUpdate = !1, U.setRenderTarget(z), U.state.buffers.depth.setMask(!0), U.autoClear === !1 && U.clear(), U.render(q, R), n.visible = !0, U.xr.enabled = oe, U.shadowMap.autoUpdate = de, U.setRenderTarget(ee);
      const xe = $.viewport;
      xe !== void 0 && U.state.viewport(xe);
    };
  }
}
const wm = ["rotation-x", "args"], Tm = /* @__PURE__ */ _e("TresPlaneGeometry", { args: [1e4, 1e4] }, null, -1), i0 = /* @__PURE__ */ me({
  __name: "Ocean",
  props: {
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    waterNormals: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg" },
    sunDirection: { default: () => new Z() },
    sunColor: { default: 16777215 },
    waterColor: { default: 7695 },
    distortionScale: { default: 3.7 },
    size: { default: 1 },
    clipBias: { default: 0 },
    alpha: { default: 1 },
    side: { default: Ms }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, { textureWidth: i, textureHeight: r, waterNormals: a, sunDirection: l, sunColor: c, waterColor: u, distortionScale: h, size: f, clipBias: p, alpha: y, side: g } = Oe(s), { extend: v, scene: d } = ke();
    v({ Water: xm });
    const w = pe(), x = pe(), T = d.value.fog !== void 0;
    e({
      root: w
    }), d.value.traverse((M) => {
      Object.prototype.hasOwnProperty.call(M, "isSky") && (x.value = M);
    }), En(async () => {
      if (await Er(), x.value) {
        const M = x.value.material.uniforms.sunPosition.value;
        w.value.material.uniforms.sunDirection.value.copy(M);
      }
    });
    const { normalMap: P } = ([t, n] = Bn(() => ai({ normalMap: a.value })), t = await t, n(), t);
    P.wrapS = P.wrapT = Ln;
    const { onLoop: S } = qe();
    return S(({ delta: M }) => {
      w.value.material.uniforms.time.value += M;
    }), (M, m) => (ce(), ue("TresWater", {
      ref_key: "waterRef",
      ref: w,
      "rotation-x": -Math.PI / 2,
      args: [void 0, {
        textureWidth: H(i),
        textureHeight: H(r),
        waterNormals: H(P),
        sunDirection: H(l),
        sunColor: H(c),
        waterColor: H(u),
        distortionScale: H(h),
        fog: T,
        size: H(f),
        clipBias: H(p),
        alpha: H(y),
        side: H(g)
      }]
    }, [
      Ve(M.$slots, "default", {}, () => [
        Tm
      ])
    ], 8, wm));
  }
});
let Wt;
const r0 = (o = "body") => {
  Wt || (Wt = new _c({
    container: document.querySelector(o)
  }), Wt.element.style.position = "absolute", Wt.element.style.top = "1rem", Wt.element.style.right = "1rem", Wt.element.style.zIndex = "9999");
  const { logWarning: e } = Or();
  e("useTweakPane is deprecated as of Cientos v3.7.0 and will no longer be part of this package. Please migrate to @tresjs/leches package https://github.com/Tresjs/leches or v-tweakpane https://github.com/vinayakkulkarni/v-tweakpane instead.");
  function t() {
    Wt && Wt.dispose();
  }
  return En(() => {
    const { resume: n } = qe();
    n();
  }), ct(() => {
    t();
  }), { pane: Wt, disposeTweakPane: t };
};
var fl = { exports: {} };
(function(o, e) {
  (function(t, n) {
    o.exports = n();
  })(Yf, function() {
    var t = function() {
      function n(p) {
        return r.appendChild(p.dom), p;
      }
      function s(p) {
        for (var y = 0; y < r.children.length; y++)
          r.children[y].style.display = y === p ? "block" : "none";
        i = p;
      }
      var i = 0, r = document.createElement("div");
      r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(p) {
        p.preventDefault(), s(++i % r.children.length);
      }, !1);
      var a = (performance || Date).now(), l = a, c = 0, u = n(new t.Panel("FPS", "#0ff", "#002")), h = n(new t.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory)
        var f = n(new t.Panel("MB", "#f08", "#201"));
      return s(0), { REVISION: 16, dom: r, addPanel: n, showPanel: s, begin: function() {
        a = (performance || Date).now();
      }, end: function() {
        c++;
        var p = (performance || Date).now();
        if (h.update(p - a, 200), p > l + 1e3 && (u.update(1e3 * c / (p - l), 100), l = p, c = 0, f)) {
          var y = performance.memory;
          f.update(y.usedJSHeapSize / 1048576, y.jsHeapSizeLimit / 1048576);
        }
        return p;
      }, update: function() {
        a = this.end();
      }, domElement: r, setMode: s };
    };
    return t.Panel = function(n, s, i) {
      var r = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), u = 80 * c, h = 48 * c, f = 3 * c, p = 2 * c, y = 3 * c, g = 15 * c, v = 74 * c, d = 30 * c, w = document.createElement("canvas");
      w.width = u, w.height = h, w.style.cssText = "width:80px;height:48px";
      var x = w.getContext("2d");
      return x.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", x.textBaseline = "top", x.fillStyle = i, x.fillRect(0, 0, u, h), x.fillStyle = s, x.fillText(n, f, p), x.fillRect(y, g, v, d), x.fillStyle = i, x.globalAlpha = 0.9, x.fillRect(y, g, v, d), { dom: w, update: function(T, P) {
        r = Math.min(r, T), a = Math.max(a, T), x.fillStyle = i, x.globalAlpha = 1, x.fillRect(0, 0, u, g), x.fillStyle = s, x.fillText(l(T) + " " + n + " (" + l(r) + "-" + l(a) + ")", f, p), x.drawImage(w, y + c, g, v - c, d, y, g, v - c, d), x.fillRect(y + v - c, g, c, d), x.fillStyle = i, x.globalAlpha = 0.9, x.fillRect(y + v - c, g, c, l((1 - T / P) * d));
      } };
    }, t;
  });
})(fl);
var bm = fl.exports;
const Em = /* @__PURE__ */ Is(bm), o0 = me({
  name: "Stats",
  props: {
    showPanel: {
      type: Number,
      default: 0
    }
  },
  setup(o, { expose: e }) {
    const t = new Em();
    e({ stats: t });
    const n = document.body;
    t.showPanel(o.showPanel || 0), n == null || n.appendChild(t.dom);
    const { onBeforeLoop: s, onAfterLoop: i, resume: r } = qe();
    r(), s(() => t.begin()), i(() => t.end()), ct(() => {
      n == null || n.removeChild(t.dom);
    });
  }
});
class Sm {
  constructor(e, t, n) {
    this.name = e, this.fg = t, this.bg = n, this.PR = Math.round(window.devicePixelRatio || 1), this.WIDTH = 90 * this.PR, this.HEIGHT = 48 * this.PR, this.TEXT_X = 3 * this.PR, this.TEXT_Y = 2 * this.PR, this.GRAPH_X = 3 * this.PR, this.GRAPH_Y = 15 * this.PR, this.GRAPH_WIDTH = 84 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR, this.canvas = document.createElement("canvas"), this.canvas.width = 90 * this.PR, this.canvas.height = 48 * this.PR, this.canvas.style.width = "90px", this.canvas.style.position = "absolute", this.canvas.style.height = "48px", this.canvas.style.cssText = "width:90px;height:48px", this.context = this.canvas.getContext("2d"), this.context && (this.context.font = "bold " + 9 * this.PR + "px Helvetica,Arial,sans-serif", this.context.textBaseline = "top", this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT), this.context.fillStyle = this.fg, this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y), this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT));
  }
  update(e, t, n, s, i = 0) {
    let r = 1 / 0, a = 0;
    this.context && (r = Math.min(r, e), a = Math.max(n, e), s = Math.max(s, t), this.context.fillStyle = this.bg, this.context.globalAlpha = 1, this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y), this.context.fillStyle = this.fg, this.context.fillText(e.toFixed(i) + " " + this.name + " (" + r.toFixed(i) + "-" + parseFloat(a.toFixed(i)) + ")", this.TEXT_X, this.TEXT_Y), this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT), this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, (1 - t / s) * this.GRAPH_HEIGHT));
  }
}
const dl = class qn {
  constructor({ logsPerSecond: e = 20, samplesLog: t = 100, samplesGraph: n = 10, precision: s = 2, minimal: i = !1, horizontal: r = !0, mode: a = 0 } = {}) {
    this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalGpuDurationCompute = 0, this.totalFps = 0, this.activeQuery = null, this.gpuQueries = [], this.renderCount = 0, this.mode = a, this.horizontal = r, this.dom = document.createElement("div"), this.dom.style.cssText = "position:fixed;top:0;left:0;opacity:0.9;z-index:10000;", i && (this.dom.style.cssText += "cursor:pointer"), this.gl = null, this.query = null, this.isRunningCPUProfiling = !1, this.minimal = i, this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.frames = 0, this.renderCount = 0, this.threeRendererPatched = !1, this.averageCpu = {
      logs: [],
      graph: []
    }, this.averageGpu = {
      logs: [],
      graph: []
    }, this.averageGpuCompute = {
      logs: [],
      graph: []
    }, this.queryCreated = !1, this.fpsPanel = this.addPanel(new qn.Panel("FPS", "#0ff", "#002"), 0), this.msPanel = this.addPanel(new qn.Panel("CPU", "#0f0", "#020"), 1), this.gpuPanel = null, this.gpuPanelCompute = null, this.samplesLog = t, this.samplesGraph = n, this.precision = s, this.logsPerSecond = e, this.minimal ? (this.dom.addEventListener("click", (l) => {
      l.preventDefault(), this.showPanel(++this.mode % this.dom.children.length);
    }, !1), this.mode = a, this.showPanel(this.mode)) : window.addEventListener("resize", () => {
      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2), this.gpuPanelCompute && this.resizePanel(this.gpuPanelCompute, 3);
    });
  }
  patchThreeRenderer(e) {
    const t = e.render, n = this;
    e.render = function(s, i) {
      n.begin(), t.call(this, s, i), n.end();
    }, this.threeRendererPatched = !0;
  }
  resizePanel(e, t) {
    e.canvas.style.position = "absolute", this.minimal ? e.canvas.style.display = "none" : (e.canvas.style.display = "block", this.horizontal ? (e.canvas.style.top = "0px", e.canvas.style.left = t * e.WIDTH / e.PR + "px") : (e.canvas.style.left = "0px", e.canvas.style.top = t * e.HEIGHT / e.PR + "px"));
  }
  addPanel(e, t) {
    return e.canvas && (this.dom.appendChild(e.canvas), this.resizePanel(e, t)), e;
  }
  showPanel(e) {
    for (let t = 0; t < this.dom.children.length; t++) {
      const n = this.dom.children[t];
      n.style.display = t === e ? "block" : "none";
    }
    this.mode = e;
  }
  async init(e) {
    if (!e) {
      console.error('Stats: The "canvas" parameter is undefined.');
      return;
    }
    if (e.isWebGLRenderer && !this.threeRendererPatched) {
      const t = e;
      this.patchThreeRenderer(t), this.gl = t.getContext();
    } else
      !this.gl && e instanceof WebGL2RenderingContext && (this.gl = e);
    if (e.isWebGPURenderer) {
      e.backend.trackTimestamp = !0, await e.hasFeatureAsync("timestamp-query") && (this.gpuPanel = this.addPanel(new qn.Panel("GPU", "#ff0", "#220"), 2), this.gpuPanelCompute = this.addPanel(new qn.Panel("CPT", "#e1e1e1", "#212121"), 3), this.info = e.info);
      return;
    } else if (!this.gl && e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {
      if (this.gl = e.getContext("webgl2"), !this.gl) {
        console.error("Stats: Unable to obtain WebGL2 context.");
        return;
      }
    } else if (!this.gl) {
      console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.");
      return;
    }
    this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2"), this.ext && (this.gpuPanel = this.addPanel(new qn.Panel("GPU", "#ff0", "#220"), 2));
  }
  begin() {
    this.isRunningCPUProfiling || this.beginProfiling("cpu-started"), !(!this.gl || !this.ext) && this.gl && this.ext && (this.activeQuery && this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.activeQuery = this.gl.createQuery(), this.activeQuery !== null && this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery));
  }
  end() {
    this.renderCount++, this.gl && this.ext && this.activeQuery && (this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.gpuQueries.push({ query: this.activeQuery }), this.activeQuery = null);
  }
  processGpuQueries() {
    !this.gl || !this.ext || (this.totalGpuDuration = 0, this.gpuQueries.forEach((e, t) => {
      if (this.gl) {
        const n = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT_AVAILABLE), s = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        if (n && !s) {
          const r = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT) * 1e-6;
          this.totalGpuDuration += r, this.gl.deleteQuery(e.query), this.gpuQueries.splice(t, 1);
        }
      }
    }));
  }
  update() {
    this.info === void 0 ? this.processGpuQueries() : (this.totalGpuDuration = this.info.render.timestamp, this.totalGpuDurationCompute = this.info.compute.timestamp, this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute)), this.endProfiling("cpu-started", "cpu-finished", "cpu-duration"), this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu), this.renderCount = 0, this.totalCpuDuration === 0 && this.beginProfiling("cpu-started"), this.totalCpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();
  }
  endInternal() {
    this.frames++;
    const e = (performance || Date).now();
    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond && (this.updatePanel(this.msPanel, this.averageCpu), this.updatePanel(this.gpuPanel, this.averageGpu), this.gpuPanelCompute && this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute), this.prevCpuTime = e), e >= this.prevTime + 1e3) {
      const t = this.frames * 1e3 / (e - this.prevTime);
      this.fpsPanel.update(t, t, 100, 100, 0), this.prevTime = e, this.frames = 0;
    }
    return e;
  }
  addToAverage(e, t) {
    t.logs.push(e), t.logs.length > this.samplesLog && t.logs.shift(), t.graph.push(e), t.graph.length > this.samplesGraph && t.graph.shift();
  }
  beginProfiling(e) {
    window.performance && (window.performance.mark(e), this.isRunningCPUProfiling = !0);
  }
  endProfiling(e, t, n) {
    if (window.performance && t && this.isRunningCPUProfiling) {
      window.performance.mark(t);
      const s = performance.measure(n, e, t);
      this.totalCpuDuration += s.duration, this.isRunningCPUProfiling = !1;
    }
  }
  updatePanel(e, t) {
    if (t.logs.length > 0) {
      let n = 0, s = 0.01;
      for (let a = 0; a < t.logs.length; a++)
        n += t.logs[a], t.logs[a] > s && (s = t.logs[a]);
      let i = 0, r = 0.01;
      for (let a = 0; a < t.graph.length; a++)
        i += t.graph[a], t.graph[a] > r && (r = t.graph[a]);
      e && e.update(n / Math.min(t.logs.length, this.samplesLog), i / Math.min(t.graph.length, this.samplesGraph), s, r, this.precision);
    }
  }
  get domElement() {
    return this.dom;
  }
  get container() {
    return console.warn("Stats: Deprecated! this.container as been replaced to this.dom "), this.dom;
  }
};
dl.Panel = Sm;
let Mm = dl;
const a0 = me({
  name: "StatsGl",
  props: [
    "logsPerSecond",
    "samplesLog",
    "samplesGraph",
    "precision",
    "horizontal",
    "minimal",
    "mode"
  ],
  async setup(o, { expose: e }) {
    const t = new Mm({
      logsPerSecond: o.logsPerSecond,
      samplesLog: o.samplesLog,
      samplesGraph: o.samplesGraph,
      precision: o.precision,
      horizontal: o.horizontal,
      minimal: o.minimal,
      mode: o.mode
    });
    e({ statsGl: t });
    const n = document.body, s = t.dom || t.container;
    n == null || n.appendChild(s);
    const { renderer: i } = ke(), { onAfterLoop: r, resume: a } = qe();
    t.init(i.value), a(), r(() => {
      t.update();
    }), ct(() => {
      n == null || n.removeChild(s);
    });
  }
}), l0 = me({
  name: "BakeShadows",
  setup() {
    const { renderer: o } = ke();
    ut(() => {
      o.value.shadowMap.autoUpdate = !1, o.value.shadowMap.needsUpdate = !0;
    });
  }
});
var Am = `#include <common>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;

  
  
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
}`, Pm = `void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}`;
const Rs = new Z(0, 0, 0), Nr = new Z(0, 0, 0), Cm = new Z(0, 0, 0);
function qo(o, e, t) {
  const n = Rs.setFromMatrixPosition(o.matrixWorld);
  n.project(e);
  const s = t.width / 2, i = t.height / 2;
  return [
    (Number.isNaN(n.x) ? 0 : n.x) * s + s,
    -(n.y * i) + i
  ];
}
function Im(o, e) {
  const t = Rs.setFromMatrixPosition(o.matrixWorld), n = Nr.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(Cm);
  return s.angleTo(i) > Math.PI / 2;
}
function Rm(o, e, t, n) {
  const s = Rs.setFromMatrixPosition(o.matrixWorld), i = s.clone();
  i.project(e), t.setFromCamera(new ge(i.x, i.y), e);
  const r = t.intersectObjects(n, !0);
  if (r.length > 0) {
    const a = r[0].distance;
    return s.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function Dm(o, e) {
  if (e instanceof qt)
    return e.zoom;
  if (e instanceof St) {
    const t = Rs.setFromMatrixPosition(o.matrixWorld), n = Nr.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);
    return 1 / (2 * Math.tan(s / 2) * i);
  } else
    return 1;
}
function Om(o, e, t) {
  if (e instanceof St || e instanceof qt) {
    const n = Rs.setFromMatrixPosition(o.matrixWorld), s = Nr.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), r = (t[1] - t[0]) / (e.far - e.near), a = t[1] - r * e.far;
    return Math.round(r * i + a);
  }
}
const gr = (o) => Math.abs(o) < 1e-10 ? 0 : o;
function pl(o, e, t = "") {
  let n = "matrix3d(";
  for (let s = 0; s !== 16; s++)
    n += gr(e[s] * o.elements[s]) + (s !== 15 ? "," : ")");
  return t + n;
}
const Lm = /* @__PURE__ */ ((o) => (e) => pl(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), Fm = /* @__PURE__ */ ((o) => (e, t) => pl(e, o(t), "translate(-50%,-50%)"))((o) => [1 / o, 1 / o, 1 / o, 1, -1 / o, -1 / o, -1 / o, -1, 1 / o, 1 / o, 1 / o, 1, 1, 1, 1, 1]), km = ["geometry", "material"], c0 = /* @__PURE__ */ me({
  __name: "HTML",
  props: {
    geometry: { default: new Ut() },
    material: {},
    as: { default: "div" },
    transform: { type: Boolean, default: !1 },
    portal: {},
    wrapperClass: {},
    eps: { default: 1e-4 },
    distanceFactor: {},
    fullscreen: { type: Boolean },
    center: { type: Boolean },
    pointerEvents: { default: "auto" },
    sprite: { type: Boolean, default: !1 },
    zIndexRange: { default: () => [16777271, 0] },
    occlude: { type: [Array, Boolean, String] }
  },
  emits: ["onOcclude"],
  setup(o, { emit: e }) {
    const t = o, n = e, s = br(), i = Ma(), r = he(), a = he(), {
      geometry: l,
      material: c,
      as: u,
      transform: h,
      portal: f,
      wrapperClass: p,
      eps: y,
      distanceFactor: g,
      fullscreen: v,
      center: d,
      pointerEvents: w,
      sprite: x,
      occlude: T,
      zIndexRange: P
    } = Oe(t), { renderer: S, scene: M, camera: m, raycaster: b, sizes: _ } = ke(), I = Fe(() => document.createElement(u.value)), R = he([0, 0]), z = he(0), k = he(), G = Fe(() => h.value ? {
      position: "absolute",
      top: 0,
      left: 0,
      width: `${_.width.value}px`,
      height: `${_.height.value}px`,
      transformStyle: "preserve-3d",
      pointerEvents: "none",
      zIndex: 2,
      willChange: "transform"
    } : {
      position: "absolute",
      transform: d.value ? "translate3d(-50%,-50%,0)" : "none",
      ...v.value && {
        top: -_.height.value / 2,
        left: -_.width.value / 2,
        width: `${_.width.value}px`,
        height: `${_.height.value}px`
      },
      zIndex: 2,
      ...i.style,
      willChange: "transform"
    }), U = Fe(() => ({
      position: "absolute",
      pointerEvents: w.value
    })), q = he(null), $ = he(!1), te = Fe(
      () => (T == null ? void 0 : T.value) && (T == null ? void 0 : T.value) !== "blending" || Array.isArray(T == null ? void 0 : T.value) && (T == null ? void 0 : T.value.length) && oi(T.value[0])
    );
    ve(
      () => T,
      (C) => {
        C && C === "blending" ? (I.value.style.zIndex = `${Math.floor(P.value[0] / 2)}`, I.value.style.position = "absolute", I.value.style.pointerEvents = "none") : (I.value.style.zIndex = null, I.value.style.position = null, I.value.style.pointerEvents = null);
      }
    ), ve(
      () => {
        var C;
        return [r.value, S.value, _.width.value, _.height.value, (C = s.default) == null ? void 0 : C.call(s)];
      },
      ([C, B]) => {
        var L, O, N, E, A, D;
        if (C && B) {
          const W = (f == null ? void 0 : f.value) || B.domElement;
          if ((L = M.value) == null || L.updateMatrixWorld(), h.value)
            I.value.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const Y = qo(C, m.value, {
              width: _.width.value,
              height: _.height.value
            });
            I.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Y[0]}px,${Y[1]}px,0);transform-origin:0 0;`;
          }
          W && !I.value.parentNode && ((O = W.parentNode) == null || O.appendChild(I.value)), h.value ? k.value = Ns("div", { id: "outer", style: G.value }, [
            Ns("div", { id: "inner", style: U.value }, [
              Ns("div", {
                key: (N = a.value) == null ? void 0 : N.uuid,
                id: M == null ? void 0 : M.value.uuid,
                class: i.class,
                style: i.style
              }, (E = s.default) == null ? void 0 : E.call(s))
            ])
          ]) : k.value = Ns("div", {
            key: (A = a.value) == null ? void 0 : A.uuid,
            id: M == null ? void 0 : M.value.uuid,
            style: G.value
          }, (D = s.default) == null ? void 0 : D.call(s)), vc(k.value, I.value);
        }
      }
    ), ut(() => {
      p != null && p.value && (I.value.className = p.value);
    });
    const ee = he(!0), { onLoop: oe } = qe();
    oe(() => {
      var C, B, L, O, N, E, A;
      if (r.value && m.value && S.value) {
        (C = m.value) == null || C.updateMatrixWorld(), r.value.updateWorldMatrix(!0, !1);
        const D = h.value ? R.value : qo(r.value, m.value, {
          width: _.width.value || 0,
          height: _.height.value || 0
        });
        if (h.value || Math.abs(z.value - m.value.zoom) > y.value || Math.abs(R.value[0] - D[0]) > y.value || Math.abs(R.value[1] - D[1]) > y.value) {
          const W = Im(r.value, m.value);
          let Y = !1;
          te.value && (Array.isArray(T == null ? void 0 : T.value) ? Y = T == null ? void 0 : T.value : (T == null ? void 0 : T.value) !== "blending" && (Y = [M.value]));
          const j = ee.value;
          if (Y) {
            const se = Rm(
              r.value,
              m.value,
              b.value,
              Y
            );
            ee.value = se && !W;
          } else
            ee.value = !W;
          j !== ee.value && (n("onOcclude", !ee.value), I.value.style.display = ee.value ? "block" : "none");
          const J = Math.floor(P.value[0] / 2), ne = T != null && T.value ? te.value ? [P.value[0], J] : [J - 1, 0] : P.value;
          if (I.value.style.zIndex = `${Om(r.value, m.value, ne)}`, I.value.style.willChange = "transform", h.value) {
            const [se, V] = [
              _.width.value / 2,
              _.height.value / 2
            ], F = m.value.projectionMatrix.elements[5] * V, { isOrthographicCamera: re, top: fe, left: Me, bottom: Xe, right: je } = m.value, _t = Lm(m.value.matrixWorldInverse), nn = re ? `scale(${F})translate(${gr(-(je + Me) / 2)}px,${gr((fe + Xe) / 2)}px)` : `translateZ(${F}px)`;
            let gt = r.value.matrixWorld;
            x.value && (gt = m.value.matrixWorldInverse.clone().transpose().copyPosition(gt).scale(r.value.scale), gt.elements[3] = gt.elements[7] = gt.elements[11] = 0, gt.elements[15] = 1), I.value.style.width = `${_.width.value}px`, I.value.style.height = `${_.height.value}px`, I.value.style.perspective = re ? "" : `${F}px`, (B = k.value) != null && B.el && ((L = k.value) != null && L.children) && (k.value.el.style.willChange = "transform", k.value.el.style.transform = `${nn}${_t}translate(${se}px,${V}px)`, k.value.children[0].willChange = "transform", k.value.children[0].el.style.transform = Fm(
              gt,
              1 / (((g == null ? void 0 : g.value) || 10) / 400)
            ));
          } else {
            const se = (g == null ? void 0 : g.value) === void 0 ? 1 : Dm(r.value, m.value) * (g == null ? void 0 : g.value);
            I.value.style.transform = `translate3d(${D[0]}px,${D[1]}px,0) scale(${se})`;
          }
        }
        R.value = D, z.value = m.value.zoom;
      }
      if (!te.value && a.value && !$.value)
        if (h.value) {
          if ((O = k.value) != null && O.el && ((N = k.value) != null && N.children)) {
            const D = (E = k.value) == null ? void 0 : E.children[0];
            if (D != null && D.clientWidth && (D != null && D.clientHeight)) {
              const { isOrthographicCamera: W } = m.value;
              if (W || l)
                i.scale && (Array.isArray(i.scale) ? i.scale instanceof Z ? a.value.scale.copy(i.scale.clone().divideScalar(1)) : a.value.scale.set(1 / i.scale[0], 1 / i.scale[1], 1 / i.scale[2]) : a.value.scale.setScalar(1 / i.scale));
              else {
                const Y = ((g == null ? void 0 : g.value) || 10) / 400, j = D.clientWidth * Y, J = D.clientHeight * Y;
                a.value.scale.set(j, J, 1);
              }
              $.value = !0;
            }
          }
        } else {
          const D = I.value.children[0];
          if (D != null && D.clientWidth && (D != null && D.clientHeight)) {
            const Y = D.clientWidth * 1, j = D.clientHeight * 1;
            a.value.scale.set(Y, j, 1), $.value = !0;
          }
          q.value.lookAt((A = m.value) == null ? void 0 : A.position);
        }
    });
    const de = Fe(() => ({
      vertexShader: h.value ? void 0 : Am,
      fragmentShader: Pm
    })), xe = Fe(() => {
      const C = de.value;
      return c.value || new Dt({
        vertexShader: C.vertexShader,
        fragmentShader: C.fragmentShader,
        side: wn
      });
    });
    return ct(() => {
      xe.value && xe.value.dispose(), I.value.remove();
    }), (C, B) => (ce(), ue("TresGroup", {
      ref_key: "groupRef",
      ref: r
    }, [
      H(T) && !te.value ? (ce(), ue("TresMesh", {
        key: 0,
        ref_key: "meshRef",
        ref: a,
        geometry: H(l),
        material: xe.value
      }, null, 8, km)) : jt("", !0)
    ], 512));
  }
}), { logError: Bm } = As();
async function u0(o, e) {
  const t = new Mr(), n = (e == null ? void 0 : e.fileName) || "scene";
  t.parse(
    o,
    (s) => {
      if (s instanceof ArrayBuffer)
        Nm(s, `${n}.glb`);
      else {
        const i = JSON.stringify(s, null, 2);
        Um(i, `${n}.gltf`);
      }
    },
    (s) => {
      Bm("An error happened while exporting the GLTF", s);
    },
    e
  );
}
function Um(o, e) {
  ml(new Blob([o], { type: "text/plain" }), e);
}
function Nm(o, e) {
  ml(new Blob([o], { type: "application/octet-stream" }), e);
}
function ml(o, e) {
  const t = document.createElement("a");
  t.style.display = "none", document.body.appendChild(t), t.href = URL.createObjectURL(o), t.download = e, t.click(), t.remove();
}
const h0 = {
  mounted: (o, e) => {
    if (e.arg) {
      console.log(`v-log:${e.arg}`, o[e.arg]);
      return;
    }
    console.log("v-log", o);
  }
}, { logWarning: Ko } = As();
let ni, Zn;
const zm = {
  DirectionalLight: rc,
  PointLight: oc,
  SpotLight: ac,
  HemisphereLight: lc,
  RectAreaLight: Va
}, f0 = {
  mounted: (o) => {
    var e;
    if (!o.isLight) {
      Ko(`${o.type} is not a light`);
      return;
    }
    ni = zm[o.type], (e = o == null ? void 0 : o.parent) == null || e.add(new ni(o, o.intensity));
  },
  updated: (o) => {
    Zn = o.parent.children.find((e) => e instanceof ni), !(Zn instanceof Va) && Zn.update();
  },
  unmounted: (o) => {
    if (!o.isLight) {
      Ko(`${o.type} is not a light`);
      return;
    }
    Zn = o.parent.children.find((e) => e instanceof ni), Zn.dispose(), o.parent.remove(Zn);
  }
};
function d0(o, e) {
  const t = {};
  for (const n of e)
    Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);
  return t;
}
function p0(o, e) {
  const t = `set${e[0].toUpperCase()}${e.slice(1)}`;
  return o[t] !== void 0;
}
function gl(o) {
  var t, n;
  let e = o.value;
  return o.value && ((n = (t = o.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = o.value.value.position), Array.isArray(o.value) && (e = new Z(...e)), e;
}
const { logWarning: Hm } = As(), m0 = {
  updated: (o, e) => {
    const t = gl(e);
    if (!t) {
      Hm(`v-always-look-at: problem with binding value: ${e.value}`);
      return;
    }
    const { onLoop: n } = qe();
    n(() => {
      o.lookAt(t);
    });
  }
}, { logWarning: jm } = As();
let Xt = null;
const g0 = {
  updated: (o, e) => {
    var s;
    const t = gl(e);
    if (!t) {
      jm(`v-distance-to: problem with binding value: ${e.value}`);
      return;
    }
    Xt && (Xt.dispose(), o.parent.remove(Xt));
    const n = t.clone().sub(o.position);
    n.normalize(), Xt = new cc(n, o.position, o.position.distanceTo(t) / 1.5, 16776960), o.parent.add(Xt), console.table(
      [
        ["Distance:", o.position.distanceTo(t)],
        [`origin: ${o.name || o.type}`, `x:${o.position.x}, y:${o.position.y}, z:${(s = o.position) == null ? void 0 : s.z}`],
        [`Destiny: ${o.name || o.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (o) => {
    Xt == null || Xt.dispose(), o.parent.remove(Xt);
  }
};
export {
  qg as Backdrop,
  l0 as BakeShadows,
  ot as BaseCameraControls,
  Dg as Box,
  Mg as CameraControls,
  Og as CatmullRomCurve3,
  Lg as Circle,
  Fg as Cone,
  Kg as ContactShadows,
  Cg as CustomShaderMaterial,
  kg as Dodecahedron,
  $g as Environment,
  gg as FBXModel,
  fg as Fbo,
  Qg as Fit,
  mg as GLTFModel,
  ug as GlobalAudio,
  Rg as HolographicMaterial,
  c0 as Html,
  Bg as Icosahedron,
  wg as KeyboardControls,
  hg as Lensflare,
  ag as Levioso,
  Zg as Lightformer,
  op as Line2,
  Eg as MapControls,
  Pg as MeshGlassMaterial,
  Ig as MeshReflectionMaterial,
  Ag as MeshWobbleMaterial,
  cg as MouseParallax,
  i0 as Ocean,
  Ug as Octahedron,
  xg as OrbitControls,
  Ng as Plane,
  bg as PointerLockControls,
  pg as PositionalAudio,
  Jg as Precipitation,
  lg as Reflector,
  zg as Ring,
  Hg as RoundedBox,
  vg as SVG,
  dg as Sampler,
  Sg as ScrollControls,
  e0 as Sky,
  t0 as Smoke,
  n0 as Sparkles,
  jg as Sphere,
  s0 as Stars,
  o0 as Stats,
  a0 as StatsGl,
  Gg as Superformula,
  Vg as Tetrahedron,
  rg as Text3D,
  Yg as Torus,
  Wg as TorusKnot,
  Tg as TransformControls,
  Xg as Tube,
  gl as extractBindingPosition,
  p0 as hasSetter,
  d0 as pick,
  og as useAnimations,
  _f as useEnvironment,
  pf as useFBO,
  bf as useFBX,
  wf as useGLTF,
  u0 as useGLTFExporter,
  yg as useProgress,
  mf as useSurfaceSampler,
  r0 as useTweakPane,
  _g as useVideoTexture,
  m0 as vAlwaysLookAt,
  g0 as vDistanceTo,
  f0 as vLightHelper,
  h0 as vLog
};
