/**
 * name: @tresjs/core
 * version: v3.9.0
 * (c) 2024
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var Oe = Object.defineProperty;
var De = (e, r, t) => r in e ? Oe(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t;
var Q = (e, r, t) => (De(e, typeof r != "symbol" ? r + "" : r, t), t);
import { ref as A, computed as L, watchEffect as B, onUnmounted as U, shallowRef as H, watch as ge, reactive as ve, readonly as Y, provide as K, inject as Be, createRenderer as je, defineComponent as ne, useSlots as He, getCurrentInstance as se, onMounted as Re, openBlock as Ie, createElementBlock as $e, normalizeClass as ze, unref as Ne, normalizeStyle as We, h as ie, Fragment as Ve } from "vue";
import * as he from "three";
import { PerspectiveCamera as X, OrthographicCamera as Fe, Camera as Ue, Clock as Ge, Vector3 as te, Color as W, MeshBasicMaterial as ye, DoubleSide as Qe, REVISION as qe, SRGBColorSpace as Je, ACESFilmicToneMapping as Ye, PCFSoftShadowMap as Ke, WebGLRenderer as q, TextureLoader as Xe, Vector2 as Ze, Raycaster as et, BufferAttribute as tt, Scene as rt, Line as ot, BufferGeometry as ae, Float32BufferAttribute as le, LineBasicMaterial as nt, Mesh as st, BackSide as it, DirectionalLightHelper as at, PointLightHelper as lt, SpotLightHelper as ut, HemisphereLightHelper as ct, ArrowHelper as dt, Quaternion as ft } from "three";
import { createEventHook as R, useRafFn as we, toValue as E, unrefElement as pt, useDevicePixelRatio as mt, usePointer as gt, useElementBounding as vt, useWindowSize as ht, useElementSize as yt, refDebounced as ue, useFps as wt, useMemory as _t } from "@vueuse/core";
const bt = "@tresjs/core", Et = "module", Ct = "3.9.0", xt = "pnpm@8.15.6", Mt = "Declarative ThreeJS using Vue Components", St = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", kt = "MIT", Pt = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
], Tt = !1, At = {
  ".": {
    types: "./dist/index.d.ts",
    import: "./dist/tres.js",
    require: "./dist/tres.umd.cjs"
  },
  "./components": {
    types: "./dist/src/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/src/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/src/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/src/utils/index.d.ts"
  },
  "./*": "./*"
}, Lt = "./dist/tres.js", Ot = "./dist/tres.js", Dt = "./dist/index.d.ts", Bt = [
  "*.d.ts",
  "dist"
], jt = {
  access: "public"
}, Ht = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint .",
  "lint:fix": "eslint . --fix",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts",
  prepare: "node .husky/install.mjs"
}, Rt = {
  three: ">=0.133",
  vue: ">=3.3"
}, It = {
  "@alvarosabu/utils": "^3.1.1",
  "@vue/devtools-api": "^6.6.1",
  "@vueuse/core": "^10.7.0"
}, $t = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.9.0",
  "@tresjs/cientos": "3.8.0",
  "@tresjs/eslint-config": "^1.0.0",
  "@tresjs/eslint-config-vue": "^0.2.1",
  "@types/three": "^0.163.0",
  "@typescript-eslint/eslint-plugin": "^7.7.1",
  "@typescript-eslint/parser": "^7.7.1",
  "@vitejs/plugin-vue": "^5.0.4",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^1.5.0",
  "@vue/test-utils": "^2.4.3",
  eslint: "^9.1.1",
  "eslint-plugin-vue": "^9.25.0",
  esno: "^4.0.0",
  gsap: "^3.12.3",
  husky: "^9.0.11",
  jsdom: "^24.0.0",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.1",
  "release-it": "^17.2.0",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.11.0",
  three: "^0.163.0",
  unocss: "^0.59.4",
  unplugin: "^1.10.1",
  "unplugin-vue-components": "^0.26.0",
  vite: "^5.2.10",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.9.0",
  "vite-plugin-inspect": "^0.8.4",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.1.3",
  vitest: "^1.5.0",
  vue: "^3.4.24",
  "vue-demi": "^0.14.6"
}, zt = {
  name: bt,
  type: Et,
  version: Ct,
  packageManager: xt,
  description: Mt,
  author: St,
  license: kt,
  keywords: Pt,
  sideEffects: Tt,
  exports: At,
  main: Lt,
  module: Ot,
  types: Dt,
  files: Bt,
  publishConfig: jt,
  scripts: Ht,
  peerDependencies: Rt,
  dependencies: It,
  devDependencies: $t
}, Nt = ({ sizes: e, scene: r }) => {
  const t = A([]), o = L(
    () => t.value[0]
  ), s = (a) => {
    const l = a instanceof Ue ? a : t.value.find((m) => m.uuid === a);
    if (!l)
      return;
    const c = t.value.filter(({ uuid: m }) => m !== l.uuid);
    t.value = [l, ...c];
  }, i = (a, l = !1) => {
    t.value.some(({ uuid: c }) => c === a.uuid) || (l ? s(a) : t.value.push(a));
  }, n = (a) => {
    t.value = t.value.filter(({ uuid: l }) => l !== a.uuid);
  };
  return B(() => {
    e.aspectRatio.value && t.value.forEach((a) => {
      a instanceof X && (a.aspect = e.aspectRatio.value), (a instanceof X || a instanceof Fe) && a.updateProjectionMatrix();
    });
  }), r.userData.tres__registerCamera = i, r.userData.tres__deregisterCamera = n, U(() => {
    t.value = [];
  }), {
    camera: o,
    cameras: t,
    registerCamera: i,
    deregisterCamera: n,
    setCameraActive: s
  };
}, _e = R(), be = R(), re = R(), j = new Ge();
let V = 0, F = 0;
const { pause: Wt, resume: Vt, isActive: Ft } = we(
  () => {
    _e.trigger({ delta: V, elapsed: F, clock: j }), be.trigger({ delta: V, elapsed: F, clock: j }), re.trigger({ delta: V, elapsed: F, clock: j });
  },
  { immediate: !1 }
);
re.on(() => {
  V = j.getDelta(), F = j.getElapsedTime();
});
const G = () => ({
  onBeforeLoop: _e.on,
  onLoop: be.on,
  onAfterLoop: re.on,
  pause: Wt,
  resume: Vt,
  isActive: Ft
}), Ir = !0, I = "[TresJS ▲ ■ ●] ";
function P() {
  function e(...o) {
    typeof o[0] == "string" ? o[0] = I + o[0] : o.unshift(I), console.error(...o);
  }
  function r(...o) {
    typeof o[0] == "string" ? o[0] = I + o[0] : o.unshift(I), console.warn(...o);
  }
  function t(o, s) {
  }
  return {
    logError: e,
    logWarning: r,
    logMessage: t
  };
}
function $r(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof te ? [e.x, e.y, e.z] : e;
}
function Ut(e) {
  return e instanceof W ? e : Array.isArray(e) ? new W(...e) : new W(e);
}
class Gt extends he.Mesh {
  constructor(...t) {
    super(...t);
    Q(this, "type", "HightlightMesh");
    Q(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const o = (Date.now() - this.createTime) / 1e3, n = 1 + 0.07 * Math.sin(2.5 * o);
    this.scale.set(n, n, n);
  }
}
const Ee = (e, r) => {
  for (const t of Object.keys(r))
    r[t] instanceof Object && Object.assign(r[t], Ee(e[t], r[t]));
  return Object.assign(e || {}, r), e;
}, Qt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", qt = /* @__PURE__ */ Jt(Qt);
function ce(e) {
  return e && e.nodeType === 1;
}
function $(e) {
  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
}
function Jt(e, r) {
  const t = /* @__PURE__ */ Object.create(null), o = e.split(",");
  for (let s = 0; s < o.length; s++)
    t[o[s]] = !0;
  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
}
const Yt = (e, r) => {
  const t = /* @__PURE__ */ new Set(), o = [];
  for (const s of e) {
    const i = r(s);
    t.has(i) || (t.add(i), o.push(s));
  }
  return o;
}, de = (e, r) => {
  if (!r)
    return;
  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((o, s) => o && o[s], e);
}, Kt = (e, r, t) => {
  const o = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  o && o.reduce((s, i, n) => (s[i] === void 0 && (s[i] = {}), n === o.length - 1 && (s[i] = t), s[i]), e);
};
function Ce(e, r) {
  if (ce(e) && ce(r)) {
    const s = e.attributes, i = r.attributes;
    return s.length !== i.length ? !1 : Array.from(s).every(({ name: n, value: a }) => r.getAttribute(n) === a);
  }
  if (e === r)
    return !0;
  if (e === null || typeof e != "object" || r === null || typeof r != "object")
    return !1;
  const t = Object.keys(e), o = Object.keys(r);
  if (t.length !== o.length)
    return !1;
  for (const s of t)
    if (!o.includes(s) || !Ce(e[s], r[s]))
      return !1;
  return !0;
}
function Xt(e, r) {
  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (!Ce(e[t], r[t]))
      return !1;
  return !0;
}
const Zt = Array.isArray;
function er(e, r, t, o) {
  const s = (l) => {
    if (l.uuid === r)
      return l;
    for (const c of l.children) {
      const m = s(c);
      if (m)
        return m;
    }
  }, i = s(e);
  if (!i) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let n = i;
  for (let l = 0; l < t.length - 1; l++)
    if (n[t[l]] !== void 0)
      n = n[t[l]];
    else {
      console.warn(`Property path is not valid: ${t.join(".")}`);
      return;
    }
  const a = t[t.length - 1];
  n[a] !== void 0 ? n[a] = o : console.warn(`Property path is not valid: ${t.join(".")}`);
}
function tr(e) {
  const r = new ye({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: !0,
    opacity: 0.2,
    depthTest: !1,
    // So the highlight is always visible
    side: Qe
    // To e
  });
  return new Gt(e.geometry.clone(), r);
}
function xe(e) {
  var t;
  let r = e.value;
  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new te(...r)), r;
}
const rr = Number.parseInt(qe.replace("dev", "")), z = {
  realistic: {
    shadows: !0,
    physicallyCorrectLights: !0,
    outputColorSpace: Je,
    toneMapping: Ye,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: Ke
    }
  }
};
function or({
  scene: e,
  canvas: r,
  options: t,
  disableRender: o,
  contextParts: { sizes: s, camera: i }
}) {
  const n = L(() => ({
    alpha: E(t.alpha),
    depth: E(t.depth),
    canvas: pt(r),
    context: E(t.context),
    stencil: E(t.stencil),
    antialias: E(t.antialias) === void 0 ? !0 : E(t.antialias),
    precision: E(t.precision),
    powerPreference: E(t.powerPreference),
    premultipliedAlpha: E(t.premultipliedAlpha),
    preserveDrawingBuffer: E(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: E(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: E(t.failIfMajorPerformanceCaveat)
  })), a = H(new q(n.value));
  ge(n, () => {
    a.value.dispose(), a.value = new q(n.value);
  }), B(() => {
    a.value.setSize(s.width.value, s.height.value);
  });
  const { pixelRatio: l } = mt();
  B(() => {
    a.value.setPixelRatio(l.value);
  });
  const { logError: c } = P(), d = (() => {
    const p = new q(), y = {
      shadowMap: {
        enabled: p.shadowMap.enabled,
        type: p.shadowMap.type
      },
      toneMapping: p.toneMapping,
      toneMappingExposure: p.toneMappingExposure,
      outputColorSpace: p.outputColorSpace
    };
    return p.dispose(), y;
  })();
  B(() => {
    const p = E(t.preset);
    p && (p in z || c(`Renderer Preset must be one of these: ${Object.keys(z).join(", ")}`), Ee(a.value, z[p]));
    const y = (C, x) => {
      const w = E(C), S = () => {
        if (p)
          return de(z[p], x);
      };
      if (w !== void 0)
        return w;
      const v = S();
      return v !== void 0 ? v : de(d, x);
    }, b = (C, x) => Kt(a.value, x, y(C, x));
    b(t.shadows, "shadowMap.enabled"), b(t.toneMapping, "toneMapping"), b(t.shadowMapType, "shadowMap.type"), rr < 150 && b(!t.useLegacyLights, "physicallyCorrectLights"), b(t.outputColorSpace, "outputColorSpace"), b(t.toneMappingExposure, "toneMappingExposure");
    const M = y(t.clearColor, "clearColor");
    M && a.value.setClearColor(
      M ? Ut(M) : new W(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: u, resume: f, onLoop: h } = G();
  return h(() => {
    i.value && !E(o) && a.value.render(e, i.value);
  }), f(), U(() => {
    u(), a.value.dispose(), a.value.forceContextLoss();
  }), {
    renderer: a
  };
}
const fe = (e) => typeof e == "function", nr = (e) => !!e && e.constructor === Array;
function sr(e) {
  const r = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
  }), r;
}
async function zr(e, r, t, o, s) {
  const { logError: i } = P(), n = new e();
  s && s(n), t && t(n);
  const l = (Array.isArray(r) ? r : [r]).map(
    (c) => new Promise((m, d) => {
      n.load(
        c,
        (u) => {
          u.scene && Object.assign(u, sr(u.scene)), m(u);
        },
        o,
        (u) => d(i("[useLoader] - Failed to load resource", u))
      );
    })
  );
  return nr(r) ? await Promise.all(l) : await l[0];
}
async function Nr(e, r) {
  const t = new Xe(r), o = (s) => new Promise((i, n) => {
    t.load(
      s,
      (a) => i(a),
      () => null,
      () => {
        n(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Zt(e)) {
    const s = await Promise.all(e.map((i) => o(i)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: i,
      normalMap: n,
      roughnessMap: a,
      metalnessMap: l,
      aoMap: c,
      alphaMap: m,
      matcap: d
    } = e;
    return {
      map: s ? await o(s) : null,
      displacementMap: i ? await o(i) : null,
      normalMap: n ? await o(n) : null,
      roughnessMap: a ? await o(a) : null,
      metalnessMap: l ? await o(l) : null,
      aoMap: c ? await o(c) : null,
      alphaMap: m ? await o(m) : null,
      matcap: d ? await o(d) : null
    };
  }
}
const ir = (e, { renderer: r, camera: t, raycaster: o }) => {
  const s = L(() => r.value.domElement), { x: i, y: n } = gt({ target: s }), { width: a, height: l, top: c, left: m } = vt(s), d = ({ x: v, y: _ }) => {
    if (s.value)
      return {
        x: (v - m.value) / a.value * 2 - 1,
        y: -((_ - c.value) / l.value) * 2 + 1
      };
  }, u = ({ x: v, y: _ }) => {
    if (t.value)
      return o.value.setFromCamera(new Ze(v, _), t.value), o.value.intersectObjects(e.value, !1);
  }, f = (v) => {
    const _ = d({
      x: (v == null ? void 0 : v.clientX) ?? i.value,
      y: (v == null ? void 0 : v.clientY) ?? n.value
    });
    return _ ? u(_) || [] : [];
  }, h = L(() => f()), p = R(), y = R(), b = (v, _) => {
    v.trigger({ event: _, intersects: f(_) });
  }, M = (v) => {
    b(y, v);
  };
  let C;
  const x = (v) => {
    var _;
    C = (_ = f(v)[0]) == null ? void 0 : _.object;
  }, w = (v) => {
    var _;
    v instanceof PointerEvent && C === ((_ = f(v)[0]) == null ? void 0 : _.object) && b(p, v);
  }, S = (v) => y.trigger({ event: v, intersects: [] });
  return s.value.addEventListener("pointerup", w), s.value.addEventListener("pointerdown", x), s.value.addEventListener("pointermove", M), s.value.addEventListener("pointerleave", S), U(() => {
    s != null && s.value && (s.value.removeEventListener("pointerup", w), s.value.removeEventListener("pointerdown", x), s.value.removeEventListener("pointermove", M), s.value.removeEventListener("pointerleave", S));
  }), {
    intersects: h,
    onClick: (v) => p.on(v).off,
    onPointerMove: (v) => y.on(v).off
  };
};
function Wr() {
  const { logWarning: e } = P();
  function r(i, n, a) {
    let l = null;
    return i.traverse((c) => {
      c[n] === a && (l = c);
    }), l || e(`Child with ${n} '${a}' not found.`), l;
  }
  function t(i, n, a) {
    const l = [];
    return i.traverse((c) => {
      c[n].includes(a) && l.push(c);
    }), l.length || e(`Children with ${n} '${a}' not found.`), l;
  }
  function o(i, n) {
    return r(i, "name", n);
  }
  function s(i, n) {
    return t(i, "name", n);
  }
  return {
    seek: r,
    seekByName: o,
    seekAll: t,
    seekAllByName: s
  };
}
const ar = ({ scene: e, contextParts: r }) => {
  const t = ve({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), o = A(/* @__PURE__ */ new Set()), s = (u) => {
    o.value.add(u);
  }, i = (u) => {
    o.value.delete(u);
  }, n = (u) => {
    Object.values(t).forEach((f) => f.delete(u)), i(u);
  }, a = (u) => {
    const { onClick: f, onPointerMove: h, onPointerEnter: p, onPointerLeave: y } = u;
    f && t.click.set(u, f), h && t.pointerMove.set(u, h), p && t.pointerEnter.set(u, p), y && t.pointerLeave.set(u, y);
  };
  e.userData.tres__registerAtPointerEventHandler = a, e.userData.tres__deregisterAtPointerEventHandler = n, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = i;
  const l = L(
    () => Yt(
      [
        ...Array.from(o.value),
        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
      ],
      ({ uuid: u }) => u
    )
  ), { onClick: c, onPointerMove: m } = ir(l, r);
  c(({ intersects: u, event: f }) => {
    var h;
    u.length && ((h = t.click.get(u[0].object)) == null || h(u[0], f));
  });
  let d;
  return m(({ intersects: u, event: f }) => {
    var M, C, x, w;
    const h = (M = u == null ? void 0 : u[0]) == null ? void 0 : M.object, { pointerLeave: p, pointerEnter: y, pointerMove: b } = t;
    d && d !== h && ((C = p.get(d)) == null || C(d, f)), h && (d !== h && ((x = y.get(h)) == null || x(u[0], f)), (w = b.get(h)) == null || w(u[0], f)), d = h || null;
  }), {
    registerObject: a,
    deregisterObject: n
  };
};
function Me(e) {
  let r = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const o = t.geometry, s = o.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, i = o.index ? o.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, n = o.attributes.normal ? o.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = o.attributes.uv ? o.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + i + n + a;
      r += l;
    }
  }), r;
}
function lr(e) {
  return (e / 1024).toFixed(2);
}
const Z = A({}), oe = (e) => Object.assign(Z.value, e);
function ur(e, r, t = 10) {
  const o = E(e) ? ht() : yt(L(() => E(r).parentElement)), s = Y(ue(o.width, t)), i = Y(ue(o.height, t)), n = L(() => s.value / i.value);
  return {
    height: i,
    width: s,
    aspectRatio: n
  };
}
function cr({
  scene: e,
  canvas: r,
  windowSize: t,
  disableRender: o,
  rendererOptions: s
}) {
  const i = ur(t, r), n = H(e), {
    camera: a,
    cameras: l,
    registerCamera: c,
    deregisterCamera: m,
    setCameraActive: d
  } = Nt({ sizes: i, scene: e }), { renderer: u } = or(
    {
      scene: e,
      canvas: r,
      options: s,
      contextParts: { sizes: i, camera: a },
      disableRender: o
    }
  ), f = {
    sizes: i,
    scene: n,
    camera: a,
    cameras: Y(l),
    renderer: u,
    raycaster: H(new et()),
    controls: A(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: oe,
    registerCamera: c,
    setCameraActive: d,
    deregisterCamera: m
  };
  K("useTres", f);
  const h = 100, p = wt({ every: h }), { isSupported: y, memory: b } = _t({ interval: h }), M = 160;
  let C = performance.now();
  const x = ({ timestamp: _ }) => {
    f.scene.value && (f.perf.memory.allocatedMem = Me(f.scene.value)), _ - C >= h && (C = _, f.perf.fps.accumulator.push(p.value), f.perf.fps.accumulator.length > M && f.perf.fps.accumulator.shift(), f.perf.fps.value = p.value, y.value && b.value && (f.perf.memory.accumulator.push(b.value.usedJSHeapSize / 1024 / 1024), f.perf.memory.accumulator.length > M && f.perf.memory.accumulator.shift(), f.perf.memory.currentMem = f.perf.memory.accumulator.reduce((Ae, Le) => Ae + Le, 0) / f.perf.memory.accumulator.length));
  };
  let w = 0;
  const S = 1, { pause: v } = we(({ delta: _ }) => {
    window.__TRES__DEVTOOLS__ && (x({ timestamp: performance.now() }), w += _, w >= S && (window.__TRES__DEVTOOLS__.cb(f), w = 0));
  }, { immediate: !0 });
  return U(() => {
    v();
  }), f;
}
function dr() {
  const e = Be("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const Vr = dr;
let g = null;
const { logError: pe } = P(), J = [
  "onClick",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave"
], fr = {
  createElement(e, r, t, o) {
    var n, a;
    if (o || (o = {}), o.args || (o.args = []), e === "template" || qt(e))
      return null;
    let s = e.replace("Tres", ""), i;
    if (e === "primitive") {
      (o == null ? void 0 : o.object) === void 0 && pe("Tres primitives need a prop 'object'");
      const l = o.object;
      s = l.type, i = Object.assign(l, { type: s, attach: o.attach, primitive: !0 });
    } else {
      const l = Z.value[s];
      l || pe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), i = new l(...o.args);
    }
    return i.isCamera && (o != null && o.position || i.position.set(3, 3, 3), o != null && o.lookAt || i.lookAt(0, 0, 0)), (o == null ? void 0 : o.attach) === void 0 && (i.isMaterial ? i.attach = "material" : i.isBufferGeometry && (i.attach = "geometry")), i.isObject3D && ((n = o == null ? void 0 : o.material) != null && n.isMaterial && (i.userData.tres__materialViaProp = !0), (a = o == null ? void 0 : o.geometry) != null && a.isBufferGeometry && (i.userData.tres__geometryViaProp = !0)), i.userData = {
      ...i.userData,
      tres__name: s
    }, i;
  },
  insert(e, r) {
    var o, s, i, n;
    r && r.isScene && (g = r);
    const t = r || g;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(g != null && g.userData.tres__registerCamera))
          throw new Error("could not find tres__registerCamera on scene's userData");
        (s = g == null ? void 0 : (o = g.userData).tres__registerCamera) == null || s.call(o, e);
      }
      if (e && J.some((a) => e[a])) {
        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
          throw new Error("could not find tres__registerAtPointerEventHandler on scene's userData");
        (n = g == null ? void 0 : (i = g.userData).tres__registerAtPointerEventHandler) == null || n.call(i, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var r, t;
    if (e) {
      if (e.isObject3D) {
        const o = e, s = (c) => {
          var d, u;
          const m = c;
          c.userData.tres__materialViaProp || ((d = m.material) == null || d.dispose(), m.material = void 0), c.userData.tres__geometryViaProp || ((u = m.geometry) == null || u.dispose(), m.geometry = void 0);
        }, i = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, n = g == null ? void 0 : g.userData.tres__deregisterBlockingObjectAtPointerEventHandler, a = (c) => {
          var m, d;
          if (!n)
            throw new Error("could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData");
          if ((d = g == null ? void 0 : (m = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(m, c), !i)
            throw new Error("could not find tres__deregisterAtPointerEventHandler on scene's userData");
          c && J.some((u) => c[u]) && (i == null || i(c));
        }, l = (c) => {
          const m = g == null ? void 0 : g.userData.tres__deregisterCamera;
          if (!m)
            throw new Error("could not find tres__deregisterCamera on scene's userData");
          c.isCamera && (m == null || m(c));
        };
        (r = e.removeFromParent) == null || r.call(e), o.traverse((c) => {
          s(c), l(c), a == null || a(c);
        }), s(o), l(o), a == null || a(o);
      }
      (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, r, t, o) {
    var s, i, n, a;
    if (e) {
      let l = e, c = r;
      if (e.isObject3D && c === "blocks-pointer-events") {
        o || o === "" ? (i = g == null ? void 0 : (s = g.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || i.call(s, e) : (a = g == null ? void 0 : (n = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || a.call(n, e);
        return;
      }
      let m = $(c), d = l == null ? void 0 : l[m];
      if (c === "args") {
        const f = e, h = t ?? [], p = o ?? [], y = e.userData.tres__name || e.type;
        y && h.length && !Xt(h, p) && (l = Object.assign(f, new Z.value[y](...o)));
        return;
      }
      if (l.type === "BufferGeometry") {
        if (c === "args")
          return;
        l.setAttribute(
          $(c),
          new tt(...o)
        );
        return;
      }
      if (c.includes("-") && d === void 0) {
        const f = c.split("-");
        d = f.reduce((h, p) => h[$(p)], l), c = f.pop(), m = c.toLowerCase(), d != null && d.set || (l = f.reduce((h, p) => h[$(p)], l));
      }
      let u = o;
      if (u === "" && (u = !0), fe(d)) {
        J.includes(r) || (Array.isArray(u) ? e[m](...u) : e[m](u));
        return;
      }
      !(d != null && d.set) && !fe(d) ? l[m] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
}, { render: pr } = je(fr);
oe(he);
function mr() {
  return Se().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Se() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const gr = typeof Proxy == "function", vr = "devtools-plugin:setup", hr = "plugin:settings:set";
let O, ee;
function yr() {
  var e;
  return O !== void 0 || (typeof window < "u" && window.performance ? (O = !0, ee = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (O = !0, ee = globalThis.perf_hooks.performance) : O = !1), O;
}
function wr() {
  return yr() ? ee.now() : Date.now();
}
class _r {
  constructor(r, t) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
    const o = {};
    if (r.settings)
      for (const n in r.settings) {
        const a = r.settings[n];
        o[n] = a.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${r.id}`;
    let i = Object.assign({}, o);
    try {
      const n = localStorage.getItem(s), a = JSON.parse(n);
      Object.assign(i, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return i;
      },
      setSettings(n) {
        try {
          localStorage.setItem(s, JSON.stringify(n));
        } catch {
        }
        i = n;
      },
      now() {
        return wr();
      }
    }, t && t.on(hr, (n, a) => {
      n === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (n, a) => this.target ? this.target.on[a] : (...l) => {
        this.onQueue.push({
          method: a,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (n, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
        method: a,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[a](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: a,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(r) {
    this.target = r;
    for (const t of this.onQueue)
      this.target.on[t.method](...t.args);
    for (const t of this.targetQueue)
      t.resolve(await this.target[t.method](...t.args));
  }
}
function br(e, r) {
  const t = e, o = Se(), s = mr(), i = gr && t.enableEarlyProxy;
  if (s && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !i))
    s.emit(vr, e, r);
  else {
    const n = i ? new _r(t, s) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: t,
      setupFn: r,
      proxy: n
    }), n && r(n.proxiedTarget);
  }
}
function Er(e, r) {
  const t = `▲ ■ ●${e}`;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
}
const ke = (e) => {
  const r = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && r.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const t = Me(e);
  return t > 0 && r.tags.push({
    label: `${lr(t)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (r.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), r.tags.push({
    label: `#${e.color.getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (r.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), r.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), r;
};
function Pe(e, r) {
  e.children.forEach((t) => {
    if (t.type === "HightlightMesh")
      return;
    const o = ke(t);
    r.children.push(o), Pe(t, o);
  });
}
const Cr = [], D = "tres:inspector", xr = ve({
  sceneGraph: null
});
function Mr(e, r) {
  br(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: Cr,
      app: e
    },
    (t) => {
      typeof t.now != "function" && Er(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), t.addInspector({
        id: D,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        t.sendInspectorTree(D);
      }, 1e3), setInterval(() => {
        t.notifyComponentUpdate();
      }, 5e3), t.on.getInspectorTree((i) => {
        if (i.inspectorId === D) {
          const n = ke(r.scene.value);
          Pe(r.scene.value, n), xr.sceneGraph = n, i.rootNodes = [n];
        }
      });
      let o = null, s = null;
      t.on.getInspectorState((i) => {
        if (i.inspectorId === D) {
          const [n] = r.scene.value.getObjectsByProperty("uuid", i.nodeId);
          if (!n)
            return;
          if (s && o && o.parent && s.remove(o), n.isMesh) {
            const a = tr(n);
            n.add(a), o = a, s = n;
          }
          i.state = {
            object: [
              {
                key: "uuid",
                editable: !0,
                value: n.uuid
              },
              {
                key: "name",
                editable: !0,
                value: n.name
              },
              {
                key: "type",
                editable: !0,
                value: n.type
              },
              {
                key: "position",
                editable: !0,
                value: n.position
              },
              {
                key: "rotation",
                editable: !0,
                value: n.rotation
              },
              {
                key: "scale",
                editable: !0,
                value: n.scale
              },
              {
                key: "geometry",
                value: n.geometry
              },
              {
                key: "material",
                value: n.material
              },
              {
                key: "color",
                editable: !0,
                value: n.color
              },
              {
                key: "intensity",
                editable: !0,
                value: n.intensity
              },
              {
                key: "castShadow",
                editable: !0,
                value: n.castShadow
              },
              {
                key: "receiveShadow",
                editable: !0,
                value: n.receiveShadow
              },
              {
                key: "frustumCulled",
                editable: !0,
                value: n.frustumCulled
              },
              {
                key: "matrixAutoUpdate",
                editable: !0,
                value: n.matrixAutoUpdate
              },
              {
                key: "matrixWorldNeedsUpdate",
                editable: !0,
                value: n.matrixWorldNeedsUpdate
              },
              {
                key: "matrixWorld",
                value: n.matrixWorld
              },
              {
                key: "visible",
                editable: !0,
                value: n.visible
              }
            ]
          };
        }
      }), t.on.editInspectorState((i) => {
        i.inspectorId === D && er(r.scene.value, i.nodeId, i.path, i.state.value);
      });
    }
  );
}
const Sr = ["data-scene", "data-tres"], kr = /* @__PURE__ */ ne({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: r }) {
    var h;
    const t = e, o = He(), { logWarning: s } = P(), i = A(), n = H(new rt()), { resume: a } = G(), l = (h = se()) == null ? void 0 : h.appContext.app, c = (p) => ne({
      setup() {
        var b;
        const y = (b = se()) == null ? void 0 : b.appContext;
        return y && (y.app = l), K("useTres", p), K("extend", oe), typeof window < "u" && Mr(y.app, p), () => ie(Ve, null, o != null && o.default ? o.default() : []);
      }
    }), m = (p) => {
      const y = c(p);
      pr(ie(y), n.value);
    }, d = (p, y = !1) => {
      n.value.children = [], y && (p.renderer.value.dispose(), p.renderer.value.renderLists.dispose(), p.renderer.value.forceContextLoss()), m(p), a();
    }, u = L(() => t.disableRender), f = H(null);
    return r({ context: f, dispose: () => d(f.value, !0) }), Re(() => {
      const p = i;
      f.value = cr({
        scene: n.value,
        canvas: p,
        windowSize: t.windowSize,
        disableRender: u,
        rendererOptions: t
      }), ar({ scene: n.value, contextParts: f.value });
      const { registerCamera: y, camera: b, cameras: M, deregisterCamera: C } = f.value;
      m(f.value);
      const x = () => {
        const w = new X(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        w.position.set(3, 3, 3), w.lookAt(0, 0, 0), y(w);
        const S = B(() => {
          M.value.length >= 2 && (w.removeFromParent(), C(w), S == null || S());
        });
      };
      ge(
        () => t.camera,
        (w, S) => {
          w && y(w), S && (S.removeFromParent(), C(S));
        },
        {
          immediate: !0
        }
      ), b.value || (s(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), x());
    }), (p, y) => (Ie(), $e("canvas", {
      ref_key: "canvas",
      ref: i,
      "data-scene": n.value.uuid,
      class: ze(p.$attrs.class),
      "data-tres": `tresjs ${Ne(zt).version}`,
      style: We({
        display: "block",
        width: "100%",
        height: "100%",
        position: p.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...p.$attrs.style
      })
    }, null, 14, Sr));
  }
}), Pr = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], Tr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !Pr.includes(e) || e === "primitive"
    }
  }
}, Fr = Tr, Ur = {
  mounted: (e, r) => {
    if (r.arg) {
      console.log(`v-log:${r.arg}`, e[r.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
class Te extends ot {
  constructor(r, t) {
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new ae();
    s.setAttribute("position", new le(o, 3)), s.computeBoundingSphere();
    const i = new nt({ fog: !1 });
    super(s, i), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new ae();
    a.setAttribute("position", new le(n, 3)), a.computeBoundingSphere(), this.add(new st(a, new ye({ side: it, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const { logWarning: me } = P();
let N, T;
const Ar = {
  DirectionalLight: at,
  PointLight: lt,
  SpotLight: ut,
  HemisphereLight: ct,
  RectAreaLight: Te
}, Gr = {
  mounted: (e) => {
    if (!e.isLight) {
      me(`${e.type} is not a light`);
      return;
    }
    N = Ar[e.type], e.parent.add(new N(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    T = e.parent.children.find((r) => r instanceof N), !(T instanceof Te) && T.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      me(`${e.type} is not a light`);
      return;
    }
    T = e.parent.children.find((r) => r instanceof N), T && T.dispose && T.dispose(), e.parent.remove(T);
  }
}, { logWarning: Lr } = P(), Qr = {
  updated: (e, r) => {
    const t = xe(r);
    if (!t) {
      Lr(`v-always-look-at: problem with binding value: ${r.value}`);
      return;
    }
    const { onLoop: o } = G();
    o(() => {
      e.lookAt(t);
    });
  }
}, { logWarning: Or } = P();
let k = null;
const qr = {
  updated: (e, r) => {
    var s;
    const t = xe(r);
    if (!t) {
      Or(`v-distance-to: problem with binding value: ${r.value}`);
      return;
    }
    k && (k.dispose(), e.parent.remove(k));
    const o = t.clone().sub(e.position);
    o.normalize(), k = new dt(o, e.position, e.position.distanceTo(t), 16776960), e.parent.add(k), console.table(
      [
        ["Distance:", e.position.distanceTo(t)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (e) => {
    k == null || k.dispose(), e.parent.remove(k);
  }
}, { logWarning: Dr } = P(), Jr = {
  mounted: (e, r) => {
    if (e.isCamera) {
      Dr(`Rotate the ${e.type} is not a good idea`);
      return;
    }
    const t = r.value ?? 0.01, o = A(r.modifiers.x || r.arg === "x" ? 1 : 0), s = A(r.modifiers.y || r.arg === "y" ? 1 : 0), i = A(r.modifiers.z || r.arg === "z" ? 1 : 0);
    o.value + s.value + i.value === 0 && (o.value = 1, s.value = 1);
    const n = new ft().setFromAxisAngle(new te(o.value, s.value, i.value).normalize(), t), { onLoop: a } = G();
    a(() => {
      e.applyQuaternion(n);
    });
  }
}, Yr = {
  install(e) {
    e.component("TresCanvas", kr);
  }
};
export {
  kr as TresCanvas,
  Z as catalogue,
  Yr as default,
  oe as extend,
  Ir as isProd,
  Ut as normalizeColor,
  $r as normalizeVectorFlexibleParam,
  Fr as templateCompilerOptions,
  sr as trasverseObjects,
  Nt as useCamera,
  zr as useLoader,
  P as useLogger,
  ar as usePointerEventHandler,
  ir as useRaycaster,
  G as useRenderLoop,
  or as useRenderer,
  Wr as useSeek,
  Nr as useTexture,
  Vr as useTres,
  dr as useTresContext,
  cr as useTresContextProvider,
  Qr as vAlwaysLookAt,
  qr as vDistanceTo,
  Gr as vLightHelper,
  Ur as vLog,
  Jr as vRotate
};
